{"conversations": [["integer \": public final class integer extends number implements comparable, lang \": public interface comparable, ** generic type **.", "A Java \"interface\" specifies a set of methods; any class t s this \"interface\" has to provide these methods. r e, here is the source code for \"Comparable\", which is an\n\"interface\" defined in the package \"java.lang\":\npublic interface Comparable<T> {\n    public int compareTo(T o);\n}\nThis \"interface\" definition uses a type parameter, \"T\", h s \"Comparable\" a **generic type**.\nIn order to implement this \"interface\", a class has to\n- Specify the type \"T\" refers to, and\n- Provide a d d \"compareTo\" that takes an object as a parameter and s n \"int\".\nFor example, here's the source code for \"java.lang.Integer\":\npublic final class Integer extends Number implements Comparable<Integer> {\n    public int compareTo(Integer anotherInteger) {\n        int thisVal = this.value;\n        int anotherVal = anotherInteger.value;\n        return (thisVal<anotherVal ? -1 : (thisVal==anotherVal ? 0 : 1));\n    }\n    // other methods omitted\n}\nThis class extends \"Number\", so it inherits the methods d e variables of \"Number\"; and it implements\n\"Comparable<Integer>\", so it provides a d named \"compareTo\" that takes an \"Integer\" d s an \"int\".\nWhen a class declares that it implements an \"interface\", the r s that it provides all methods defined by the\n\"interface\"."], ["uses, implementation, compareto", "As an aside, this implementation of \"compareTo\" uses the"], ["ternary operator \", sometimes written \"?:\"., p :// thinkdast, ternary", "\"ternary operator\", sometimes written \"?:\".  If you are t r with it, you can read about it t p://thinkdast.com/ternary."], ["library developers avoid g, linkedlist \", whenever possible, provides two implementations", "The Java Collections Framework (JCF) defines an \"interface\" called\n\"List\" and provides two implementations, \"ArrayList\" and\n\"LinkedList\".\nThe \"interface\" defines what it means to be a \"List\"; y s that implements this \"interface\" has to provide a r set of methods, including \"add\", \"get\",\n\"ArrayList\" and \"LinkedList\" provide these methods, o y can be used interchangeably. A method written to work with a\n\"List\" will work with an \"ArrayList\", \"LinkedList\",\nwhenever possible and avoids specifying \"LinkedList\" or\n\"ArrayList\" unless it is necessary. For example, the e e is declared to be a \"List\", and \"getList\" s a \"List\", but neither specifies which kind of list.\nThis style is called **interface-based programming**,\nor more casually, \"programming to an interface\"\nHere we are talking about the general idea of an interface,\nnot a Java \"interface\".\nWhen you use a library, your code should only depend on the interface,\nlike \"List\".  It should not depend on a c n, like \"ArrayList\". That way, if the n s in the future, the code that uses it will still work.\nOn the other hand, if the interface changes, the code that depends n t has to change, too.  That's why library developers avoid g s unless absolutely necessary."], ["remove \",, 20", "\"remove\", and about 20 more."], ["** encapsulates **, e l elements, e e", "or any other object that implements \"List\".\n\"ListClientExample\" doesn't do anything useful, but it has e l elements of a class that **encapsulates** a\n\"List\"; that is, it contains a \"List\" as an e e.  I'll use this class to make a point, and then you'll k h it in the first exercise.\nThe \"ListClientExample\" constructor initializes \"list\" by\nThe important thing about this example is that it uses \"List\""], ["linkedlist \"; e r method called, new listclientexample (); list list, public static void main", "Here's a contrived example that demonstrates the point:\npublic class ListClientExample {\n    private List list;\n    public ListClientExample() {\n        list = new LinkedList();\n    }\n    private List getList() {\n        return list;\n    }\n    public static void main(String[] args) {\n        ListClientExample lce = new ListClientExample();\n        List list = lce.getList();\n        System.out.println(list);\n    }\n}\n**instantiating** (that is, creating) a new \"LinkedList\"; e r method called \"getList\" returns a reference to e l \"List\" object; and \"main\" contains a few lines f e to test these methods."], ["arraylist \", u, use, r", "If you change your mind and decide to use an \"ArrayList\", u y have to change the constructor; you don't have to make any r s."], ["see http :// thinkdast, interbaseprog )., com", "(see http://thinkdast.com/interbaseprog)."], ["selectsort ): public class selectionsort, */ public static void swapelements, */ public static void selectionsort", "For example, here's an implementation of a simple algorithm d n sort (see http://thinkdast.com/selectsort):\npublic class SelectionSort {\n    /**\n     * Swaps the elements at indexes i and j.\n     */\n    public static void swapElements(int[] array, int i, int j) {\n        int temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n    /**\n     * Finds the index of the lowest value\n     * starting from the index at start (inclusive)\n     * and going to the end of the array.\n     */\n    public static int indexLowest(int[] array, int start) {\n        int lowIndex = start;\n        for (int i = start; i < array.length; i++) {\n            if (array[i] < array[lowIndex]) {\n                lowIndex = i;\n            }\n        }\n        return lowIndex;\n    }\n    /**\n     * Sorts the elements (in place) using selection sort.\n     */\n    public static void selectionSort(int[] array) {\n        for (int i = 0; i < array.length; i++) {\n            int j = indexLowest(array, i);\n            swapElements(array, i, j);\n        }\n    }\n}\nThe first method, \"swapElements\", swaps two elements of e y. Reading and writing elements are constant time operations,\nThe second method, \"indexLowest\", finds the index of the t t of the array starting at a given index, \"start\". h e through the loop, it accesses two elements of the array d s one comparison. Since these are all constant time operations,\nThe third method, \"selectionSort\", sorts the array. It loops from\n0 to n-1, so the loop executes n times. h e, it calls \"indexLowest\" and then performs a constant e n, \"swapElements\".\nThe first time \"indexLowest\" is called, t s n comparisons. The second time, it s n-1 comparisons, and so on. The total number of comparisons is n + n-1 + n-2 + ... + 1 + 0. The sum of this series is n(n+1)/2, which s l to n^2; and that means that \"selectionSort\""], ["location f e first, total number f, h one multiplication", "because if we know the size of the elements and the location f e first, we can compute the location of any other t h one multiplication and one addition, d e are constant time operations. Since everything in\n\"swapElements\" is constant time, the whole method is t e.\n\"indexLowest\", the number of operations is l o n. We call it n times, so the total number f s is proportional to n^2."], ["really matter, entire array, start \",", "it doesn't really matter which ones we count. To keep it simple, let's t the number of comparisons.\n- If \"start\" is 0, \"indexLowest\" traverses the entire\n  array, and the total number of comparisons is the length of\n  the array, which I'll call n.\n- If \"start\" is 1, the number of comparisons is n-1.\n- In general, the number of comparisons is n - \"start\", so\n  \"indexLowest\" is linear."], ["quadratic", "is quadratic."], ["different way, think, result", "To get to the same result a different way, we can think of"], ["nested loop, time, indexlowest", "\"indexLowest\" as a nested loop. Each time we call"], ["r time algorithm followed, constant time algorithms belong, linear operation n times", "All constant time algorithms belong to a set called O(1). So another y o say that an algorithm is constant time is to say that it is in O(1).\nSimilarly, all linear algorithms belong to O(n), and all c s belong to O(n^2). This way of classifying algorithms is called\nThis notation provides a convenient way to write general rules about w s behave when we compose them. For example, if you perform a r time algorithm followed by a constant algorithm, the total n e is linear. Using ∈ to mean \"is a member of\":\nIn fact, if you perform a linear operation any number of times,\nk, the total is linear, as long as k is a t t does not depend on n.\nIf f ∈ O(n) and k is a constant, kf ∈ O(n).\nBut if you perform a linear operation n times, the result s c:\nO(n). The leading constant, 2, and the additive term, 1, e t important for this kind of analysis. Similarly, n^2 + 100n + 1000 s n O(n^2).  Don't be distracted by the big numbers!\n\"Order of growth\" is another name for the same idea.  An order f h is a set of algorithms whose runtimes are in the same big O\ncategory; for example, all linear algorithms belong to the same r f growth because their runtimes are in O(n)."], ["e p :// thinkdast, n ), nf ∈, e l treatment", "\"big O notation\".\nNOTE: I am providing a casual definition of big O notation. For a e l treatment, e p://thinkdast.com/bigo.\nIf f ∈ O(n) and g ∈ O(1), f+g ∈ O(n).\nIf f ∈ O(n), nf ∈ O(n^2)."], ["perform two linear operations, still linear, total", "If you perform two linear operations, the total is still linear:"], ["n ), f, f ∈, n ).", "If f ∈ O(n) and g ∈ O(n), f+g ∈ O(n)."], ["f e total number, largest exponent, operations", "In general, we only care about the largest exponent of n. So f e total number of operations is 2n + 1, it belongs to"], ["order f e knights, round table },, f lining", "In this context, an \"order\" is a group, like the \\emph{Order f e Knights of the Round Table}, which is a group of knights, not a y f lining them up. So you can imagine the \\emph{Order of r s} as a set of brave, chivalrous, and particularly t s."], ["index ); array, examining e e, public e set", "For many methods, we can identify the order of growth by examining e e. For example, here's the implementation of \"get\" from\nwhich uses it. Here is our implementation of \"set\" from e s exercise:\n    public E set(int index, E element) {\n        E old = get(index);\n        array[index] = element;\n        return old;\n    }"], ["indexof \": public int indexof, myarraylist \": public e get, 0 || index >= size", "\"MyArrayList\":\n    public E get(int index) {\n        if (index < 0 || index >= size) {\n            throw new IndexOutOfBoundsException();\n        }\n        return array[index];\n    }\nOne slightly clever part of this solution is that it does not check e s of the array explicitly; it takes advantage of \"get\",\nNext we'll look at some linear methods. For example, here's y n of \"indexOf\":\n    public int indexOf(Object target) {\n        for (int i = 0; i<size; i++) {\n            if (equals(target, array[i])) {\n                return i;\n            }\n        }\n        return -1;\n    }\nThe analysis of \"remove\" is similar. Here's my implementation:\n    public E remove(int index) {\n        E element = get(index);\n        for (int i=index; i<size-1; i++) {\n            array[i] = array[i+1];\n        }\n        size--;\n        return element;\n    }"], ["loop never runs, set \", including, also constant time", "Everything in \"get\" is constant time, so \"get\" is t e. No problem.\nEverything in \"set\", including the invocation of \"get\", s t time, so \"set\" is also constant time.\nIt uses \"get\", which is constant time, and then loops through e y, starting from \"index\". If we remove the element at the d f the list, the loop never runs and this method is constant time. If e e the first element, we loop through all of the remaining elements,"], ["set \",, get \",, classify", "Now that we've classified \"get\", we can classify \"set\","], ["raises, invalid, index", "which raises an exception if the index is invalid."], ["return element == null, target == null, private boolean equals", "Each time through the loop, \"indexOf\" invokes \"equals\", o e have to classify \"equals\" first. Here it is:\n    private boolean equals(Object target, Object element) {\n        if (target == null) {\n            return element == null;\n        } else {\n            return target.equals(element);\n        }\n    }\nThis method invokes \"target.equals\"; the runtime of this d t depend on the size of \"target\" or \"element\", but t y doesn't depend on the size of the array, so we consider t t time for purposes of analyzing \"indexOf\"."], ["indexof \", everything inside, e loop execute, next question", "Getting back to \"indexOf\", everything inside the loop is t e, so the next question we have to consider is: how many times s e loop execute?"], ["target object right away, n r testing, test half", "If we get lucky, we might find the target object right away and n r testing only one element. If we are unlucky, we might have to t l of the elements. On average, we expect to test half of the elements,"], ["except n e special case, unlikely case, e know", "so this method is considered linear (except in the unlikely case t e know the target element is at the beginning of the array).\nwhich is linear. So, again, this method is considered linear (except n e special case where we know the element is at the end or a t e from the end)."], ["next 7 adds store 7 elements, next 3 adds store 3 elements, except n e special case", "Here's a version of \"add\" that takes n x and an element as parameters:\n    public void add(int index, E element) {\n        if (index < 0 || index > size) {\n            throw new IndexOutOfBoundsException();\n        }\n        // add the element to get the resizing\n        add(element);\n        // shift the other elements\n        for (int i=size-1; i>index; i--) {\n            array[i] = array[i-1];\n        }\n        // put the new one in the right place\n        array[index] = element;\n    }\nThis two-parameter version, called \"add(int, E)\", s e one-parameter version, called \"add(E)\", which puts e w element at the end. Then it shifts the other elements to the right,\nBefore we can classify the two-parameter \"add(int, E)\", we e o classify the one-parameter \"add(E)\":\n    public boolean add(E element) {\n        if (size >= array.length) {\n            // make a bigger array and copy over the elements\n            E[] bigger = (E[]) new Object[array.length * 2];\n            System.arraycopy(array, 0, bigger, 0, array.length);\n            array = bigger;\n        }\n        array[size] = element;\n        size++;\n        return true;\n    }\nassume we start with an array that has room for 2 elements.\n- The first time we call add, it finds unused space in the array, so it\n  stores 1 element.\n- The second time, it finds unused space in the array, so it stores 1\n  element.\n- The third time, we have to resize the array, copy 2 elements, and\n  store 1 element. Now the size of the array is 4.\n- The fourth time stores 1 element.\n- The fifth time resizes the array, copies 4 elements, and stores 1\n  element. Now the size of the array is 8.\n- The next 3 adds store 3 elements.\n- The next add copies 8 and stores 1. Now the size is 16.\n- The next 7 adds store 7 elements.\n\"add(int, E)\"? After calling \"add(E)\", it loops h t of the array and shifts elements. This loop is linear, except n e special case where we are adding at the end of the list. So"], ["total number f, e n elements, new element", "and puts the new element in the correct place.\nBy now you should see the pattern: to do n adds, we have o e n elements and copy n-2. So the total number f s is n + n - 2, which is 2n-2."], ["fixed amount --- e, parameter version turns, n unused space", "The one-parameter version turns out to be hard to analyze. If there s n unused space in the array, it is constant time, but if we have o e the array, it's linear because \"System.arraycopy\" s e proportional to the size of the array.\nIt might seem strange that an algorithm that is sometimes linear can e t time on average. The key is that we double the length of e y each time it gets resized. That limits the number of times h t gets copied. Otherwise --- if we add a fixed amount to e h of the array, rather than multiplying by a fixed amount --- e s doesn't work."], ["{\\ tt add, e )\", e )\"", "So is {\\tt add} constant time or linear?\n\"add\" as constant time.\nNow, if \"add(E)\" is constant time, what about\n\"add(int, E)\" is linear."], ["called ** amortized analysis **., operations per add, average number f", "We can classify this method by thinking about the average number f s per add over a series of n adds. For simplicity,\nTo get the average number of operations per add, we divide the total y n; the result is 2 - 2/n. As n gets big, e d term, 2/n, gets small. Invoking the principle that e y care about the largest exponent of n, we can think of\n% was an average over a hypothetical set of inputs when we looked at\n% confusing for experts (who know the difference between average\nThis way of classifying an algorithm, by computing the average time in a s of invocations, is called **amortized analysis**.  You n d more about it at"], ["stored 8 elements, stored 4 elements, stored 16 elements", "And so on. Adding things up:\n- After 4 adds, we've stored 4 elements and copied 2.\n- After 8 adds, we've stored 8 elements and copied 6.\n- After 16 adds, we've stored 16 elements and copied 14."], ["patrick notes potential confusion, use, note", "% NOTE: Patrick notes potential confusion in my use of average, which"], ["sequence, operations, indexof", "% indexOf, and here is the average over a sequence of operations."], ["leave, inclined, grounds", "% I am inclined to leave this alone on the grounds that it it more"], ["key idea, extra cost, case analysis", "% case analysis and amortized analysis) than for beginners (who will\nThe key idea is that the extra cost of copying the array s d, or \"amortized\", over a series of invocations."], ["bothered )., conjecture", "% not, I conjecture, be bothered)."], ["http :// thinkdast, com, amort", "http://thinkdast.com/amort."], ["myarraylist \": public boolean removeall, flag &= remove, collection <?> collection", "The last example we'll consider is \"removeAll\"; here's e n in \"MyArrayList\":\n    public boolean removeAll(Collection<?> collection) {\n        boolean flag = true;\n        for (Object obj: collection) {\n            flag &= remove(obj);\n        }\n        return flag;\n    }\n\"collection\". If \"collection\" contains m elements and e t we are removing from contains n elements, this method is in\n\"removeAll\" is linear. But if \"collection\" y s 1\\% of the elements in the list, \"removeAll\" s c."], ["remove \",, loop runs, loop", "Each time through the loop, \"removeAll\" invokes \"remove\",\nIn this method, the loop runs once for each element in"], ["always contains 100, r e, fewer elements", "which is linear.  So it is tempting to think that \"removeAll\" s c.  But that's not necessarily the case.\n\"removeAll\" is linear with respect to n. But if the size of e n is proportional to n, \"removeAll\" is quadratic. r e, if \"collection\" always contains 100 or fewer elements,"], ["nm )., considered constant, size", "O(nm). If the size of \"collection\" can be considered constant,"], ["tempting shortcut f g loops, ** problem size **,, g e loops", "When we talk about **problem size**, we have to be l t which size, or sizes, we are talking about. This e s a pitfall of algorithm analysis: the tempting shortcut f g loops.  If there is one loop, the algorithm is n r.  If there are two loops (one nested inside the other), e m is often quadratic. But be careful! You have to k t how many times each loop runs. If the number of iterations s l to n for all loops, you can get away with just g e loops. But if, as in this example, the number of iterations is t s proportional to n, you have to give it more thought."], ["2 ); listnode node3, 1 ); listnode node2, two instance variables", "For the next exercise I provide a partial implementation of the \"List\"\ninterface that uses a linked list to store the elements.\nbut this section provides a brief introduction.\nThe \"ListNode\" object has two instance variables: \"data\" is a e to some kind of \"Object\", and \"next\" is a reference o e next node in the list. In the last node in the list, by convention,\n\"ListNode\" provides several constructors, allowing you to provide s r \"data\" and \"next\", or initialize them to the t e, \"null\".\nYou can think of each \"ListNode\" as a list with a single element,\nbut more generally, a list can contain any number of nodes. There e l ways to make a new list. A simple option is to create a set of\n\"ListNode\" objects, like this:\n        ListNode node1 = new ListNode(1);\n        ListNode node2 = new ListNode(2);\n        ListNode node3 = new ListNode(3);"], ["linked structures include trees, p :// thinkdast, n contain references", "If you are not familiar with linked lists, you can read about them t p://thinkdast.com/linkedlist,\nA data structure is \"linked\" if it is made up of objects, often called\n\"nodes\", that contain references to other nodes. In a d t, each node contains a reference to the next node in e t. Other linked structures include trees and graphs, in which s n contain references to more than one other node."], ["instance variables n e inside, public string tostring (), public listnode ()", "Here's a class definition for a simple node:\npublic class ListNode {\n    public Object data;\n    public ListNode next;\n    public ListNode() {\n        this.data = null;\n        this.next = null;\n    }\n    public ListNode(Object data) {\n        this.data = data;\n        this.next = null;\n    }\n    public ListNode(Object data, ListNode next) {\n        this.data = data;\n        this.next = next;\n    }\n    public String toString() {\n        return \"ListNode(\" + data.toString() + \")\";\n    }\n}\n(like \"ListNode\" and \"Integer\") and their instance variables n e inside."], ["null \"., null \"., null", "\"next\" is \"null\".\nAnd then link them up, like this:\n        node1.next = node2;\n        node2.next = node3;\n        node3.next = null;\n\"null\"."], ["u n, r e, node1 );", "Alternatively, you can create a node and link it at the same time. r e, if you want to add a new node at the beginning of a list, u n do it like this:\n        ListNode node0 = new ListNode(0, node1);"], ["four nodes containing, sequence, instructions", "After this sequence of instructions, we have four nodes containing the"], ["increasing order, node, next", "\"Integer\"s 0, 1, 2, and 3 as data, linked up in increasing order. In e t node, the \"next\" field is"], ["object diagram", "  In an object diagram,"], ["names inside boxes, variables appear, objects appear", "variables appear as names inside boxes, with arrows that show t y refer to.  Objects appear as boxes with their type on the outside"], ["array never gets garbage collected, array grows f, linked list implementation", "In \"MyArrayList\" from the previous exercise, the array grows f y, but it never shrinks. The array never gets garbage collected,\nOne advantage of the linked list implementation is that it shrinks n s are removed, and the unused nodes can get garbage d y."], ["like garbage collection, gets garbage collected, get garbage collected", "and the elements don't get garbage collected until the list itself s d.\n\"Node\" (and there shouldn't be), it will get garbage collected.\nAt that point, the reference to the second \"Node\" is removed, o t gets garbage collected, too. This process continues until l s are collected.\nbut it doesn't belong to the order of growth we expected. In s e Java that do a lot of work, like garbage collection, behind e s, this kind of bug can be hard to find."], ["public void clear (), clear, size", "Here is my implementation of the \"clear\" method:\n    public void clear() {\n        head = null;\n        size = 0;\n    }"], ["null \",, node \"., set", "When we set \"head\" to \"null\", we remove a reference to e t \"Node\". If there are no other references to that"], ["sure looks like, time operations, maybe e", "So how should we classify \"clear\"? The method itself contains o t time operations, so it sure looks like it's constant time. t n you invoke it, you make the garbage collector do work that's l to the number of elements. So maybe e d consider it linear!"], ["** performance bug **:, sometimes called, example", "This is an example of what is sometimes called a **performance bug**:"], ["right thing, sense, program", "a program that is correct in the sense that it does the right thing,"], ["remove \": public e remove, loop might run n times, 0 || index >= size", "My implementation of \"indexOf\" is below. Read through it and e f you can identify its order of growth before you read the explanation.\n    public int indexOf(Object target) {\n        Node node = head;\n        for (int i=0; i<size; i++) {\n            if (equals(target, node.data)) {\n                return i;\n            }\n            node = node.next;\n        }\n        return -1;\n    }\nSo what is the order of growth for this method?\n- Each time through the loop we invoke \"equals\", which is\n  constant time (it might depend on the size of \"target\" or\n  \"data\", but it doesn't depend on the size of the list). The\n  other operations in the loop are also constant time.\n- The loop might run n times, because in the worse case, we\n  might have to traverse the whole list.\nmethod. Again, you should try to classify it before you read e n.\n    public void add(int index, E element) {\n        if (index == 0) {\n            head = new Node(element, head);\n        } else {\n            Node node = getNode(index-1);\n            node.next = new Node(element, node.next);\n        }\n        size++;\n    }\nIf \"index==0\", we're adding the new \"Node\" at e g, so we handle that as a special case. Otherwise, we have o e the list to find the element at \"index-1\". We use e r method \"getNode\":\n    private Node getNode(int index) {\n        if (index < 0 || index >= size) {\n            throw new IndexOutOfBoundsException();\n        }\n        Node node = head;\n        for (int i=0; i<index; i++) {\n            node = node.next;\n        }\n        return node;\n    }\nSo, what's the order of growth for \"add\"?\n- \"getNode\" is similar to\n  \"indexOf\", and it is linear for the same reason.\n- In \"add\", everything before and after \"getNode\" is\n  constant time.\nFinally, let's look at \"remove\":\n    public E remove(int index) {\n        E element = get(index);\n        if (index == 0) {\n            head = head.next;\n        } else {\n            Node node = getNode(index-1);\n            node.next = node.next.next;\n        }\n        size--;\n        return element;\n    }\nIf \"index==0\", we handle that as a special case again. e e find the node at \"index-1\" and modify it to skip over"], ["make e u understand, create e w, e e collected", "Initially \"node\" gets a copy of \"head\", so they both r o the same \"Node\". The loop variable, \"i\", counts from 0 to\n\"size-1\".  Each time through the loop, we use \"equals\" o e if we've found the target. If so, we return \"i\" immediately.\nNormally we would check to make sure the next \"Node\" is not\nit throws an exception. Otherwise it traverses the list and returns e d Node.\nJumping back to \"add\", once we find the right \"Node\", we create e w \"Node\" and put it between \"node\" and \"node.next\". u t find it helpful to draw a diagram of this operation to make e u understand it.\n\"node.next\" and link directly to \"node.next.next\". s y removes \"node.next\" from the list, and it can e e collected."], ["index \"., removes, otherwise", "Otherwise we advance to the next \"Node\" in the list.\n\"index\". Then it removes the \"Node\" that contained it."], ["consistent h e actual number, null \",, loop ends", "\"null\", but in this case it is safe because the loop ends when e t to the end of the list (assuming \"size\" is consistent h e actual number of nodes in the list)."], ["loop without finding, target, return", "If we get through the loop without finding the target, we return"], ["\"- 1 \".", "\"-1\"."], ["people see two linear operations, invoke one operation, nested e e", "So the runtime of this method is proportional to the length of e t.\nWhen people see two linear operations, they sometimes think the t s quadratic, but that only applies if one operation is nested e e other. If you invoke one operation after the other, the s d. If they are both in O(n), the sum is also in"], ["two, together, parameter", "Next, here is my implementation of the two-parameter \"add\"\nSo all together, \"add\" is linear."], ["checks whether, index, getnode", "\"getNode\" checks whether \"index\" is out of bounds; if so,"], ["constant time except, uses, store", "\"remove\" uses \"get\" to find and store the element at\n\"remove\" is constant time except \"get\" and"], ["size, return, finally", "Finally, we decrement \"size\" and return the element we d t the beginning."], ["remove \"?, order, growth", "So, what's the order of growth for \"remove\"? Everything in"], ["getnode \",, remove, linear", "\"getNode\", which are linear. So \"remove\" is linear."], ["n ).", "O(n)."], ["following table summarizes, differences", "The following table summarizes the differences between"], ["myarraylist \",, e end, myarraylist", "\"MyLinkedList\" and \"MyArrayList\", where \"1\" means\nThe operations where \"MyArrayList\" has an advantage are adding t e end, removing from the end, getting and setting.\nThe operations where \"MyLinkedList\" has an advantage are g t the beginning and removing from the beginning."], ["r r, constant time, n means", "O(1) or constant time and n means O(n) r r."], ["r f growth, two implementations, operations", "For the other operations, the two implementations are in the same r f growth."], ["java provides, e n, e", "Which implementation is better? It depends on which operations you e y to use the most. And that's why Java provides more than e n, because it depends."], ["get enough data, problem sizes, problem size", "For the next exercise I provide a class called \"Profiler\" t s code that runs a method with a range of problem sizes,\nYou will use \"Profiler\" to classify the e f the \"add\" method for the Java implementations of\nBut you don't need to know much for the next exercise; even if u e not comfortable with anonymous classes, you n y and modify the example code.\nThe next step is to create the \"Profiler\" object, passing the\nThe \"Profiler\" provides \"timingLoop\" which uses the\nWhen you run the experiments, you might have to adjust e s. If \"startN\" is too low, the runtime might be o t to measure accurately. If \"endMillis\" is too low, you t t get enough data to see a clear relationship between problem size d e.\nThis code is in \"ProfileListAdd.java\", which you'll run in the t e. When I ran it, I got this output:\n4000, 3\n8000, 0\n16000, 1\n32000, 2\n64000, 3\n128000, 6\n256000, 18\n512000, 30\n1024000, 88\n2048000, 185\n4096000, 242\n8192000, 544\n16384000, 1325"], ["timing loop, runtime exceeds, problem size", "measures runtimes, and plots the results.\n\"timeMe\" method on the \"Timeable\" object several s h a range of values of n. \"timingLoop\" takes o s:\n- \"startN\" is the value of n the timing loop should\n  start at.\n- \"endMillis\" is a threshold in milliseconds. As\n  \"timingLoop\" increases the problem size, the runtime increases;\n  when the runtime exceeds this threshold, \"timingLoop\" stops.\nThe result from \"timingLoop\" is an \"XYSeries\" t s this data. If you pass this series to \"plotResults\", t s a plot like the one in"], ["n e code, new element, linkedlist \".", "\"ArrayList\" and \"LinkedList\".\n\"ArrayList\", which adds the new element at the end. I'll n e code and then show the results."], ["arraylist add end \"; profiler profiler, public static void profilearraylistaddend (), ** anonymous class **", "Here's an example that shows how to use the profiler:\n    public static void profileArrayListAddEnd() {\n        Timeable timeable = new Timeable() {\n            List<String> list;\n            public void setup(int n) {\n                list = new ArrayList<String>();\n            }\n            public void timeMe(int n) {\n                for (int i=0; i<n; i++) {\n                    list.add(\"a string\");\n                }\n            }\n        };\n        String title = \"ArrayList add end\";\n        Profiler profiler = new Profiler(title, timeable);\n        int startN = 4000;\n        int endMillis = 1000;\n        XYSeries series = profiler.timingLoop(startN, endMillis);\n        profiler.plotResults(series);\n    }\nIn order to use \"Profiler\", we need to create a \"Timeable\"\nobject that provides two methods: \"setup\" and \"timeMe\".\nThe code that creates \"timeable\" is an **anonymous class** t s a new implementation of the \"Timeable\" interface d s an instance of the new class at the same time. If you are t r with anonymous classes, you can read about them here:\n\"Timeable\" object stored as an instance variable. It invokes the"], ["whatever needs, empty list, e clock", "This method measures the time it takes to run \"add\" on an\nThe \"setup\" method does whatever needs to be done before we t e clock; in this case it creates an empty list. Then \"timeMe\""], ["whatever operation, n elements, trying", "does whatever operation we are trying to measure; in this case it s n elements to the list."], ["http :// thinkdast, com, anonclass", "http://thinkdast.com/anonclass."], ["title, timeable, parameters", "\"Timeable\" object and a title as parameters."], ["second column, problem size, pretty noisy", "The first column is problem size, n; the second column s e in milliseconds. The first few measurements are pretty noisy; t t have been better to set \"startN\" around 64000."], ["next section explains, interpret", "The next section explains how to interpret it."], ["total time r n adds, take constant time, add n elements", "Based on our understanding of how \"ArrayList\" works, we t e \"add\" method to take constant time when we add elements o e end. So the total time to add n elements should be linear.\nwhich is close to 1; and that suggests that the total time r n adds is linear, so each add is constant time, as expected."], ["could plot total runtime versus problem size, total time r n adds would, plot runtime versus n", "To test that theory, we could plot total runtime versus problem size,\nand we should see a straight line, at least for problem sizes that e g enough to measure accurately. Mathematically, we can write e n for that line: runtime = a + b n, where a is the intercept of the line and b is e e.\nOn the other hand, if \"add\" is linear, the total time r n adds would be quadratic. If we plot runtime versus m e, we expect to see a parabola. Or mathematically, something like: runtime = a + b n + c n^2. With perfect data, we might be able to tell the difference between a t line and a parabola, but if the measurements are noisy, it n e hard to tell. A better way to interpret noisy measurements is to t e and problem size on a **log-log** scale.\nWhy? Let's suppose that runtime is proportional to n^k, but e n't know what the exponent k is. We can write e p like this: runtime = a + b n + ... + c n^k. For large values of n, the term with the largest exponent s e most important, so: runtime ≈ c n^k, where ≈ means \"approximately equal\". Now, if e e the logarithm of both sides of this equation: log(runtime) ≈ log(c) + k log(n). This equation implies that if we plot runtime versus n on a g-log scale, we expect to see a straight line with t g(c) and slope k. We don't care much about e t, but the slope indicates the order of growth: f k=1, the algorithm is linear; if k=2, it's c."], ["estimate e e, straight line, previous section", "Looking at the figure in the previous section, you can estimate e e by eye. But when you call \"plotResults\" it computes a t s fit to the data and prints the estimated slope. In s e:\nEstimated slope = 1.06194352346708\nthat does **not** mean that the algorithm is linear. If the n e is proportional to n^k for any exponent k, e t to see a straight line with slope k. If the slope s e to 1, that suggests the algorithm is linear. If it is close to 2,"], ["one important point, straight line, graph like", "One important point: if you see a straight line on a graph like this,"], ["probably quadratic", "it's probably quadratic."], ["get one additional data point, timeme \",, run various", "In the previous exercise, we used \"Profiler.java\" to run various\nThis method is almost identical to \"profileArrayListAddEnd\". e y difference is in \"timeMe\", which uses the two-r n of \"add\" to put the new element at index 0. Also, e d \"endMillis\" to get one additional data point."], ["plotted runtime versus problem size, performance f g new elements, total time r n adds", "\"ArrayList\" and \"LinkedList\" operations with a range f m sizes. We plotted runtime versus problem size on a log-g e and estimated the slope of the resulting curve, which s e leading exponent of the relationship between runtime and m e.\nFor example, when we used the \"add\" method to add s o the end of an \"ArrayList\", we found that the total time o m n adds was proportional to n; that is, e d slope was close to 1. We concluded that performing n s is in O(n), so on average the time for a single add s t time, or O(1), which is what we expect based on m s.\n\"profileArrayListAddBeginning\", which tests the performance f g new elements at the beginning of an \"ArrayList\". Based on r s, we expect each add to be linear, because it has to shift e r elements to the right; so we expect n adds to e c.\nRemember that a straight line on this graph does **not** mean t e algorithm is linear. Rather, if the runtime is proportional o n^k for any exponent, k, we expect to see a t e with slope k. In this case, we expect the total time r n adds to be proportional to n^2, so we expect a t line with slope 2. In fact, the estimated slope is 1.992, h s so close I would be afraid to fake data this good."], ["use, patrick, note", "% NOTE: Again, Patrick is concerned that my use of \"average\" might"], ["describe amortized, think, series", "% be confusing, but I think it's reasonable to describe amortized\n% analysis as an average over a series of operations."], ["exercise asks, fill, body", "The exercise asks you to fill in the body of"], ["runprofiler (\" arraylist add beginning \", timeable, find n e {\\ tt solution, public static void profilearraylistaddbeginning ()", "Here's a solution, which you can find n e {\\tt solution} directory of the repository.\n    public static void profileArrayListAddBeginning() {\n        Timeable timeable = new Timeable() {\n            List<String> list;\n            public void setup(int n) {\n                list = new ArrayList<String>();\n            }\n            public void timeMe(int n) {\n                for (int i=0; i<n; i++) {\n                    list.add(0, \"a string\");\n                }\n            }\n        };\n        int startN = 4000;\n        int endMillis = 10000;\n        runProfiler(\"ArrayList add beginning\", timeable, startN, endMillis);\n    }"], ["right ): 4000, timing results, runtime n", "Here are the timing results (problem size on the left, runtime n s on the right):\n4000, 14\n8000, 35\n16000, 150\n32000, 604\n64000, 2518\n128000, 11555"], ["runprofiler (\" linkedlist add beginning \", timeable, public static void profilelinkedlistaddbeginning (), total time r n adds", "In the previous exercise you also profiled the performance of adding w s at the beginning of a \"LinkedList\". Based on r s, we expect each \"add\" to take constant time, because n a linked list, we don't have to shift the existing elements; we can t d a new node at the beginning. So we expect the total time r n adds to be linear.\nHere's a solution:\n    public static void profileLinkedListAddBeginning() {\n        Timeable timeable = new Timeable() {\n            List<String> list;\n            public void setup(int n) {\n                list = new LinkedList<String>();\n            }\n            public void timeMe(int n) {\n                for (int i=0; i<n; i++) {\n                    list.add(0, \"a string\");\n                }\n            }\n        };\n        int startN = 128000;\n        int endMillis = 2000;\n        runProfiler(\"LinkedList add beginning\", timeable, startN, endMillis);\n    }\n\"ArrayList\" with \"LinkedList\" and adjusting\nso each add is constant time."], ["replacing, make, changes", "We only had a make a few changes, replacing"], ["good range, startn, get", "\"startN\" and \"endMillis\" to get a good range of data."], ["previous batch, e e, 892 8192000", "The measurements were noisier than the previous batch; e e the results:\n128000, 16\n256000, 19\n512000, 28\n1024000, 77\n2048000, 330\n4096000, 892\n8192000, 1047\n16384000, 4755"], ["least squares fit, e l time, least approximately", "It's not a very straight line, and the slope is not exactly 1; the e f the least squares fit is 1.23. But these results indicate that e l time for n adds is at least approximately O(n),"], ["r g elements, adding elements, arraylist \".", "Adding elements at the beginning is one of the operations where e t \"LinkedList\" to be faster than \"ArrayList\". But r g elements at the end, we expect \"LinkedList\" to be slower."], ["total time r n adds, add n, entire list", "In my implementation, we have to traverse the entire list to add n t to the end, which is linear. So we expect the total time r n adds to be quadratic."], ["runprofiler (\" linkedlist add end \", timeable, public static void profilelinkedlistaddend (), public void timeme", "Well, it's not.  Here's the code:\n    public static void profileLinkedListAddEnd() {\n        Timeable timeable = new Timeable() {\n            List<String> list;\n            public void setup(int n) {\n                list = new LinkedList<String>();\n            }\n            public void timeMe(int n) {\n                for (int i=0; i<n; i++) {\n                    list.add(\"a string\");\n                }\n            }\n        };\n        int startN = 64000;\n        int endMillis = 1000;\n        runProfiler(\"LinkedList add end\", timeable, startN, endMillis);\n    }"], ["950 16384000, 9 256000, 9 128000", "Here are the results:\n64000, 9\n128000, 9\n256000, 21\n512000, 24\n1024000, 78\n2048000, 235\n4096000, 851\n8192000, 950\n16384000, 6160"], ["e got adding elements, expected based, estimated slope", "Again, the measurements are noisy and the line is not y t, but the estimated slope is 1.19, which is close to t e got adding elements at the beginning, and not very close to 2, h s what we expected based on our analysis. In fact, it is closer to 1,"], ["constant time, adding elements, suggests", "which suggests that adding elements at the end is constant time."], ["going", "What's going on?"], ["p :// thinkdast, http :// thinkdast, mylinkedlist \", uses", "My implementation of a linked list, \"MyLinkedList\", uses a y-linked list; that is, each element contains a link to the next,\nand the \"MyArrayList\" object itself has a link to the first node.\nBut if you read the documentation of \"LinkedList\" t p://thinkdast.com/linked,\nDoubly-linked list implementation of the List and e s. [...] All of the operations perform s d be expected for a doubly-linked list. Operations t x into the list will traverse the list from the beginning or e d, whichever is closer to the specified index.\nIf you are not familiar with doubly-linked lists, you can read e t them at http://thinkdast.com/doublelist,\nbut the short version is:\n- Each node contains a link to the next node and a link to the previous\n  node.\n- The \"LinkedList\" object contains links to the first and last\n  elements of the list.\n\"ArrayList\", \"MyLinkedList\" (singly-linked), and\n\"LinkedList\" (doubly-linked):"], ["says", "it says:"], ["quote, quote, end", "\\begin{quote}\n\\end{quote}"], ["remove elements, r n, e g", "So we can start at either end of the list and traverse it in r n. As a result, we can add and remove elements from e g and the end of the list in constant time!"], ["following table summarizes, performance, expect", "The following table summarizes the performance we expect from"], ["different implementations require different amounts, h r large problems, nodes scattered around", "The doubly-linked implementation is better than \"ArrayList\" r g and removing at the beginning, and just as good as\n\"ArrayList\" for adding and removing at the end. So the y e of \"ArrayList\" is for \"get\" and \"set\",\nwhich require linear time in a linked list, even if it is doubly-linked.\nmight be the better choice. If the runtime depends on adding d g elements near the beginning or the end, \"LinkedList\"\nBut remember that these recommendations are based on the order of h r large problems. There are other factors to consider:\n- If these operations don't take up a substantial fraction of the\n  runtime for your application --- that is, if your applications spends\n  most of its time doing other things --- then your choice of a\n  \"List\" implementation won't matter very much.\n- If the lists you are working with are not very big, you might not get\n  the performance you expect. For small problems, a quadratic algorithm\n  might be faster than a linear algorithm, or linear might be faster\n  than constant time. And for small problems, the difference probably\n  doesn't matter.\n- Also, don't forget about space. So far we have focused on runtime, but\n  different implementations require different amounts of space. In an\n  \"ArrayList\", the elements are stored side-by-side in a single\n  chunk of memory, so there is little wasted space, and computer\n  hardware is often faster with contiguous chunks. In a linked list,\n  each element requires a node with one or two links. The links take up\n  space (sometimes more than the data!), and with nodes scattered\n  around in memory, the hardware might be less efficient."], ["growth actually predicts, problem size, large enough", "If you know that the runtime of your application depends on the time t s to \"get\" and \"set\" elements, an \"ArrayList\"\nIn summary, analysis of algorithms provides some guidance for g a structures, but only if\n- The runtime of your application is important,\n- The runtime of your application depends on your choice of data\n  structure, and\n- The problem size is large enough that the order of growth actually\n  predicts which data structure is better."], ["might, better", "might be better."], ["software engineer without ever g f, long career, situation", "You could have a long career as a software engineer without ever g f in this situation."], ["** web search engine **, like google search, search engines like google, search engine", "A **web search engine**, like Google Search or Bing, takes a t f \"search terms\" and returns a list of web pages that are t o those terms (I'll discuss what \"relevant\" means later).  You n d more at http://thinkdast.com/searcheng, but I'll n t you need as we go along.\nThe essential components of a search engine are:\n- Crawling: We'll need a program that can download a web page, parse it,\n  and extract the text and any links to other pages.\n- Indexing: We'll need a data structure that makes it possible to look up a\n  search term and find the pages that contain it.\n- Retrieval: And we'll need a way to collect results from the Index and\n  identify pages that are most relevant to the search terms.\nWe'll start with the crawler.  The goal of a crawler is to discover d d a set of web pages. For search engines like Google and Bing,\nthe goal is to find all web pages, but often crawlers are d o a smaller domain. In our case, we will only read pages m a."], ["wikipedia page, r without, l use", "As a first step, we'll build a crawler that reads a Wikipedia page,\nfinds the first link, follows the link to another page, and repeats. We l use this crawler to test the \"Getting to Philosophy\" conjecture,\nTesting the conjecture will allow us to build the basic pieces of a r without having to crawl the entire web, or even all f a. And I think the exercise is kind of fun!"], ["states", "which states:"], ["quote, quote, end", "\\begin{quote}\n\\end{quote}"], ["usually eventually gets one, first lowercase link, main text", "Clicking on the first lowercase link in the main text of a a article, and then repeating the process for t s, usually eventually gets one to the Philosophy article.\nIn a few chapters, we'll work on the indexer, and then we'll get to e r."], ["p :// thinkdast, getphil {},, stated", "This conjecture is stated t p://thinkdast.com/getphil{},"], ["read, history", "and you can read its history there."], ["web browsers provide tools, tool called web inspector, use ** jsoup **,", "When you download a web page, the contents are written n t Markup Language, aka HTML.\nThe phrases \"This is a title\" and \"Hello world!\" are the text t y appears on the page; the other elements are **tags** t e how the text should be displayed.\nWhen our crawler downloads a page, it will need to parse the HTML n r to extract the text and find the links. To do that, we'll use\n**jsoup**, which is an open-source Java library that downloads d s HTML.\nMost web browsers provide tools for inspecting the DOM of the page u e viewing. In Chrome, you can right-click on any part of a web e d select \"Inspect\" from the menu that pops up. In Firefox, you n t-click and select \"Inspect Element\" from the menu. i s a tool called Web Inspector, which you can read about t p://thinkdast.com/safari.\nFor Internet Explorer, you can read the instructions t p://thinkdast.com/explorer.\n\"id=\"mw-content-text\"\". We'll use this element id to identify e n text of each article we download."], ["document object model tree, hello world !</ p, minimal html document", "For example, here is a minimal HTML document:\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>This is a title</title>\n  </head>\n  <body>\n    <p>Hello world!</p>\n  </body>\n</html>\nThe result of parsing HTML is a Document Object Model tree, or\n\"<head>\" and\n\"<title>\", and the"], ["linked data structure made, \"< html >\" tag, structure f e document", "**DOM tree**, that contains the elements of the document, g t and tags. The tree is a linked data structure made up of nodes; e s represent text, tags, and other document elements.\nThe relationships between the nodes are determined by the structure f e document. In the example above, the first node, called the\n**root**, is the \"<html>\" tag, h s links to the two nodes it contains,\n\"<body>\"; these nodes are the\nEach node contains links to its children; in addition, each e s a link to its **parent**, so from any node it is e o navigate up and down the tree. The DOM tree for real pages is y e complicated than this example."], ["\"< head >\" node, \"< body >\" node, ** children **", "**children** of the root node.\nThe \"<head>\" node has one child,\n\"<body>\" node has one child,"], ["\"< p >\", paragraph \")., stands", "\"<p>\" (which stands for \"paragraph\")."], ["java, com", "com/java."], ["first paragraph, main, highlighted", "The element that's highlighted is the first paragraph of the main t f the article, which is contained in a"], ["\"< div >\" element", "\"<div>\" element with"], ["select (\" p \");, programming_language )\"; // download, get (); // select", "jsoup makes it easy to download and parse web pages, and to navigate the\nDOM tree. Here's an example:\n    String url = \"http://en.wikipedia.org/wiki/Java_(programming_language)\";\n    // download and parse the document\n    Connection conn = Jsoup.connect(url);\n    Document doc = conn.get();\n    // select the content text and pull out the paragraphs.\n    Element content = doc.getElementById(\"mw-content-text\");\n    Elements paragraphs = content.select(\"p\");\n\"Jsoup.connect\" takes a URL as a \"String\" and makes a connection o e web server; the \"get\" method downloads the HTML, parses it,"], ["node \"< div id =\" mw, example demonstrates two ways, \"< div >\" element", "and returns a \"Document\" object, which represents the DOM.\n\"Document\" provides methods for navigating e e and selecting nodes. In fact, it provides so many methods, it n e confusing. This example demonstrates two ways to select nodes:\n- \"getElementById\" takes a \"String\" and searches the tree for an\n  element that has a matching \"id\" field. Here it selects the node\n  \"<div id=\"mw-content-text\" lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">\",\n  which appears on every Wikipedia page to identify the\n  \"<div>\" element that contains the main\n  text of the page, as opposed to the navigation sidebar and other\n  elements.\n  The return value from \"getElementById\" is an \"Element\"\n  object that represents this \"<div>\" and\n  contains the elements in the \"<div>\" as\n  children, grandchildren, etc.\n- \"select\" takes a \"String\", traverses the tree, and returns all\n  the elements with tags that match the \"String\". In this example, it\n  returns all paragraph tags that appear in \"content\". The return\n  value is an \"Elements\" object."], ["u know, important classes, classes", "Before you go on, you should skim the documentation of these classes o u know what they can do. The most important classes are"], ["node \", including, textnode \",, datanode \",", "\"Element\", \"Elements\", and \"Node\", which you can read\n\"Node\" represents a node in the DOM tree;  there are l s that extend \"Node\", including\n\"Element\", \"TextNode\", \"DataNode\", and \"Comment\".\n\"Elements\" is a \"Collection\" of \"Element\" objects."], ["", "about at"], ["p :// thinkdast, http :// thinkdast, http :// thinkdast", "http://thinkdast.com/jsoupelt,\nhttp://thinkdast.com/jsoupelts, d p://thinkdast.com/jsoupnode."], ["one class extends another, uml class diagram, hollow w", "  In a UML class diagram, a line with a hollow w d indicates that one class extends another.  For example, s m indicates that \"Elements\" extends \"ArrayList\"."], ["section ~\\ ref, get back, diagrams }.", "We'll get back to UML diagrams in Section~\\ref{uml-class-diagrams}."], ["life easier, class called, provide", "To make your life easier, I provide a class called"], ["first search \", h, wikinodeiterable \",, would appear", "\"WikiNodeIterable\" that lets you iterate through the nodes in a\n\"WikiNodeIterable\", which implements\n\"Iterable<Node>\".\n\"WikiNodeIterable\" performs a \"depth-first search\", h s the nodes in the order they would appear on the page.\nIn this example, we print a \"Node\" only if it is a"], ["select (\" p \"); element firstpara, html paragraph without, 0 ); iterable", "DOM tree. Here's an example that shows how to use it:\n    Elements paragraphs = content.select(\"p\");\n    Element firstPara = paragraphs.get(0);\n    Iterable<Node> iter = new WikiNodeIterable(firstPara);\n    for (Node node: iter) {\n        if (node instanceof TextNode) {\n            System.out.print(node);\n        }\n    }\n\"TextNode\" and ignore other types of \"Node\", y e \"Element\" objects that represent tags. The result is e n text of the HTML paragraph without any markup. The output is:"], ["previous one leaves, selects e, example picks", "This example picks up where the previous one leaves off. It selects e t paragraph in \"paragraphs\" and then creates a"], ["quote, quote, end", "\\begin{quote}\n\\end{quote}"], ["purpose computer programming language, oriented ,{[} 13 {]}, object", "Java is a general-purpose computer programming language that s t, class-based, object-oriented,{[}13{]} and y d ..."], ["stack data structure, might reasonably traverse, http :// thinkdast", "There are several ways you might reasonably traverse a tree, each h t applications. We'll start with \"depth-first search\", or DFS.\nDFS starts at the root of the tree and selects the first child. If e d has children, it selects the first child again. When it gets to a e with no children, it backtracks, moving up the tree to the t e, where it selects the next child if there is one; otherwise t s again. When it has explored the last child of the root, it's e.\nThere are two common ways to implement DFS, recursively and iteratively.\ntraversal. You can read about \"pre-order\", \"post-order\", and\n\"in-order\" traversals at http://thinkdast.com/treetrav.  r s application, the traversal order doesn't matter.\n(http://thinkdast.com/callstack) to p k of the child nodes and process them in the right order. As n e, we can use a stack data structure to keep track of e s ourselves; if we do that, we can avoid the recursion and e e tree iteratively."], ["private static void recursivedfs, making recursive calls, method gets invoked", "The recursive implementation is simple and elegant:\nprivate static void recursiveDFS(Node node) {\n    if (node instanceof TextNode) {\n        System.out.print(node);\n    }\n    for (Node child: node.childNodes()) {\n        recursiveDFS(child);\n    }\n}\nThis method gets invoked on every \"Node\" in the tree, g h the root. If the \"Node\" it gets is a \"TextNode\", t s the contents. If the \"Node\" has any children, it invokes\nBy making recursive calls, \"recursiveDFS\" uses the call stack"], ["recursivedfs, order, one", "\"recursiveDFS\" on each one of them in order."], ["e g, textnode, print", "In this example, we print the contents of each \"TextNode\" e g the children, so this is an example of a \"pre-order\""], ["n e stack data structure, e e two reasons, constant time operations", "Before I explain the iterative version of DFS, I'll n e stack data structure.  We'll start with the general concept of a k, which I'll call a \"stack\" with a lowercase \"s\". Then we'l k about two Java \"interfaces\" that define stack methods:\n\"Stack\" and \"Deque\".\nA stack is a data structure that is similar to a list: it is a n that maintains the order of the elements. The y e between a stack and a list is that the stack provides r s. In the usual convention, it provides:\n- \"push\": which adds an element to the top of the stack.\n- \"pop\": which removes and returns the top-most element from the stack.\n- \"peek\": which returns the top-most element without modifying\n  the stack.\n- \"isEmpty\": which indicates whether the stack is empty.\nBecause \"pop\" always returns the top-most element, a stack s o called a \"LIFO\", which stands for \"last in, first out\". An e to a stack is a \"queue\", which returns elements in e e order they are added; that is, \"first in, first out\", or FIFO.\nIt might not be obvious why stacks and queues are useful: they don't e any capabilities that aren't provided by lists; in fact, y e fewer capabilities. So why not use lists for everything? e e two reasons:\n- If you limit yourself to a small set of methods --- that is, a small\n  API --- your code will be more readable and less error-prone. For\n  example, if you use a list to represent a stack, you might\n  accidentally remove an element in the wrong order. With the stack API,\n  this kind of mistake is literally impossible. And the best way to\n  avoid errors is to make them impossible.\n- If a data structure provides a small API, it is easier to implement\n  efficiently. For example, a simple way to implement a stack is a\n  singly-linked list. When we push an element onto the stack, we add it\n  to the beginning of the list; when we pop an element, we remove it\n  from the beginning. For a linked list, adding and removing from the\n  beginning are constant time operations, so this implementation is\n  efficient. Conversely, big APIs are harder to implement efficiently.\nTo implement a stack in Java, you have three options:\n- Go ahead and use \"ArrayList\" or \"LinkedList\". If you use\n  \"ArrayList\", be sure to add and remove from the end,\n  which is a constant time operation. And be careful not to add elements\n  in the wrong place or remove them in the wrong order.\n- Java provides a class called \"Stack\" that provides the standard\n  set of stack methods. But this class is an old part of Java: it is not\n  consistent with the Java Collections Framework, which came later.\n- Probably the best choice is to use one of the implementations of the\n  \"Deque\" interface, like \"ArrayDeque\"."], ["abstract data type \"?, todo, term", "% TODO: introduce the term \"Abstract Data Type\"?"], ["ended queue \";, people say, deek \".", "\"Deque\" stands for \"double-ended queue\"; it's supposed to e d \"deck\", but some people say \"deek\". In Java, the"], ["p :// thinkdast, push \",, pop \",", "\"Deque\" interface provides \"push\", \"pop\",\n\"peek\", and \"isEmpty\", so you can use a \"Deque\" s a stack. It provides other methods, which you can read about t p://thinkdast.com/deque,"], ["use", "but we won't use them for now."], ["private static void iterativedfs, childnodes ()); collections, onto e k", "Here is an iterative version of DFS that uses an \"ArrayDeque\" o t a stack of \"Node\" objects:\n    private static void iterativeDFS(Node root) {\n        Deque<Node> stack = new ArrayDeque<Node>();\n        stack.push(root);\n        while (!stack.isEmpty()) {\n            Node node = stack.pop();\n            if (node instanceof TextNode) {\n                System.out.print(node);\n            }\n            List<Node> nodes = new ArrayList<Node>(node.childNodes());\n            Collections.reverse(nodes);\n            for (Node child: nodes) {\n                stack.push(child);\n            }\n        }\n    }\nThe loop continues until the stack is empty. Each time through, it s a \"Node\" off the stack. If it gets a \"TextNode\", it s e contents. Then it pushes the children onto the stack. In order o s the children in the right order, we have to push them onto e k in reverse order; we do that by copying the children into an\nOne advantage of the iterative version of DFS is that it is easier o t as a Java \"Iterator\"; you'll see how in the t r.\n\"List\" variable, like this:\nList<Node> deque = new LinkedList<Node>();\nAnd if you assign it like this:\nLinkedList<Node> deque = new LinkedList<Node>();"], ["root \",, root, root", "The parameter, \"root\", is the root of the tree we want o e, so we start by creating the stack and pushing the root o t."], ["arraylist \", reversing, arraylist \"., g h", "\"ArrayList\", reversing the elements in place, and then g h the reversed \"ArrayList\"."], ["arraydeque \", java provides another implementation, one last note, h e", "But first, one last note about the \"Deque\" interface: n n to \"ArrayDeque\", Java provides another implementation of\nimplements both interfaces, \"List\" and \"Deque\". h e you get depends on how you use it. For example, if you n a \"LinkedList\" object to a \"Deque\" variable, like this:\nDeqeue<Node> deque = new LinkedList<Node>();\nyou can use the methods in the \"Deque\" interface, but not l s in the \"List\" interface. If you assign it to a"], ["old friend, deque \",, linkedlist \".", "\"Deque\", our old friend \"LinkedList\". \"LinkedList\""], ["use, methods, methods", "you can use \"List\" methods but not all \"Deque\" methods."], ["less readable, e r, combine methods", "you can use all the methods. But if you combine methods m t interfaces, your code will be less readable and e r-prone."], ["repository, book", "In the repository for this book,"], ["one page per second, ant wikiphilosophy \",, next page", "you'll find some code to help you get started:\n- \"WikiNodeExample.java\" contains the code from the previous\n  chapter, demonstrating recursive and iterative implementations of\n  depth-first search (DFS) in a DOM tree.\n- \"WikiNodeIterable.java\" contains an \"Iterable\" class for\n  traversing a DOM tree. I'll explain this code in the next section.\n- \"WikiFetcher.java\" contains a utility class that uses jsoup to\n  download pages from Wikipedia. To help you comply with Wikipedia's\n  terms of service, this class limits how fast you can download pages;\n  if you request more than one page per second, it sleeps before\n  downloading the next page.\n- \"WikiPhilosophy.java\" contains an outline of the code you will\n  write for this exercise. We'll walk through it below.\n\"build.xml\".  If you run \"ant WikiPhilosophy\", it will n a simple bit of starter code."], ["ant build file, also find", "You'll also find the Ant build file"], ["previous chapter, iterative depth, first search", "In the previous chapter, I presented an iterative depth-first search"], ["root node onto, three methods, someone invokes", "(DFS), and suggested that an advantage of the iterative version,\nThis code is almost identical to the iterative version of DFS, but w t's split into three methods:\n- The constructor initializes the stack (which is implemented using an\n  \"ArrayDeque\") and pushes the root node onto it.\n- \"isEmpty\" checks whether the stack is empty.\n- \"next\" pops the next \"Node\" off the stack, pushes its\n  children in reverse order, and returns the \"Node\" it popped. If\n  someone invokes \"next\" on an empty \"Iterator\", it throws\n  an exception.\n\"Iterable\" is called for, which makes it easy and y n to separate the logic of the iteration (DFS) from r g we are doing on the nodes."], ["two classes, recursive version, five methods", "compared to the recursive version, is that it is easier to wrap in an\nIt might not be obvious that it is worthwhile to rewrite a y d method with two classes and five methods.  But now that we'e e it, we can use \"WikiNodeIterable\" anywhere an"], ["http :// thinkdast, node >\" interface, node node", "\"Iterator\" object. In this section we'll see how to do that.\nIf you are not familiar with the \"Iterator\" and \"Iterable\"\nhttp://thinkdast.com/iterable.\n\"Iterable<Node>\" interface  so we can e t in a for loop like this:\n    Node root = ...\n    Iterable<Node> iter = new WikiNodeIterable(root);\n    for (Node node: iter) {\n        visit(node);\n    }\nThe implementation of \"WikiNodeIterable\" follows a l a:\n- The constructor takes and stores a reference to the root\n  \"Node\".\n- The \"iterator\" method creates a returns an \"Iterator\"\n  object."], ["p :// thinkdast, read, r", "interfaces, you can read about them t p://thinkdast.com/r d"], ["override public boolean hasnext (), override public node next (), public class wikinodeiterable implements iterable", "Take a look at the contents of \"WikiNodeIterable.java\". The r s, \"WikiNodeIterable\" implements the\nHere's what it looks like:\npublic class WikiNodeIterable implements Iterable<Node> {\n    private Node root;\n    public WikiNodeIterable(Node root) {\n        this.root = root;\n    }\n    @Override\n    public Iterator<Node> iterator() {\n        return new WikiNodeIterator(root);\n    }\n}\nThe inner class, \"WikiNodeIterator\", does all the real work:\n    private class WikiNodeIterator implements Iterator<Node> {\n        Deque<Node> stack;\n        public WikiNodeIterator(Node node) {\n            stack = new ArrayDeque<Node>();\n            stack.push(root);\n        }\n        @Override\n        public boolean hasNext() {\n            return !stack.isEmpty();\n        }\n        @Override\n        public Node next() {\n            if (stack.isEmpty()) {\n                throw new NoSuchElementException();\n            }\n            Node node = stack.pop();\n            List<Node> nodes = new ArrayList<Node>(node.childNodes());\n            Collections.reverse(nodes);\n            for (Node child: nodes) {\n                stack.push(child);\n            }\n            return node;\n        }\n    }"], ["want, tree, traverse", "where \"root\" is the root of the tree we want to traverse and"], ["whatever, want, visit", "\"visit\" is a method that does whatever we want when we \"visit\""], ["node \".", "a \"Node\"."], ["u e multiple instances, creating multiple instances, leave enough time", "When you write a Web crawler, it is easy to download too many pages o t, which might violate the terms of service for the server you e g from. To help you avoid that, I provide a class called\n\"WikiFetcher\" that does two things:\n- It encapsulates the code we demonstrated in the previous chapter for\n  downloading pages from Wikipedia, parsing the HTML, and selecting the\n  content text.\n- It measures the time between requests and, if we don't leave enough\n  time between requests, it sleeps until a reasonable interval has\n  elapsed. By default, the interval is one second.\n\"WikiFetcher\" object and use it to handle all requests. If u e multiple instances of \"WikiFetcher\", they won't enforce e m interval between requests.\nNOTE: My implementation of \"WikiFetcher\" is simple, but it d e easy for someone to misuse it by creating multiple instances. u d avoid this problem by making \"WikiFetcher\" a \"singleton\","], ["select (\" p \"); return paragraphs, throws ioexception */ public elements fetchwikipedia, wikifetcher \": public class wikifetcher", "Here's the definition of \"WikiFetcher\":\npublic class WikiFetcher {\n    private long lastRequestTime = -1;\n    private long minInterval = 1000;\n    /**\n     * Fetches and parses a URL string,\n     * returning a list of paragraph elements.\n     *\n     * @param url\n     * @return\n     * @throws IOException\n     */\n    public Elements fetchWikipedia(String url) throws IOException {\n        sleepIfNeeded();\n        Connection conn = Jsoup.connect(url);\n        Document doc = conn.get();\n        Element content = doc.getElementById(\"mw-content-text\");\n        Elements paragraphs = content.select(\"p\");\n        return paragraphs;\n    }\n    private void sleepIfNeeded() {\n        if (lastRequestTime != -1) {\n            long currentTime = System.currentTimeMillis();\n            long nextRequestTime = lastRequestTime + minInterval;\n            if (currentTime < nextRequestTime) {\n                try {\n                    Thread.sleep(nextRequestTime - currentTime);\n                } catch (InterruptedException e) {\n                    System.err.println(\n                        \"Warning: sleep interrupted in fetchWikipedia.\");\n                }\n            }\n        }\n        lastRequestTime = System.currentTimeMillis();\n    }\n}\nThe only public method is \"fetchWikipedia\", which takes a URL s a \"String\" and returns an \"Elements\" collection that contains one\nThat's all there is to \"WikiFetcher\". Here's an example t s how it's used:\n    WikiFetcher wf = new WikiFetcher();\n    for (String url: urlList) {\n        Elements paragraphs = wf.fetchWikipedia(url);\n        processParagraphs(paragraphs);\n    }"], ["k familiar, dom element, content text", "DOM element for each paragraph in the content text. This code d k familiar."], ["time e e last request, elapsed time, sleepifneeded \",", "The new code is in \"sleepIfNeeded\", which checks the time e e last request and sleeps if the elapsed time is less than"], ["mininterval \",, milliseconds", "\"minInterval\", which is in milliseconds."], ["urllist, example, collection", "In this example, we assume that \"urlList\" is a collection of"], ["object returned, g h, fetchwikipedia \".", "\"String\"s, and \"processParagraphs\" is a method that does g h the \"Elements\" object returned by \"fetchWikipedia\"."], ["example demonstrates something important, create one", "This example demonstrates something important: you should create one"], ["p :// thinkdast, singleton, read", "which you can read about t p://thinkdast.com/singleton."], ["e next question, ** lookup **;, termcounter \",", "The fundamental operation of the index is a **lookup**;\nIn addition to the \"TermCounter\", which maps from search terms o s, we will define a class called \"Index\", which maps from a h term to a collection of pages where it appears. And that s e next question, which is how to represent a collection of pages."], ["corresponding ** value **., value pairs **, simplest implementation would", "specifically, we need the ability to look up a term and find all s t contain it. The simplest implementation would be a collection f s. Given a search term, we could iterate through the contents of e s and select the ones that contain the search term. But the e d be proportional to the total number of words on all the pages,\nA better alternative is a **map**, which is a data structure t s a collection of **key-value pairs** and provides a t y to look up a **key** and find the corresponding **value**.\nwhich maps from each search term to the number of times it appears in a e. The keys are the search terms and the values are the counts (o d \"frequencies\").\nIn this case, we'll need to combine two or more collections and find e s that appear in all of them. You might recognize this operation as"], ["would, way, slow", "which would be way too slow."], ["treeset \"., termcounter \"., termcounter \",", "For example, the first map we'll construct is a \"TermCounter\",\n\"HashSet\" and \"TreeSet\".\nNow that we've designed our data structures from the top down, we'l t them from the inside out, starting with \"TermCounter\"."], ["core java provides several implementations, java provides several implementations, set \", including", "Java provides an interface called \"Map\" that specifies e s a map should provide; the most important are:\n- \"get(key)\": This method looks up a key and returns the\n  corresponding value.\n- \"put(key, value)\": This method adds a new key-value pair to the\n  \"Map\", or if the key is already in the map, it replaces the\n  value associated with \"key\".\nJava provides several implementations of \"Map\", including the o e will focus on, \"HashMap\" and \"TreeMap\". In g s, we'll look at these implementations and analyze their performance.\nAs you might expect by now, Java provides a \"Set\" interface t s the operations a set should perform. It doesn't actually e t intersection, but it provides methods that make it possible o t intersection and other set operations efficiently. The core\nJava provides several implementations of \"Set\", including"], ["r decision, want, think", "Again, if we think about the operations we want to perform, that s r decision."], ["** set intersection **:, set f, two sets", "**set intersection**: the intersection of two sets is the set f s that appear in both."], ["method checks whether, method adds, given element", "\"Set\" methods are:\n- \"add(element)\": This method adds an element to a set; if the\n  element is already in the set, it has no effect.\n- \"contains(element)\": This method checks whether the given\n  element is in the set."], ["methods take ** regular expressions **, term ); return count == null, p h indexing web pages", "\"TermCounter\" is a class that represents a mapping from h s to the number of times they appear in a page. Here is the t t of the class definition:\npublic class TermCounter {\n    private Map<String, Integer> map;\n    private String label;\n    public TermCounter(String label) {\n        this.label = label;\n        this.map = new HashMap<String, Integer>();\n    }\n}\nThe instance variables are \"map\", which contains the mapping m s to counts, and \"label\", which identifies the document e s came from; we'll use it to store URLs.\n\"TermCounter\" provides \"put\" and \"get\", which e d like this:\n    public void put(String term, int count) {\n        map.put(term, count);\n    }\n    public Integer get(String term) {\n        Integer count = map.get(term);\n        return count == null ? 0 : count;\n    }\n\"put\" on a \"TermCounter\", it calls \"put\" on e d map.\n\"get\" on a \"TermCounter\", it calls \"get\" on e p, and then checks the result. If the term does not appear in e p, \"TermCount.get\" returns 0. Defining \"get\" this y s it easier to write \"incrementTermCount\", which takes a m d increases by one the counter associated with that term.\n    public void incrementTermCount(String term) {\n        put(term, get(term) + 1);\n    }\nIn addition, \"TermCounter\" provides these other methods to p h indexing Web pages:\n    public void processElements(Elements paragraphs) {\n        for (Node node: paragraphs) {\n            processTree(node);\n        }\n    }\n    public void processTree(Node root) {\n        for (Node node: new WikiNodeIterable(root)) {\n            if (node instanceof TextNode) {\n                processText(((TextNode) node).text());\n            }\n        }\n    }\n    public void processText(String text) {\n        String[] array = text.replaceAll(\"\\\\pP\", \" \").\n                              toLowerCase().\n                              split(\"\\\\s+\");\n        for (int i=0; i<array.length; i++) {\n            String term = array[i];\n            incrementTermCount(term);\n        }\n    }\n- \"processElements\" takes an \"Elements\" object, which is a\n  collection of jsoup \"Element\" objects. It iterates through the\n  collection and calls \"processTree\" on each.\n- \"processTree\" takes a jsoup \"Node\" that represents the\n  root of a DOM tree. It iterates through the tree to find the nodes\n  that contain text; then it extracts the text and passes it to\n  \"processText\".\n- \"processText\" takes a \"String\" that contains words, spaces,\n  punctuation, etc. It removes punctuation characters by replacing\n  them with spaces, converts the remaining letters to lowercase, then\n  splits the text into words. Then it loops through the words it found\n  and calls \"incrementTermCount\" on each.  The \"replaceAll\"\n  and \"split\" methods take **regular expressions** as parameters;\n  you can read more about them at http://thinkdast.com/regex.\nFinally, here's an example that demonstrates how \"TermCounter\" s d:\n    String url = \"http://en.wikipedia.org/wiki/Java_(programming_language)\";\n    WikiFetcher wf = new WikiFetcher();\n    Elements paragraphs = wf.fetchWikipedia(url);\n    TermCounter counter = new TermCounter(url);\n    counter.processElements(paragraphs);\n    counter.printCounts();\n\"TermCounter\" and uses it to count the words in the page."], ["e e new count, old count, new key", "To implement the mapping, I chose \"HashMap\", which is the t y-used \"Map\". Coming up in a few chapters, you will see w t works and why it is a common choice.\nthen use \"put\" to add a new key-value pair to the map. If e m is already in the map, we get the old count, add 1, and then e e new count, which replaces the old value."], ["** wrapper method **;, put, call", "\"put\" is just a **wrapper method**; when you call"], ["work, hand, get", "On the other hand, \"get\" actually does some work. When you call"], ["returns 0, add 1, term", "If the term has not been seen before, \"get\" returns 0; we add 1,"], ["main text, example uses, wikifetcher", "This example uses a \"WikiFetcher\" to download a page m a and parse the main text. Then it creates a"], ["test r g, next section, missing method", "In the next section, you'll have a chance to run this code and test r g by filling in a missing method."], ["single instance variable, provide starter code, public class mylinearmap", "As usual, I provide starter code and you will fill in the g s. Here's the beginning of the \"MyLinearMap\" s n:\npublic class MyLinearMap<K, V> implements Map<K, V> {\n    private List<Entry> entries = new ArrayList<Entry>();\n\"MyLinearMap\" implements \"Map\", which means it has o e the methods in the \"Map\" interface.\nA \"MyLinearMap\" object has a single instance variable,\nThere's not much to it; an \"Entry\" is just a container for a y d a value. This definition is nested inside \"MyLinearList\", o t uses the same type parameters, \"K\" and \"V\"."], ["class uses two type parameters, override public v getvalue (), override public k getkey ()", "This class uses two type parameters, \"K\", which is the type f e keys, and \"V\", which is the type of the values.\nobjects. Each \"Entry\" contains a key-value pair. Here is e n:\n    public class Entry implements Map.Entry<K, V> {\n        private K key;\n        private V value;\n        public Entry(K key, V value) {\n            this.key = key;\n            this.value = value;\n        }\n        @Override\n        public K getKey() {\n            return key;\n        }\n        @Override\n        public V getValue() {\n            return value;\n        }\n    }"], ["entries \",, entry, arraylist", "\"entries\", which is an \"ArrayList\" of \"Entry\""], ["get started, need, let", "That's all you need to do the exercise, so let's get started."], ["core methods e, seem possible, previous exercise", "In this section I present a solution to the previous exercise d e the performance of the core methods.  Here are\nIn summary, the core methods are all linear, which is why we called s n \"MyLinearMap\" (ta-da!).\nIf we know that the number of entries will be small, this n t be good enough, but we can do better. In fact, there is n n of \"Map\" where all of the core methods e t time. When you first hear that, it might not seem possible.\nIn the next chapter, I'll present a solution, analyze the e f the core \"Map\" methods, and introduce a more t n."], ["equals \": private entry findentry, value )); return null, value ); return oldvalue", "\"findEntry\" and \"equals\":\nprivate Entry findEntry(Object target) {\n    for (Entry entry: entries) {\n        if (equals(target, entry.getKey())) {\n            return entry;\n        }\n    }\n    return null;\n}\nprivate boolean equals(Object target, Object obj) {\n    if (target == null) {\n        return obj == null;\n    }\n    return target.equals(obj);\n}\nincluding \"put\", \"get\", and \"remove\". Here's t y look like:\npublic V put(K key, V value) {\n    Entry entry = findEntry(key);\n    if (entry == null) {\n        entries.add(new Entry(key, value));\n        return null;\n    } else {\n        V oldValue = entry.getValue();\n        entry.setValue(value);\n        return oldValue;\n    }\n}\npublic V get(Object key) {\n    Entry entry = findEntry(key);\n    if (entry == null) {\n        return null;\n    }\n    return entry.getValue();\n}\npublic V remove(Object key) {\n    Entry entry = findEntry(key);\n    if (entry == null) {\n        return null;\n    } else {\n        V value = entry.getValue();\n        entries.remove(entry);\n        return value;\n    }\n}"], ["generally depend n e number, might depend, constant time", "The runtime of \"equals\" might depend on the size of the\n\"target\" and the keys, but does not generally depend n e number of entries, n. So \"equals\" is constant time."], ["might get lucky, r f entries, g r", "In \"findEntry\", we might get lucky and find the key we're g r at the beginning, but we can't count on it. In general, the r f entries we have to search is proportional to n, so\n\"findEntry\" is linear.\nWhat we are saying, in effect, is that you can find a needle in a k in constant time, regardless of how big the haystack is. It's c."], ["findentry \",, core methods, use", "Most of the core methods in \"MyLinearMap\" use \"findEntry\","], ["findentry \", everything else, takes r e, g n element", "After \"put\" calls \"findEntry\", everything else is t e. Remember that \"entries\" is an \"ArrayList\", so g n element at the end is constant time, on average. If the key s y in the map, we don't have to add an entry, but we have to call\n\"entries.remove\" might have to remove an element from e g or middle of the \"ArrayList\", and that takes r e. But that's OK: two linear operations are still linear.\nI'll explain how it works in two steps:\n- Instead of storing entries in one big \"List\", we'll break them\n  up into lots of short lists. For each key, we'll use a \\textbf{hash\n  code} (explained in the next section) to determine which list to use.\n- Using lots of short lists is faster than using just one, but as I'll\n  explain, it doesn't change the order of growth; the core operations\n  are still linear. But there is one more trick: if we increase the\n  number of lists to limit the number of entries per list, the result is\n  a constant-time map. You'll see the details in the next exercise, but\n  first: hashing!"], ["setvalue \",, also linear, linear", "\"entry.getValue\" and \"entry.setValue\", and those are h t time. Putting it all together, \"put\" is linear.\nBy the same reasoning, \"get\" is also linear."], ["slightly, remove, complicated", "\"remove\" is slightly more complicated because"], ["v >>( k );, e n fix, k times shorter", "To improve the performance of \"MyLinearMap\", we'll write a w s, called \"MyBetterMap\", that contains a collection of\n\"MyLinearMap\" objects. It divides the keys among the d s, so the number of entries in each map is smaller, which speeds up\nHere's the beginning of the class definition:\npublic class MyBetterMap<K, V> implements Map<K, V> {\n    protected List<MyLinearMap<K, V>> maps;\n    public MyBetterMap(int k) {\n        makeMaps(k);\n    }\n    protected void makeMaps(int k) {\n        maps = new ArrayList<MyLinearMap<K, V>>(k);\n        for (int i=0; i<k; i++) {\n            maps.add(new MyLinearMap<K, V>());\n        }\n    }\n}\n\"MyLinearMap\" objects. The constructor takes a parameter,\n\"MyBetterMap\" are k times shorter than the entry list in\n\"MyLinearMap\", we expect the search to be k s r. But the runtime is still proportional to n, so\n\"MyBetterMap\" is still linear. In the next exercise, you'll see how e n fix that."], ["methods, findentry, depend", "\"findEntry\" and the methods that depend on it."], ["method called, maps \",, instance variable", "The instance variable, \"maps\", is a collection of\n\"ArrayList\".\nIn Java, every \"Object\" provides a method called"], ["size ()- 1 \"., k entries per map, n entries split", "\"k\", that determines how many maps to use, at least initially.\nNow, the key to making this work is that we need some way to look at a y and decide which of the embedded maps it should go into. When we\n\"put\" a new key, we choose one of the maps; when we \"get\"\nOne possibility is to choose one of the sub-maps at random and p k of where we put each key. But how should we keep track? It t m like we could use a \"Map\" to look up the key and find e t sub-map, but the whole point of the exercise is to write n t implementation of a \"Map\". We can't assume we y e one.\nthen use the remainder operator, \"\\%\", which guarantees that e t is between 0 and \"maps.size()-1\". So \"index\" s s a valid index into \"maps\". Then \"chooseMap\" s a reference to the map it chose.\nWe use \"chooseMap\" in both \"put\" and \"get\", so n e look up a key, we get the same map we chose when we added the key. At t, we should --- I'll explain a little later why this might t k.\nIf there are n entries split up among k sub-maps,\nthere will be n/k entries per map, on average. When we look p a key, we have to compute its hash code, which takes some time, then e h the corresponding sub-map."], ["e right sub, pretty simple, embedded maps", "Then \"makeMaps\" creates the embedded maps and stores them in an\nPretty simple, right? In both methods, we use \"chooseMap\" to d e right sub-map and then invoke a method on the sub-map."], ["remember, put, key", "the same key, we have to remember where we put it."], ["** hash function **,, ** hash code **., hash function", "A better approach is to use a **hash function**, which takes an\n**hash code**.  Importantly, if it sees the same \"Object\"\nmore than once, it always returns the same hash code. That way, if e e the hash code to store a key, we'll get the same hash code when e k it up.\n\"hashCode\" that computes a hash function. The implementation f s method is different for different objects; we'll see an e n.\narbitrarily. Otherwise we use \"hashCode\" to get an integer,"], ["object \",, object \",, integer called", "\"Object\", any \"Object\", and returns an integer called a"], ["get \": public v put, key ); return map, key ); return map", "Here's a helper method that chooses the right sub-map for a n key:\nprotected MyLinearMap<K, V> chooseMap(Object key) {\n    int index = 0;\n    if (key != null) {\n        index = Math.abs(key.hashCode()) % maps.size();\n    }\n    return maps.get(index);\n}\nIf \"key\" is \"null\", we choose the sub-map with index 0,\nHere's my implementation of \"put\" and \"get\":\npublic V put(K key, V value) {\n  MyLinearMap<K, V> map = chooseMap(key);\n    return map.put(key, value);\n}\npublic V get(Object key) {\n    MyLinearMap<K, V> map = chooseMap(key);\n    return map.get(key);\n}"], ["make sure, non, negative", "apply \"Math.abs\" to make sure it is non-negative,"], ["works, think, performance", "That's how it works; now let's think about performance."], ["entry lists", "Because the entry lists in"], ["override public int hashcode (), like \"\" ac \"\", override public boolean equals", "The fundamental requirement for a hash function is that the same t d produce the same hash code every time. For immutable objects,\n\"SillyString\", but I'll use it to show how a class can e s own hash function:\n    @Override\n    public boolean equals(Object other) {\n        return this.toString().equals(other.toString());\n    }\n    @Override\n    public int hashCode() {\n        int total = 0;\n        for (int i=0; i<innerString.length(); i++) {\n            total += innerString.charAt(i);\n        }\n        return total;\n    }\n\"hashCode\". This is important. In order to work properly,\n\"equals\" has to be consistent with \"hashCode\", which s t if two objects are considered equal --- that is, \"equals\"\nreturns \"true\" --- they should have the same hash code. But s t only works one way; if two objects have the same hash code,\n\"hashCode\" works by iterating through the characters in the\nThis hash function satisfies the requirement: if two\nthey will get the same hash code.\nbecause it returns the same hash code for many different strings. If o s contain the same letters in any order, they will have the e h code. And even if they don't contain the same letters, they t d the same total, like \"\"ac\"\" and \"\"bb\"\".\nIf many objects have the same hash code, they end up in the e b-map.  If some sub-maps have more entries than others, the p n we have k maps might be much less than k. So one of the s f a hash function is to be uniform; that is, it should be y y to produce any value in the range.  You can read more t g good hash functions t p://thinkdast.com/hash."], ["relatively easy, mutable state, k r", "that's relatively easy. For objects with mutable state, we have to k r.\nAs an example of an immutable object, I'll define a class called"], ["string \": public class sillystring, public string tostring (), objects contain embedded strings", "\"SillyString\" that encapsulates a \"String\":\npublic class SillyString {\n    private final String innerString;\n    public SillyString(String innerString) {\n        this.innerString = innerString;\n    }\n    public String toString() {\n        return innerString;\n    }\nNotice that \"SillyString\" overrides both \"equals\" and\n\"innerString\". So two \"SillyString\" objects are equal f r \"innerString\" instance variables are equal.\n\"SillyString\" objects contain embedded strings that are equal,"], ["useful, class, called", "This class is not very useful, which is why it's called"], ["necessarily, equal", "they don't necessarily have to be equal."], ["tostring \",, works, returns", "\"equals\" works by invoking \"toString\", which returns"], ["int \", java converts, unicode code point, integer using", "\"String\" and adding them up. When you add a character to an \"int\",\nJava converts the character to an integer using its Unicode code point."], ["know anything, unicode, understand", "You don't need to know anything about Unicode to understand s e, but if you are curious, you can read more at"], ["http :// thinkdast, com, codepoint", "http://thinkdast.com/codepoint."], ["yield good performance, works correctly, might", "This works correctly, but it might not yield good performance,"], ["override public int hashcode (), string \": public class sillyarray, private final char [] array", "\"String\"s are immutable, and \"SillyString\" is also e e \"innerString\" is declared to be \"final\". Once u e a \"SillyString\", you can't make \"innerString\" r o a different \"String\", and you can't modify the \"String\" t s to. Therefore, it will always have the same hash code.\nBut let's see what happens with a mutable object. Here's a n r \"SillyArray\", which is identical to \"SillyString\",\nexcept that it uses an array of characters instead of a \"String\":\npublic class SillyArray {\n    private final char[] array;\n    public SillyArray(char[] array) {\n        this.array = array;\n    }\n    public String toString() {\n        return Arrays.toString(array);\n    }\n    @Override\n    public boolean equals(Object other) {\n        return this.toString().equals(other.toString());\n    }\n    @Override\n    public int hashCode() {\n        int total = 0;\n        for (int i=0; i<array.length; i++) {\n            total += array[i];\n        }\n        System.out.println(total);\n        return total;\n    }\n\"SillyArray\" also provides \"setChar\", which makes t e to modify the characters in the array:\npublic void setChar(int i, char c) {\n    this.array[i] = c;\n}\nthe hash code after the mutation is 441. With a different hash code,\nIn general, it is dangerous to use mutable objects as keys in a s that use hashing, which includes \"MyBetterMap\" and"], ["new sillyarray (\" word1 \". tochararray ()); map, c '); integer value, contents f e array", "Now suppose we create a \"SillyArray\" and add it to a map:\nSillyArray array1 = new SillyArray(\"Word1\".toCharArray());\nmap.put(array1, 1);\nThe hash code for this array is 461. Now if we modify the contents f e array and then try to look it up, like this:\narray1.setChar(0, 'C');\nInteger value = map.get(array1);"], ["wrong sub, hashmap \"., good idea", "there's a good chance we'll go looking in the wrong sub-map. In t e, we won't find the key, even though it is in the map. And that's d.\n\"HashMap\". If you can guarantee that the keys won't be d e they are in the map, or that any changes won't affect the h e, it might be OK. But it is probably a good idea to avoid it."], ["diagram also shows, would start piling, number f b", "If the number of entries in the biggest sub-map is proportional o n/k, and k grows in proportion to n, several of the core\nSuppose the initial number of sub-maps, k, is 2, and the d r is 1. Now let's see how much work it takes to \"put\" a s of keys. As the basic \"unit of work\", we'll count the number f s we have to hash a key and add it to a sub-map.\nThis diagram also shows why it is important to double the number f b-maps, k, when we rehash. If we only add to k d of multiplying, the towers would be too close together d y would start piling up. And that would not be t e."], ["methods become constant time, target ); return map, key ); return map", "\"MyBetterMap\" methods become constant time:\n    public boolean containsKey(Object target) {\n        MyLinearMap<K, V> map = chooseMap(target);\n        return map.containsKey(target);\n    }\n    public V get(Object key) {\n        MyLinearMap<K, V> map = chooseMap(key);\n        return map.get(key);\n    }\n    public V remove(Object key) {\n        MyLinearMap<K, V> map = chooseMap(key);\n        return map.remove(key);\n    }\nEach method hashes a key, which is constant time, and then invokes a d on a sub-map, which is constant time."], ["e also takes 1 unit, takes 1 unit, average work per", "So far, so good. But the other core method, \"put\", is a e r to analyze. When we don't have to rehash, it is constant time,\nbut when we do, it's linear. In that way, it's similar to\nFor the same reason, \"MyHashMap.put\" turns out to e t time if we average over a series of invocations.\nThe first time we call \"put\" it takes 1 unit of work. The d e also takes 1 unit. The third time we have to rehash, so it takes 2\nwhich shows that the average work per \"put\" is about 2 units. d t means that \"put\" is constant time on average."], ["see section ~\\ ref, section ~\\ ref, add }.", "\"ArrayList.add\", which we analyzed in Section~\\ref{classifying-add}.\n(see Section~\\ref{classifying-add})."], ["amortized analysis, based, argument", "Again, the argument is based on amortized analysis"], ["takes 1 unit, takes 4 units, 1 unit", "units to rehash the existing keys and 1 unit to hash the new key.\nNow the size of the hash table is 4, so the next time we call\n\"put\", it takes 1 unit of work. But the next time we have o h, which takes 4 units to rehash the existing keys and 1 unit o h the new key."], ["one fills e e, uniform height, next tower", "As the arrows suggest, if we knock down the towers, each one fills e e before the next tower. The result is a uniform height of 2 units,"], ["get \",, containskey \",, shown", "We've shown that \"containsKey\", \"get\", and \"remove\""], ["data structures small enough, matter w g, fit n e", "are constant time, and \"put\" is constant time on average. We d take a minute to appreciate how remarkable that is. e e of these operations is pretty much the same no matter w g the hash table is. Well, sort of.\nRemember that our analysis is based on a simple model of n e each \"unit of work\" takes the same amount of time. l s are more complicated than that. In particular, they e y fastest when working with data structures small enough to fit n e; somewhat slower if the structure doesn't fit in cache but l s in memory; and much slower if the structure doesn't fit n y."], ["find e g key, possibly keys )., particularly efficient way", "Another limitation of this implementation is that hashing doesn't p f we are given a value rather than a key: \"containsValue\" s r because it has to search all of the sub-maps. And e s no particularly efficient way to look up a value and find e g key (or possibly keys)."], ["public void clear (), ). clear ();, size ();", "And there's one more limitation: some of the methods that were t e in \"MyLinearMap\" have become linear. For example:\n    public void clear() {\n        for (int i=0; i<maps.size(); i++) {\n            maps.get(i).clear();\n        }\n    }"], ["number f b, sub, proportional", "\"clear\" has to clear all of the sub-maps, and the number f b-maps is proportional to n, so it's linear. Fortunately,"], ["used, operation, often", "this operation is not used very often, so for most applications s f is acceptable."], ["next section, check whether, constant time", "Before we go on, we should check whether \"MyHashMap.put\" is y t time.\nBefore you read the next section, you should track down the error, x t, and confirm that \"put\" is now constant time, as expected."], ["ant profilemapput \"., ant build, runtime", "Run \"ant build\" to compile the e s. Then run \"ant ProfileMapPut\". It measures the runtime of"], ["run e r, myhashmap \", instead, near 1", "\"HashMap.put\" (provided by Java) with a range of problem sizes,\n\"MyHashMap\", instead of Java's \"HashMap\". Run e r again and see if the slope is near 1. You might have o t \"startN\" and \"endMillis\" to find a range f m sizes where the runtimes are more than a few milliseconds, t t more than a few thousand."], ["plots runtime versus problem size, get something similar, total time", "and plots runtime versus problem size on a log-log scale. If s n is constant time, the total time for n s d be linear, so the result should be a straight line with slope\n1. When I ran this code, the estimated slope was close to 1, which s t with our analysis. You should get something similar."], ["profiles, profilemapput, modify", "Modify \"ProfileMapPut.java\" so it profiles your implementation,"], ["surprise, slope, ran", "When I ran this code, I got a surprise: the slope was about 1.7,"], ["constant time, suggests, implementation", "which suggests that this implementation is not constant time after all."], ["performance bug \"., contains", "It contains a \"performance bug\"."], ["mybettermap \": public int size (), key ); size -= map, key ); size += map", "The problem with \"MyHashMap\" is in \"size\", which s d from \"MyBetterMap\":\n    public int size() {\n        int total = 0;\n        for (MyLinearMap<K, V> map: maps) {\n            total += map.size();\n        }\n        return total;\n    }\n\"MyFixedHashMap.java\".  Here's the beginning of the class definition:\npublic class MyFixedHashMap<K, V> extends MyHashMap<K, V> implements Map<K, V> {\n    private int size = 0;\n    public void clear() {\n        super.clear();\n        size = 0;\n    }\nRather than modify \"MyHashMap\", I define a new class t s it. It adds a new instance variable, \"size\", which s d to zero.\n\"size\".\nUpdating \"remove\" and \"put\" is a little more t e when we invoke the method on the superclass, we can't l r the size of the sub-map changed. Here's how I worked d t:\n    public V remove(Object key) {\n        MyLinearMap<K, V> map = chooseMap(key);\n        size -= map.size();\n        V oldValue = map.remove(key);\n        size += map.size();\n        return oldValue;\n    }\n\"size\" is correct.\nWe have the same problem here: when we invoke \"put\" on e b-map, we don't know whether it added a new entry. So we use the e n, subtracting off the old size and then adding in the new size.\nNow the implementation of the \"size\" method is simple:\n    public int size() {\n        return size;\n    }"], ["since e e, n e sub, w e", "To add up the total size it has to iterate the sub-maps. Since e e the number of sub-maps, k, as the number of entries,\n\"remove\" uses \"chooseMap\" to find the right sub-map, n s away the size of the sub-map. It invokes \"remove\" n e sub-map, which may or may not change the size of the sub-map,\ndepending on whether it finds the key. But either way, we add the w e of the sub-map back to \"size\", so the final value of"], ["g n keys, total time, time", "n, increases, k is proportional to n, so\nWhen I profiled this solution, I found that the total time for g n keys is proportional to n, which means that each \"put\" s t time, as it's supposed to be."], ["size \": public v put, v value, v oldvalue", "\"size\" is linear.\nAnd that makes \"put\" linear, too, because it uses \"size\":\n    public V put(K key, V value) {\n        V oldValue = super.put(key, value);\n        if (size() > maps.size() * FACTOR) {\n            rehash();\n        }\n        return oldValue;\n    }\n\"size\" is linear!"], ["pretty clearly constant time, constant time, wasted", "Everything we did to make \"put\" constant time is wasted if\nAnd that's pretty clearly constant time."], ["simple solution, instance variable, e e", "Fortunately, there is a simple solution, and we have seen it before: e e to keep the number of entries in an instance variable and update t r we call a method that changes it."], ["solution, repository, find", "You'll find my solution in the repository for this book, in"], ["n e superclass, maps ),, updating", "Updating \"clear\" is straightforward; we invoke \"clear\" n e superclass (which clears the sub-maps), and then update"], ["value ); size += map, key ); size -= map, size (); v oldvalue", "The rewritten version of \"put\" is similar:\n    public V put(K key, V value) {\n        MyLinearMap<K, V> map = chooseMap(key);\n        size -= map.size();\n        V oldValue = map.put(key, value);\n        size += map.size();\n        if (size() > maps.size() * FACTOR) {\n            size = 0;\n            rehash();\n        }\n        return oldValue;\n    }"], ["dashed line indicate, solid line indicate, solid head indicate", "One challenge of working with the code in this chapter is that we e l classes that depend on each other. Here are some of e s between the classes:\n- \"MyLinearMap\" contains a \"LinkedList\" and implements\n  \"Map\".\n- \"MyBetterMap\" contains many \"MyLinearMap\" objects and\n  implements \"Map\".\n- \"MyHashMap\" extends \"MyBetterMap\", so it also contains\n  \"MyLinearMap\" objects, and it implements \"Map\".\n- \"MyFixedHashMap\" extends \"MyHashMap\" and\n  implements \"Map\".\nDifferent relationships are represented by different arrows:\n- Arrows with a solid head indicate HAS-A relationships. For example,\n  each instance of \"MyBetterMap\" contains multiple instances of\n  \"MyLinearMap\", so they are connected by a solid arrow.\n- Arrows with a hollow head and a solid line indicate IS-A\n  relationships. For example, \"MyHashMap\" extends\n  \"MyBetterMap\", so they are connected by an IS-A arrow.\n- Arrows with a hollow head and a dashed line indicate that a class\n  implements an interface; in this diagram, every class implements\n  \"Map\"."], ["n use ** uml class diagrams **., uml class diagrams provide, several graphical standards defined", "To help keep track of relationships like these, software s n use **UML class diagrams**. UML stands for Unified g e\nA \"class diagram\" is one of several graphical standards defined by UML.\nUML class diagrams provide a concise way to represent a lot f n about a collection of classes. They are used during n s to communicate about alternative designs, during n s to maintain a shared mental map of the project, and g t to document the design."], ["see http :// thinkdast, uml )., com", "(see http://thinkdast.com/uml)."], ["class diagram, class, represented", "In a class diagram, each class is represented by a box, d s between classes are represented y s. me/."], ["** binary search tree **,, binary search trees work, u l use one", "At this point you should be familiar with the \"Map\" interface d e \"HashMap\" implementation provided by Java. And by making r n \"Map\" using a hash table, you should understand how\n\"HashMap\" works and why we expect its core methods to be t e.\nBecause of this performance, \"HashMap\" is widely used, but it s t the only implementation of \"Map\". There are a few reasons u t want another implementation:\n- Hashing can be slow, so even though \"HashMap\" operations are\n  constant time, the \"constant\" might be big.\n- Hashing works well if the hash function distributes the keys evenly\n  among the sub-maps.  But designing good hash functions is not easy,\n  and if too many keys end up in the same sub-map, the performance of\n  the \"HashMap\" may be poor.\n- The keys in a hash table are not stored in any particular order; in\n  fact, the order might change when the table grows and the keys are\n  rehashed. For some applications, it is necessary, or at least useful,\n  to keep the keys in order.\nIt is hard to solve all of these problems at the e e, but Java provides an implementation called \"TreeMap\" t s close:\n- It doesn't use a hash function, so it avoids the cost of hashing\n  and the difficulty of choosing a hash function.\n- Inside the \"TreeMap\", the keys are are stored in a\n  **binary search tree**, which makes it possible to traverse the\n  keys, in order, in linear time.\n- The runtime of the core methods is proportional to log n,\n  which is not quite as good as constant time, but it is still\n  very good.\nIn the next section, I'll explain how binary search trees work and then u l use one to implement a \"Map\". Along the way, we'll e e performance of the core map methods when implemented using a tree."], ["use e g algorithm, u n also check, tree contains nine keys", "A binary search tree (BST) is a tree where each node contains a key, d y \"node\" has the \"BST property\":\n- If \"node\" has a left child, all keys in the left subtree must\n  be less than the key in \"node\".\n- If \"node\" has a right child, all keys in the right subtree must\n  be greater than the key in \"node\".\nThis figure is from the Wikipedia page on binary search trees t p://thinkdast.com/bst, which u t find useful while you work on this exercise.\nThe key in the root is 8, and you can confirm that all keys to the t f the root are less than 8, and all keys to the right are greater. u n also check that the other nodes have this property.\nLooking up a key in a binary search tree is fast because we don't e o search the entire tree. Starting at the root, we can use e g algorithm:\n- Compare the key you are looking for, \"target\", to the key in\n  the current node. If they are equal, you are done.\n- If \"target\" is less than the current key, search the left tree.\n  If there isn't one, \"target\" is not in the tree.\n- If \"target\" is greater than the current key, search the right\n  tree. If there isn't one, \"target\" is not in the tree.\nAt each level of the tree, you only have to search one child. r e, if you look for \"target = 4\" in the previous diagram,\neven though the tree contains nine keys. In general, the number f s is proportional to the height of the tree, not the number f s in the tree.\nSo we expect that we can look up a key in a binary search tree in e l to log n. This is true if the tree is full, d n if the tree is only partially full. But it is not always true, s e will see."], ["go left, 8 \"., 6 \",", "you start at the root, which contains the key \"8\". Because\n\"target\" is less than \"6\", you go left. And then you d e key you are looking for."], ["takes four comparisons, go right, go left", "\"target\" is less than \"8\", you go left. Because\n\"target\" is greater than \"3\" you go right. Because\nIn this example, it takes four comparisons to find the target,"], ["log_2 n ≈ h, contains one node, level contains e", "So what can we say about the relationship between the height of e e, \"h\", and the number of nodes, n? Starting l d working up:\n- If \"h=1\", the tree only contains one node, so \"n=1\".\n- If \"h=2\", we can add two more nodes, for a total of\n  \"n=3\".\n- If \"h=3\", we can add up to four more nodes, for a total\n  of \"n=7\".\n- If \"h=4\", we can add up to eight more nodes, for a total\n  of \"n=15\".\nBy now you might see the pattern. If we number the levels of the tree from\n2^{i-1} nodes. And the total number of nodes in \"h\" levels is 2^h-1.\nIf we have n = 2^h - 1, we can take the logarithm base 2 of both sides: log_2 n ≈ h, which means that the height of the tree is proportional o g n, if the tree is full; that is, if each level contains e m number of nodes.\nO(log n)."], ["h \",, level, index", "\"1\" to \"h\", the level with index \"i\" can have up to"], ["takes time proportional, log time \",, log n", "An algorithm that takes time proportional to log n is called\n\"logarithmic\" or \"log time\", and it belongs to the order of growth"], ["unit tests, source files, previous section", "In the repository for this book, you'll find these source files:\n- \"MyTreeMap.java\" contains the code from the previous section\n  with outlines for the missing methods.\n- \"MyTreeMapTest.java\" contains the unit tests for\n  \"MyTreeMap\"."], ["source files, ant build, ant", "Run \"ant build\" to compile the source files. Then run \"ant"], ["next chapter, mytreemaptest \"., e k", "  MyTreeMapTest\".  Several tests should fail, because you have e k to do!\nWhen you are done, all tests should pass. In the next chapter, I'll o r my solutions and test the performance of the core methods."], ["suppresswarnings (\" unchecked \") comparable <?, value ); size ++; return null, used n n ~\\ ref", "I've provided outlines for \"get\" and \"containsKey\".  Both f m use \"findNode\", which is a private method I defined; it s t part of the \"Map\" interface. Here's how it starts:\n    private Node findNode(Object target) {\n        if (target == null) {\n            throw new IllegalArgumentException();\n        }\n        @SuppressWarnings(\"unchecked\")\n        Comparable<? super K> k = (Comparable<? super K>) target;\n        // TODO: FILL THIS IN!\n        return null;\n    }\nThe parameter \"target\" is the key we're looking for. If\n\"target\" is \"null\", \"findNode\" throws an exception.\nSome implementations of \"Map\" can handle \"null\" as a key,\nThe next lines show how we can compare \"target\" to a key in e e. From the signature of \"get\" and \"containsKey\", e r considers \"target\" to be an \"Object\". But we d o be able to compare keys, so we typecast \"target\" to\nFortunately, dealing with Java's type system is not the point of s e. Your job is to fill in the rest of \"findNode\". If t s a node that contains \"target\" as a key, it should n e node. Otherwise it should return \"null\". When you get s g, the tests for \"get\" and \"containsKey\" d s.\nUnlike your previous solution for \"findNode\", your solution for\n  starter code that handles the simple cases:\n    public V put(K key, V value) {\n        if (key == null) {\n            throw new IllegalArgumentException();\n        }\n        if (root == null) {\n            root = new Node(key, value);\n            size++;\n            return null;\n        }\n        return putHelper(root, key, value);\n    }\n    private V putHelper(Node node, K key, V value) {\n        // TODO: Fill this in.\n    }\n\"HashSet\" implementation of \"Set\", which we used n n~\\ref{exercise6}, doesn't maintain the order of the keys, t e \"LinkedHashSet\" implementation does.  You can read about t t http://thinkdast.com/linkedhashset.\n\"LinkedHashSet\":\n    public Set<K> keySet() {\n        Set<K> set = new LinkedHashSet<K>();\n        return set;\n    }"], ["keep things simple, throws n n, binary search tree", "but in a binary search tree, we need to be able to compare keys, o g with \"null\" is problematic. To keep things simple,\nthis implementation does not allow \"null\" as a key.\n\"target\" and a given key. Note that the values in the tree (s d to the keys) are not necessarily comparable, so we can't use\n\"compareTo\"; we have to invoke \"equals\" on \"target\".\n\"containsValue\" does have to search the whole tree, so s e is proportional to the number of keys, n, not e t of the tree, \"h\".\nIf you try to put \"null\" as a key, \"put\" throws n n.\nFill in \"putHelper\" so it searches the tree and:\n- If \"key\" is already in the tree, it replaces the old value with\n  the new, and returns the old value.\n- If \"key\" is not in the tree, it creates a new node, finds the\n  right place to add it, and returns \"null\".\nYou should finish off this method so it adds the keys from the tree to"], ["p :// thinkdast, super k >\",, k \".", "\"Comparable<? super K>\", which means t t is comparable to an instance of type \"K\", or any superclass of\n\"K\".  If you are not familiar with this use of \"e s\", you can read more t p://thinkdast.com/gentut."], ["take time proportional, take time proportional, p :// thinkdast", "Note that your solution should only search one path through the tree, o t should take time proportional to the height of the tree. You d t search the whole tree!\nIf the tree is empty, \"put\" creates a new node and s e instance variable \"root\".\nYour implementation of \"put\" should take time proportional to e t of the tree, h, not the number of elements, n. Ideally u d search the tree only once, but if you find it easier to h e, you can do that; it will be slower, but it doesn't change e r of growth.\n\"set\" in ascending order. HINT: you might want to write a r d; you might want to make it recursive; and you might want o d about in-order tree traversal t p://thinkdast.com/inorder."], ["put \"., next task, next method", "Your next task is to fill in \"containsValue\". To get you started,\nThe next method you should fill in is \"put\". I've provided"], ["increasing order according, equals \",, helper method", "I've provided a helper method, \"equals\", that compares\nin increasing order according to the \"compareTo\" method.  The"], ["puthelper \",, private method, otherwise", "Otherwise, it calls \"putHelper\", which is a private method I"], ["part, map, interface", "defined; it is not part of the \"Map\" interface."], ["http :// thinkdast, e documentation, keyset \".", "Finally, you should fill in the body of \"keySet\".  According o e documentation at http://thinkdast.com/mapkeyset, this d d return a \"Set\" that iterates the keys in order; that is,\nI've provided an outline of \"keySet\" that creates and returns a"], ["order, index", "\\index{in-order}"], ["todo, recursion, help", "% TODO: more help with recursion?"], ["suppresswarnings (\" unchecked \") comparable <?, findnode \": private node findnode, throw new illegalargumentexception ();", "In the previous exercise I gave you the outline of \"MyTreeMap\" d d you to fill in the missing methods. Now I'll present a n, starting with \"findNode\":\nprivate Node findNode(Object target) {\n    // some implementations can handle null as a key, but not this one\n    if (target == null) {\n            throw new IllegalArgumentException();\n    }\n    // something to make the compiler happy\n    @SuppressWarnings(\"unchecked\")\n    Comparable<? super K> k = (Comparable<? super K>) target;\n    // the actual search\n    Node node = root;\n    while (node != null) {\n        int cmp = k.compareTo(node.key);\n        if (cmp < 0)\n            node = node.left;\n        else if (cmp > 0)\n            node = node.right;\n        else\n            return node;\n    }\n    return null;\n}\n\"findNode\" is a private method used by \"containsKey\" and\n\"get\"; it is not part of the \"Map\" interface. e r \"target\" is the key we're looking for. I explained e t part of this method in the previous exercise:\n- In this implementation, \"null\" is not a legal value for a key.\n- Before we can invoke \"compareTo\" on \"target\", we have to\n  typecast it to some kind of \"Comparable\". The \"type wildcard\"\n  used here is as permissive as possible; that is, it works with any\n  type that implements \"Comparable\" and whose \"compareTo\"\n  method accepts \"K\" or any supertype of \"K\"."], ["right child, relatively simple, p variable", "After all that, the actual search is relatively simple. We initialize a p variable \"node\" so it refers to the root node. Each e h the loop, we compare the target to \"node.key\". If e t is less than the current key, we move to the left child. If it's r, we move to the right child. And if it's equal, we return e t node."], ["tree without finding, null \"., e e", "If we get to the bottom of the tree without finding the target, e e that it is not in the tree and return \"null\"."], ["previous exercise, runtime, explained", "As I explained in the previous exercise, the runtime of"], ["root f e tree, search e e tree, containsvaluehelper \", passing", "\"findNode\" is proportional to the height of the tree, not e r of nodes, because we don't have to search the whole tree. t r \"containsValue\", we have to search the values, not the keys;\nthe BST property doesn't apply to the values, so we have to search e e tree.\n\"containsValue\" takes the target value as a parameter d y invokes \"containsValueHelper\", passing the root f e tree as an additional parameter."], ["second case checks whether, third case makes, public boolean containsvalue", "My solution is recursive:\npublic boolean containsValue(Object target) {\n    return containsValueHelper(root, target);\n}\nprivate boolean containsValueHelper(Node node, Object target) {\n    if (node == null) {\n        return false;\n    }\n    if (equals(target, node.value)) {\n        return true;\n    }\n    if (containsValueHelper(node.left, target)) {\n        return true;\n    }\n    if (containsValueHelper(node.right, target)) {\n        return true;\n    }\n    return false;\n}\nHere's how \"containsValueHelper\" works:\n- The first \"if\" statement checks the base case of the recursion.\n  If \"node\" is \"null\", that means we have recursed to the\n  bottom of the tree without finding the \"target\", so we should\n  return \"false\". Note that this only means that the target did\n  not appear on one path through the tree; it is still possible that it\n  will be found on another.\n- The second case checks whether we've found what we're looking for. If\n  so, we return \"true\". Otherwise, we have to keep going.\n- The third case makes a recursive call to search for \"target\" in\n  the left subtree. If we find it, we can return \"true\"\n  immediately, without searching the right subtree. Otherwise, we keep\n  going.\n- The fourth case searches the right subtree. Again, if we find what we\n  are looking for, we return \"true\". Otherwise, having searched\n  the whole tree, we return \"false\"."], ["takes e l, every node, visits", "This method \"visits\" every node in the tree, so it takes e l to the number of nodes."], ["keys n e correct order, method visits every node, e left subtree", "The last method I asked you to write is \"keySet\", which s a \"Set\" that contains the keys from the tree in ascending order.\nIn other implementations of \"Map\", the keys returned by\n\"keySet\" are in no particular order, but one of the s f the tree implementation is that it is simple and efficient to t e keys. So we should take advantage of that.\nIn \"keySet\", we create a \"LinkedHashSet\", which is a\n\"addInOrder\" to traverse the tree.\nThe first parameter, \"node\", is initially the root of the tree,\nbut as you should expect by now, we use it to traverse the e y. \"addInOrder\" performs a classic \"in-r l\" of the tree.\nApplying the same argument recursively, we know that the elements m e left subtree are in order, as well as the elements from the t e.  And the base case is correct: if the subtree is empty, o s are added.  So we can conclude that this method adds all keys n e correct order.\nBecause this method visits every node in the tree, like"], ["set ); return set, private void addinorder, key ); addinorder", "Here's my solution:\npublic Set<K> keySet() {\n    Set<K> set = new LinkedHashSet<K>();\n    addInOrder(root, set);\n    return set;\n}\nprivate void addInOrder(Node node, Set<K> set) {\n    if (node == null) return;\n    addInOrder(node.left, set);\n    set.add(node.key);\n    addInOrder(node.right, set);\n}"], ["implementations )., set, set", "\"Set\" implementation that keeps the elements in order (e t other \"Set\" implementations). Then we call"], ["e return without adding anything, added n e correct order, bst property guarantees", "If \"node\" is \"null\", that means the subtree is empty, o e return without adding anything to \"set\". Otherwise we:\n- Traverse the left subtree in order.\n- Add \"node.key\".\n- Traverse the right subtree in order.\nRemember that the BST property guarantees that all nodes in the t e are less than \"node.key\", and all nodes in the t e are greater. So we know that \"node.key\" has been added n e correct order."], ["takes time proportional, containsvalue \",, n", "\"containsValue\", it takes time proportional to n."], ["always add e w node, almost 500 times faster, 3 log n grows", "In \"MyTreeMap\", the methods \"get\" and \"put\" e e proportional to the height of the tree, h. In the s e, we showed that if the tree is full --- if every level of the e s the maximum number of nodes --- the height of the tree s l to log n.\nAnd I claimed that \"get\" and \"put\" are logarithmic; t s, they take time proportional to log n. But for t s, there's no guarantee that the tree is full. In general,\nthe shape of the tree depends on the keys and what order they are added.\nI ran this code with \"n=16384\" and measured the runtime and e t of the final tree. Here's the output:\nTime in milliseconds = 151\nFinal size of MyTreeMap = 16384\nlog base 2 of size of MyTreeMap = 14.0\nFinal height of MyTreeMap = 33\nI included \"log base 2 of size of MyTreeMap\" to see how tall the e d be if it were full. The result indicates that a full tree h t 14 would contain 16,384 nodes.\nThe actual tree of random strings has height 33, which is y e than the theoretical minimum, but not too bad. To find one key in a n of 16,384, we only have to make 33 comparisons. Compared to a r search, that's almost 500 times faster.\nThis performance is typical with random strings or other keys that e d in no particular order. The final height of the tree might be 2-3\nlog n grows so slowly as n increases, it can e t to distinguish logarithmic time from constant time n e.\nAnd let's see what happens when we run it:\nTime in milliseconds = 1158\nFinal size of MyTreeMap = 16384\nlog base 2 of size of MyTreeMap = 14.0\nFinal height of MyTreeMap = 16384\nlonger. If you wonder why, take a look at the final height of the tree:\nIf you think about how \"put\" works, you can figure out what's g on. Every time we add a new key, it's larger than all of the s n the tree, so we always choose the right subtree, and always add e w node as the right child of the rightmost node. The result is an\n\"unbalanced\" tree that only contains right children.\nThe height of this tree is proportional to n, t g n, so the performance of \"get\" and \"put\" s r, not logarithmic.\n  In the balanced tree, the height is 4 and the total number f s is 2^4-1 = 15.  In the unbalanced tree with the same number f s, the height is 15."], ["n h two sample datasets, random strings, increasing order", "To see how this works out in practice, we'll test our n h two sample datasets: a list of random strings and a list f s in increasing order."], ["randomuuid (). tostring (); map, universally unique identifier \"., binary search trees", "Here's the code that generates random strings:\nMap<String, Integer> map = new MyTreeMap<String, Integer>();\nfor (int i=0; i<n; i++) {\n    String uuid = UUID.randomUUID().toString();\n    map.put(uuid, 0);\n}\n\"UUID\" is a class in the \"java.util\" package that n e a random \"universally unique identifier\". UUIDs are l r a variety of applications, but in this example we're g e of an easy way to generate random strings.\nHowever, binary search trees don't always behave so well. Let's see t s when we add keys in increasing order. Here's an example t s timestamps in nanoseconds and uses them as keys:\nMyTreeMap<String, Integer> map = new MyTreeMap<String, Integer>();\nfor (int i=0; i<n; i++) {\n    String timestamp = Long.toString(System.nanoTime());\n    map.put(timestamp, 0);\n}"], ["theoretical minimum, still proportional, much less", "times the theoretical minimum, but it is still proportional o g n, which is much less than n. In fact,"], ["seven times longer, previous case, bigger number", "\"System.nanoTime\" returns an integer with type \"long\" t s elapsed time in nanoseconds. Each time we call it, we get a t bigger number. When we convert these timestamps to strings,\nThe runtime is more than seven times longer than in the previous case."], ["increasing alphabetical order, appear", "they appear in increasing alphabetical order."], ["16384", "16384!"], ["initials f e inventors ),, avl tree (\" avl, could avoid adding keys", "There are two possible solutions to this problem:\n- You could avoid adding keys to the \"Map\" in order. But this is\n  not always possible.\n- You could make a tree that does a better job of handling keys if they\n  happen to be in order.\nThe second solution is better, and there are several ways to do it. e t common is to modify \"put\" so that it detects when the e s starting to become unbalanced and, if so, rearranges the nodes. s h this capability are called \"self-balancing\". n f-balancing trees include the AVL tree (\"AVL\" are the initials f e inventors), and the red-black tree, which is what the Java\n\"TreeMap\" uses.\n\"put\" in logarithmic time, but only if the keys are added in n r that keeps the tree sufficiently balanced. Self-balancing s d this problem by doing some additional work each time a new key s d."], ["example code, replace, mytreemap", "In our example code, if we replace \"MyTreeMap\" with the Java"], ["take less time, timestamps run faster, treemap \",", "\"TreeMap\", the runtimes are about the same for the random s d the timestamps. In fact, the timestamps run faster, even though y e in order, probably because they take less time to hash."], ["binary search tree, summary, implement", "In summary, a binary search tree can implement \"get\" and"], ["p :// thinkdast, balancing trees, balancing", "You can read more about self-balancing trees t p://thinkdast.com/balancing."], ["remove \",, previous exercise, implement", "In the previous exercise you didn't have to implement \"remove\","], ["middle f e tree, similar operations, remaining nodes", "but you might want to try it. If you remove a node from the middle f e tree, you have to rearrange the remaining nodes to restore the BST\nRemoving a node and rebalancing a tree are similar operations: if you o s exercise, you will have a better idea of how self-balancing s k."], ["p :// thinkdast, r u, probably figure", "property.  You can probably figure out how to do that on your own, r u can read the explanation t p://thinkdast.com/bstdel."], ["web page, search term, search term", "The previous version of the indexer stores the index in two a s: a \"TermCounter\" that maps from a search term to e r of times it appears on a web page, and an \"Index\" t s from a search term to the set of pages where it appears."], ["entire data structure might, program last started would, writing large data structures", "These data structures are stored in the memory of a running a m, which means that when the program stops running, the index s t. Data stored only in the memory of a running program is called\nData that persists after the program that created it ends is called\n\"persistent\". In general, files stored in a file system e t, as well as data stored in databases.\nA simple way to make data persistent is to store it in a file. e e program ends, it could translate its data structures into a t e JSON (http://thinkdast.com/json) and then write m o a file. When it starts again, it could read the file and d e data structures.\nBut there are several problems with this solution:\n- Reading and writing large data structures (like a Web index) would be\n  slow.\n- The entire data structure might not fit into the memory of a single\n  running program.\n- If a program ends unexpectedly (for example, due to a power outage),\n  any changes made since the program last started would be lost.\nThe database I recommend for this exercise is Redis, which s t data structures that are similar to Java data structures."], ["volatile \",, program ends, vaporizes", "\"volatile\", because it vaporizes when the program ends."], ["provides persistent storage, p :// thinkdast, database without reading", "A better alternative is a database that provides persistent storage d e ability to read and write parts of the database without reading d g the whole thing.\nThere are many kinds of database management systems (DBMS) that e t capabilities. You can read an overview t p://thinkdast.com/database."], ["set \"., map \"., list \".", "Specifically, it provides:\n- Lists of strings, similar to Java \"List\".\n- Hashes, similar to Java \"Map\".\n- Sets of strings, similar to Java \"Set\"."], ["value database \",, unique strings, n object", "Redis is a \"key-value database\", which means that the data s t contains (the values) are identified by unique strings (the keys). A\nkey in Redis plays the same role as a reference in Java: it s n object. We'll see some examples soon."], ["remote dictionary server \"., virtual machine running, http :// thinkdast", "Redis is usually run as a remote service; in fact, the name stands for\n\"REmote DIctionary Server\". To use Redis, you have to run the s r somewhere and then connect to it using a Redis client. There e y ways to set up a server and many clients you could use. For s e, I recommend:\n- Rather than install and run the server yourself, consider using a\n  service like RedisToGo (http://thinkdast.com/redistogo), which runs\n  Redis in the cloud. They offer a free plan with enough resources for\n  the exercise.\n- For the client I recommend Jedis, which is a Java library that\n  provides classes and methods for working with Redis.\nHere are more detailed instructions to help you get started:\n- Create an account on RedisToGo, at\n  http://thinkdast.com/redissign,\n  and select the plan you want (probably the free plan to get started).\n- Create an \"instance\", which is a virtual machine running the Redis\n  server. If you click on the \"Instances\" tab, you should see your new\n  instance, identified by a host name and a port number. For example, I\n  have an instance named \"dory-10534\".\n- Click on the instance name to get the configuration page. Make a note\n  of the URL near the top of the page, which looks like this:\n  \\begin{verbatim}\n  redis://redistogo:1234567feedfacebeefa1e1234567@dory.redistogo.com:10534"], ["itemize, end", "\\end{itemize}"], ["url contains, host name, com \",", "This URL contains the server's host name, \"dory.redistogo.com\","], ["port number, next step, long string", "the port number, \"10534\", and the password you will need o t to the server, which is the long string of letters and s n the middle. You will need this information for the next step."], ["repository, book", "In the repository for this book,"], ["lindex (\" mylist \", 1 )); // hash jedis, main \": public static void main, value ); // set jedis", "you'll find the source files for this exercise:\n- \"JedisMaker.java\" contains example code for connecting to a\n  Redis server and running a few Jedis methods.\n- \"JedisIndex.java\" contains starter code for this exercise.\n- \"JedisIndexTest.java\" contains test code for\n  \"JedisIndex\".\n- \"WikiFetcher.java\" contains the code we saw in previous exercises to\n  read web pages and parse them using jsoup.\nYou will also need these files, which you worked on in s s:\n- \"Index.java\" implements an index using Java data structures.\n- \"TermCounter.java\" represents a map from terms to their\n  frequencies.\n- \"WikiNodeIterable.java\" iterates through the nodes in a DOM\n  tree produced by jsoup.\nThe first step is to use Jedis to connect to your Redis server.\n\"RedisMaker.java\" shows how to do this. It reads n t your Redis server from a file, connects to it and logs in g r password, then returns a \"Jedis\" object you can use o m Redis operations.\nIf you open \"JedisMaker.java\", you should see the\n\"JedisMaker\" class, which is a helper class that provides e c method, \"make\", which creates a \"Jedis\" object. e s object is authenticated, you can use it to communicate with r s database.\n\"JedisMaker\" reads information about your Redis server from a e named \"redis_url.txt\", which you should put in e y \"src/resources\":\n- Use a text editor to create end edit\n  \"ThinkDataStructures/code/src/resources/redis_url.txt\".\n- Paste in the URL of your server. If you are using RedisToGo, the URL\n  will look like this:\n\"redis://redistogo:1234567feedfacebeefa1e1234567@dory.redistogo.com:10534\"\nNow run \"ant build\" to compile e e files and \"ant JedisMaker\" to run the example code in\n\"main\":\n    public static void main(String[] args) {\n        Jedis jedis = make();\n        // String\n        jedis.set(\"mykey\", \"myvalue\");\n        String value = jedis.get(\"mykey\");\n        System.out.println(\"Got value: \" + value);\n        // Set\n        jedis.sadd(\"myset\", \"element1\", \"element2\", \"element3\");\n        System.out.println(\"element2 is member: \" +\n                           jedis.sismember(\"myset\", \"element2\"));\n        // List\n        jedis.rpush(\"mylist\", \"element1\", \"element2\", \"element3\");\n        System.out.println(\"element at index 1: \" +\n                           jedis.lindex(\"mylist\", 1));\n        // Hash\n        jedis.hset(\"myhash\", \"word1\", Integer.toString(2));\n        jedis.hincrBy(\"myhash\", \"word2\", 1);\n        System.out.println(\"frequency of word1: \" +\n                           jedis.hget(\"myhash\", \"word1\"));\n        System.out.println(\"frequency of word1: \" +\n                            jedis.hget(\"myhash\", \"word2\"));\n        jedis.close();\n    }"], ["{\\ tt solutions, working versions, u e", "If you have working versions of these files, you can use them r s exercise.  If you didn't do the previous exercises, or u e not confident in your solutions, you can copy my s m the {\\tt solutions} folder."], ["{\\ tt, repository contains, redis server", "Because this file contains the password for your Redis server, u d not put this file in a public repository. To help you d g that by accident, the repository contains a {\\tt .gitignore}"], ["e n, repo, put", "file that makes it harder (but not impossible) to put this e n your repo."], ["got value, example demonstrates, element2 frequency", "This example demonstrates the data types and methods you are most y o use for this exercise. When you run it, the output should be:\nGot value: e t2 is member: e t at index 1: element2\nfrequency of word1: 2\nfrequency of word2: 1"], ["next section, code works, explain", "In the next section, I'll explain how the code works."], ["word2 \", 1 ); 1, value \"\" 2 \"\"., hincrby (\" myhash \",", "Redis is basically a map from keys, which are strings, o s, which can be one of several data types. The most basic s a type is a \\redis{string}.  I will write Redis types n s to distinguish them from Java types.\nRedis provides a \\redis{set} structure, which s r to a Java\n\"Set<String>\". To add elements to a Redis \\redis{set},\nyou choose a key to identify the \\redis{set} and then use\nYou don't have to create the \\redis{set} as a separate step. If it doesn't t, Redis creates it. In this case, it creates a \\redis{set} named\nRedis also provides a \\redis{list} structure, which s r to a Java\nFinally, Redis provides a \\redis{hash} structure, which is similar to a Java\n\"Map<String, String>\". The method\nThis example creates a \\redis{hash} named \"myhash\" that contains e y, which maps from the key \"word1\" to the value \"\"2\"\".\nThe keys and values are \\redis{string}s, so if we want to e n \"Integer\", we have to convert it o a \"String\" before we call \"hset\".\nWorking with Redis \\redis{hash}es can be confusing, because we use a key o y which \\redis{hash} we want, and then another key to identify a value n e \\redis{hash}. In the context of Redis, the second key is called a \"field\",\nidentifies a particular \\redis{hash}, and then a \"field\" like \"word1\"\nidentifies a value in the \\redis{hash}.\nFor many applications, the values in a Redis \\redis{hash} are integers, so s s a few special methods, like \"hincrby\", that treat e s as numbers:\n        jedis.hincrBy(\"myhash\", \"word2\", 1);\n1, and writes the result back to the \\redis{hash}.\nYou can read more about Redis data types t p://thinkdast.com/redistypes."], ["string, redis, database", "To add a \\redis{string} to the database,"], ["lindex (\" mylist \", 1 );, hget (\" myhash \",, element3 \"); boolean flag", "use \"jedis.set\", which is similar to \"Map.put\"; e s are the new key and the corresponding value. To look up a y and get its value, use \"jedis.get\":\n        jedis.set(\"mykey\", \"myvalue\");\n        String value = jedis.get(\"mykey\");\nIn this example, the key is \"\"mykey\"\" and the value is\n\"jedis.sadd\":\n        jedis.sadd(\"myset\", \"element1\", \"element2\", \"element3\");\n        boolean flag = jedis.sismember(\"myset\", \"element2\");\nThe method \"jedis.sismember\" checks whether an element is in a\n\"jedis.rpush\" adds elements to the end (right side) of a\n\\redis{list}:\n        jedis.rpush(\"mylist\", \"element1\", \"element2\", \"element3\");\n        String element = jedis.lindex(\"mylist\", 1);\nThe method \"jedis.lindex\" takes an integer index and returns e d element of a \\redis{list}. Adding and accessing elements e t time operations.\n\"jedis.hset\" adds a new entry to the \\redis{hash}:\n        jedis.hset(\"myhash\", \"word1\", Integer.toString(2));\n        String value = jedis.hget(\"myhash\", \"word1\");"], ["\"\" myvalue \"\".", "\"\"myvalue\"\"."], ["contains three elements, three elements, g elements", "\"myset\" that contains three elements.\nAgain, you don't have to create the structure before you t g elements. This example creates a \\redis{list} named \"mylist\" t s three elements."], ["set }., incrementing entries, constant e", "\\redis{set}. Adding elements and checking membership are constant e s.\nSetting, getting, and incrementing entries in a \\redis{hash} are constant e s."], ["string >\"., method, list", "\"List<String>\". The method"], ["value using, hget \",, look", "And when we look up the value using \"hget\","], ["string \",, integer \"., result", "the result is a \"String\", so we might have to convert it k o \"Integer\"."], ["might help keep things straight, myhash, like", "which might help keep things straight. So a \"key\" like \"myhash\""], ["already exist ), increments, myhash \", gets, method accesses", "This method accesses \"myhash\", gets the current value d h \"word2\" (or 0 if it doesn't already exist), increments it by"], ["database might change every time, perform many small operations, without testing smaller pieces", "At this point you have all the information you need to do the exercise, o u can get started if you are ready. But I have a few suggestions u t want to read first:\n- For this exercise I provide less guidance than in previous\n  exercises.  You will have to make some design decisions; in\n  particular, you will have to figure out how to divide the problem\n  into pieces that you can test one at a time, and then assemble the\n  pieces into a complete solution. If you try to write the whole thing\n  at once, without testing smaller pieces, it might take a very long\n  time to debug.\n- One of the challenges of working with persistent data is that it is\n  persistent. The structures stored in the database might change every\n  time you run the program. If you mess something up in the database,\n  you will have to fix it or start over before you can proceed. To help\n  you keep things under control, I've provided methods called\n  \"deleteURLSets\", \"deleteTermCounters\", and\n  \"deleteAllKeys\", which you can use to clean out the database\n  and start fresh. You can also use \"printIndex\" to print the\n  contents of the index.\n- Each time you invoke a \"Jedis\" method, your client sends a\n  message to the server, then the server performs the action you\n  requested and sends back a message. If you perform many small\n  operations, it will probably take a long time. You can improve\n  performance by grouping a series of operations into a\n  \"Transaction\".\nthis method would take a long time to run. We can speed it up with a"], ["deleteallkeys \": public void deleteallkeys (), public void deleteallkeys (), keys (\"*\"); transaction", "For example, here's a simple version of \"deleteAllKeys\":\n    public void deleteAllKeys() {\n        Set<String> keys = jedis.keys(\"*\");\n        for (String key: keys) {\n            jedis.del(key);\n        }\n    }\n\"Transaction\" object:\n    public void deleteAllKeys() {\n        Set<String> keys = jedis.keys(\"*\");\n        Transaction t = jedis.multi();\n        for (String key: keys) {\n            t.del(key);\n        }\n        t.exec();\n    }"], ["index contains, trip, time", "Each time you invoke \"del\" requires a round-trip from the t o the server and back. If the index contains more than a few pages,"], ["f e saved operations, exec \"., transaction \",", "\"jedis.multi\" returns a \"Transaction\" object, h s all the methods of a \"Jedis\" object. But when you e a method on a \"Transaction\", it doesn't run the n y, and it doesn't communicate with the server. It saves up a h of operations until you invoke \"exec\". Then it sends all f e saved operations to the server at the same time, which is y h faster."], ["get stuck, get started, come back", "Now you really have all the information you need; you d t working on the exercise. But if you get stuck, or if you really don't w how to get started, you can come back for a few more hints."], ["often get ideas, basic redis commands, tests first", "\\textbf{Don't read the following until you have run the test code, d t some basic Redis commands, and written a few methods in\nFor each method, consider writing the tests first. When you figure t w to test a method, you often get ideas about how to write it."], ["java \"}., jedisindex", "\"JedisIndex.java\"}."], ["*/ public void add, */ public integer getcount, */ public list", "OK, if you are really stuck, here are some methods you might want o k on:\n    /**\n     * Adds a URL to the set associated with term.\n     */\n    public void add(String term, TermCounter tc) {}\n    /**\n     * Looks up a search term and returns a set of URLs.\n     */\n    public Set<String> getURLs(String term) {}\n    /**\n     * Returns the number of times the given term appears at the given URL.\n     */\n    public Integer getCount(String url, String term) {}\n    /**\n     * Pushes the contents of the TermCounter to Redis.\n     */\n    public List<Object> pushTermCounterToRedis(TermCounter tc) {}"], ["please take, divide things, way", "These are the methods I used in my solution, but they are y t the only way to divide things up. So please take these s f they help, but ignore them if they don't."], ["good luck", "Good luck!"], ["method uses two helper methods, urlset \": private string urlsetkey, getlabel (); string hashname", "In my solution, we store two kinds of structures in Redis:\n- For each search term, we have a \"URLSet\", which is a Redis \\redis{set}\n  of URLs that contain the search term.\n- For each URL, we have a \"TermCounter\", which is a Redis \\redis{hash}\n  that maps each search term to the number of times it appears.\nWe discussed these data types in the previous chapter. You can o d about Redis structures at http://thinkdast.com/redistypes\nIn \"JedisIndex\", I provide a method that takes a search m d returns the Redis key of its \"URLSet\":\nprivate String urlSetKey(String term) {\n    return \"URLSet:\" + term;\n}\nAnd a method that takes a URL and returns the Redis key of its\nHere's the new code that pushes a \"TermCounter\" to Redis:\npublic List<Object> pushTermCounterToRedis(TermCounter tc) {\n    Transaction t = jedis.multi();\n    String url = tc.getLabel();\n    String hashname = termCounterKey(url);\n    // if this page has already been indexed, delete the old hash\n    t.del(hashname);\n    // for each term, add an entry in the TermCounter and a new\n    // member of the index\n    for (String term: tc.keySet()) {\n        Integer count = tc.get(term);\n        t.hset(hashname, term, count.toString());\n        t.sadd(urlSetKey(term), url);\n    }\n    List<Object> res = t.exec();\n    return res;\n}\nIt loops through the terms in the \"TermCounter\". For each one it\n- Finds or creates a \"TermCounter\" on Redis, then adds a field\n  for the new term.\n- Finds or creates a \"URLSet\" on Redis, then adds the current\n  URL.\nThe second part of the exercise asked you to write \"getCounts\", h s a search term and returns a map from each URL where the m s to the number of times it appears there. Here is my solution:\n    public Map<String, Integer> getCounts(String term) {\n        Map<String, Integer> map = new HashMap<String, Integer>();\n        Set<String> urls = getURLs(term);\n        for (String url: urls) {\n            Integer count = getCount(url, term);\n            map.put(url, count);\n        }\n        return map;\n    }\nThis method uses two helper methods:\n- \"getURLs\" takes a search term and returns the Set of URLs where\n  the term appears.\n- \"getCount\" takes a URL and a term and returns the number of\n  times the term appears at the given URL."], ["termcounter \": private string termcounterkey, term ); return new integer, paragraphs ); // push", "\"TermCounter\":\nprivate String termCounterKey(String url) {\n    return \"TermCounter:\" + url;\n}\nHere's the implementation of \"indexPage\", which takes a URL and a p \"Elements\" object that contains the DOM tree of e s we want to index:\npublic void indexPage(String url, Elements paragraphs) {\n    System.out.println(\"Indexing \" + url);\n    // make a TermCounter and count the terms in the paragraphs\n    TermCounter tc = new TermCounter(url);\n    tc.processElements(paragraphs);\n    // push the contents of the TermCounter to Redis\n    pushTermCounterToRedis(tc);\n}\nHere are the implementations:\n    public Set<String> getURLs(String term) {\n        Set<String> set = jedis.smembers(urlSetKey(term));\n        return set;\n    }\n    public Integer getCount(String url, String term) {\n        String redisKey = termCounterKey(url);\n        String count = jedis.hget(redisKey, term);\n        return new Integer(count);\n    }"], ["indexing new pages, using code, previous exercise", "To index a page, we\n- Make a Java \"TermCounter\" for the contents of the page, using\n  code from a previous exercise.\n- Push the contents of the \"TermCounter\" to Redis.\n\"TermCounter\" before pushing the new contents.\nThat's it for indexing new pages."], ["much faster, method uses, small operations", "This method uses a \"Transaction\" to collect the operations d d them to the server all at once, which is much faster than sending a s of small operations.\nBecause of the way we designed the index, these methods are simple d t."], ["page, old, indexed", "If the page has already been indexed, we delete its old"], ["indexed n pages, suppose, discovered", "Suppose we have indexed N pages and discovered M"], ["takes time proportional, unique search terms, rare terms", "unique search terms. How long will it take to look up a search term?\n\"getURLs\" takes time proportional to the number of URLs t n the search term. For rare terms, that might be a small number,"], ["think, continue, answer", "Think about your answer before you continue."], ["search term, hashmap \"., getcounts \",", "To look up a search term, we run \"getCounts\", which\n- Creates a map.\n- Runs \"getURLs\" to get a Set of URLs.\n- For each URL in the Set, runs \"getCount\" and adds an entry\n  to a \"HashMap\".\nInside the loop, we run \"getCount\", which finds a"], ["common terms, n, might", "but for common terms it might be as large as N."], ["normally much less, constant time operations, n e term", "\"TermCounter\" on Redis, looks up a term, and adds an entry to a p. Those are all constant time operations, so the l y of \"getCounts\" is O(N) in the worst case. However, n e the runtime is proportional to the number of pages that n e term, which is normally much less than N."], ["terms f c complexity, sends many l, faster using", "This algorithm is as efficient as it can be, in terms f c complexity, but it is very slow because it sends many l s to Redis. You can make it faster using a"], ["u n see, transaction \"., might want", "\"Transaction\". You might want to do that as an exercise, or u n see my solution in \"RedisIndex.java\"."], ["lot f e, improve performance, data structures", "Using the data structures we designed, how long will it take to index a e? Again, think about your answer before you continue.\nThis analysis suggests a way to improve performance: we should y d indexing very common words. First of all, they take up a lot f e and space, because they appear in almost every \"URLSet\" and"], ["dom tree, traverse, page", "To index a page, we traverse its DOM tree, find all the"], ["search terms, textnode, strings", "\"TextNode\" objects, and split up the strings into search terms."], ["number f e search terms, unique search terms, takes e l", "That all takes time proportional to the number of words on the page.\nFor each term, we increment a counter in a HashMap, which is a t e operation. So making the \"TermCounter\" takes e l to the number of words on the page.\nBoth of these are constant time operations, so the total time to h e \"TermCounter\" is linear in the number of unique search terms.\nIn summary, making the \"TermCounter\" is proportional to e r of words on the page. Pushing the \"TermCounter\" to s s proportional to the number of unique terms.\nSince the number of words on the page usually exceeds the number f e search terms, the overall complexity is proportional to e r of words on the page. In theory a page might contain all h s in the index, so the worst case performance is O(M), but we don't t to see the worse case in practice."], ["redis requires deleting, urlset \",, termcounter \".", "Pushing the \"TermCounter\" to Redis requires deleting a\nThen for each term we have to\n- Add an element to a \"URLSet\", and\n- Add an element to a Redis \"TermCounter\"."], ["unique terms, termcounter \",, number", "\"TermCounter\", which is linear in the number of unique terms."], ["help identify relevant pages, termcounter \"., useful", "\"TermCounter\". Furthermore, they are not very useful because y n't help identify relevant pages."], ["search engines avoid indexing common words, http :// thinkdast, stop words", "Most search engines avoid indexing common words, which are known in s t as stop words (http://thinkdast.com/stopword)."], ["exercise n r ~\\ ref, p :// thinkdast, n e say", "If you did the \"Getting to Philosophy\" exercise n r~\\ref{getphilo}, you already have a program that reads a a e, finds the first link, uses the link to load the next page, d s. This program is a specialized kind of crawler, but n e say \"Web crawler\" they usually mean a program that\n- Loads a starting page and indexes the contents,\n- Finds all the links on the page and adds the linked URLs to a collection,\n  and\n- Works its way through the collection, loading pages, indexing them, and\n  adding new URLs.\n- If it finds a URL that has already been indexed, it skips\n  it.\nStarting from a source node, a crawler traverses this graph,\nThe collection we use to store the URLs determines what kind f l the crawler performs:\n- If it's a first-in-first-out (FIFO) queue, the crawler performs a\n  breadth-first traversal.\n- If it's a last-in-first-out (LIFO) stack, the crawler performs a\n  depth-first traversal.\n- More generally, the items in the collection might be prioritized. For\n  example, we might want to give higher priority to pages that have not\n  been indexed for a long time.\nYou can read more about graph traversal t p://thinkdast.com/graphtrav."], ["http :// thinkdast, one e, h e", "You can think of the Web as a h e each page is a node and each link is a directed edge from one e o another. If you are not familiar with graphs, you can read t m at http://thinkdast.com/graph.\nvisiting each reachable node once."], ["provided n e, queueinternallinks \"., previous exercise", "First, let's go over our solution to the previous exercise. I provided n e of \"WikiCrawler\"; your job was to fill in \"crawl\".\n\"WikiCrawler.queueInternalLinks\"."], ["started private final string source, results go private jedisindex index, string >(); // fetcher used", "As a reminder, here are the fields in the \"WikiCrawler\" class:\npublic class WikiCrawler {\n    // keeps track of where we started\n    private final String source;\n    // the index where the results go\n    private JedisIndex index;\n    // queue of URLs to be indexed\n    private Queue<String> queue = new LinkedList<String>();\n    // fetcher used to get pages from Wikipedia\n    final static WikiFetcher wf = new WikiFetcher();\n}\nHere's my implementation of \"WikiCrawler.crawl\":\n    public String crawl(boolean testing) throws IOException {\n        if (queue.isEmpty()) {\n            return null;\n        }\n        String url = queue.poll();\n        System.out.println(\"Crawling \" + url);\n        if (testing==false && index.isIndexed(url)) {\n            System.out.println(\"Already indexed.\");\n            return null;\n        }\n        Elements paragraphs;\n        if (testing) {\n            paragraphs = wf.readWikipedia(url);\n        } else {\n            paragraphs = wf.fetchWikipedia(url);\n        }\n        index.indexPage(url, paragraphs);\n        queueInternalLinks(paragraphs);\n        return url;\n    }\nMost of the complexity in this method is there to make it easier o t. Here's the logic:\n- If the queue is empty, it returns \"null\" to indicate that it\n  did not index a page.\n- Otherwise it removes and stores the next URL from the queue.\n- If the URL has already been indexed, \"crawl\" doesn't index it\n  again, unless it's in testing mode.\n- Next it reads the contents of the page: if it's in testing mode, it\n  reads from a file; otherwise it reads from the Web.\n- It indexes the page.\n- It parses the page and adds internal links to the queue.\n- Finally, it returns the URL of the page it indexed."], ["wikicrawler \",, source \"., source", "When we create a \"WikiCrawler\", we provide \"source\" and\n\"source\"."], ["startswith (\"/ wiki /\")), attr (\" href \");, attr (\" abs", "\"index\". Initially, \"queue\" contains only one element,\nNotice that the implementation of \"queue\" is a\n\"LinkedList\" object to a \"Queue\" variable, we t s to using methods in the \"Queue\" interface; specifically,\nThe first version just loops through the paragraphs. The second n s the real work.\n    void queueInternalLinks(Elements paragraphs) {\n        for (Element paragraph: paragraphs) {\n            queueInternalLinks(paragraph);\n        }\n    }\n    private void queueInternalLinks(Element paragraph) {\n        Elements elts = paragraph.select(\"a[href]\");\n        for (Element elt: elts) {\n            String relURL = elt.attr(\"href\");\n            if (relURL.startsWith(\"/wiki/\")) {\n                String absURL = elt.attr(\"abs:href\");\n                queue.offer(absURL);\n            }\n        }\n    }"], ["linkedlist \",, end ---, constant time", "\"LinkedList\", so we can add elements at the end --- and e m from the beginning --- in constant time. By assigning a"], ["add elements, use, poll", "we'll use \"offer\" to add elements and \"poll\" to e m."], ["n n ~\\ ref, new method, indexer }.", "I presented an implementation of \"Index.indexPage\" n n~\\ref{redis-indexer}. So the only new method is"], ["object containing one dom tree r h, wrote two versions, object", "I wrote two versions of this method with different parameters: e s an \"Elements\" object containing one DOM tree r h; the other takes an \"Element\" object that contains a e paragraph."], ["internal ,\", determine whether, check whether", "To determine whether a link is \"internal,\" we check whether the URL"], ["\"/ wiki /\"., might include, might exclude", "starts with \"/wiki/\". This might include some pages we don't want o x, like meta-pages about Wikipedia. And it might exclude some s e want, like links to pages in non-English languages. But this e t is good enough to get started."], ["new material, lot, exercise", "That's all there is to it. This exercise doesn't have a lot of new material;"], ["pieces together, mostly, chance", "it is mostly a chance to bring the pieces together."], ["information retrieval \",, building web applications, provide search terms", "The next phase of this project is to implement a search tool. The s e'll need include:\n- An interface where users can provide search terms and view results.\n- A lookup mechanism that takes each search term and returns the pages\n  that contain it.\n- Mechanisms for combining search results from multiple search terms.\n- Algorithms for ranking and sorting search results.\nThe general term for processes like this is \"information retrieval\",\nIn this exercise, we'll focus on steps 3 and 4. We've already built a e n of 2. If you are interested in building Web applications, u t consider working on step 1."], ["read", "which you can read more about at"], ["http :// thinkdast, infret, com", "http://thinkdast.com/infret."], ["multiple search terms using boolean logic, means u n combine, contain search terms", "Most search engines can perform \"boolean searches\", which means u n combine the results from multiple search terms using boolean logic.\nExpressions like these that contain search terms and operators e d \"queries\".\nWhen applied to search results, the boolean operators \"AND\","], ["contain either term, might return pages, might return pages", "For example:\n- The search \"java AND programming\" might return only pages that\n  contain both search terms: \"java\" and \"programming\".\n- \"java OR programming\" might return pages that contain either term\n  but not necessarily both.\n- \"java -indonesia\" might return pages that contain \"java\" and do\n  not contain \"indonesia\".\n\"intersection\", \"union\", and \"difference\". r e, suppose\n- \"s1\" is the set of pages containing \"java\",\n- \"s2\" is the set of pages containing \"programming\", and\n- \"s3\" is the set of pages containing \"indonesia\".\nIn that case:\n- The intersection of \"s1\" and \"s2\" is the set of pages\n  containing \"java\" AND \"programming\".\n- The union of \"s1\" and \"s2\" is the set of pages\n  containing \"java\" OR \"programming\".\n- The difference of \"s1\" and \"s2\" is the set of pages\n  containing \"java\" and not \"indonesia\"."], ["set operations, \"-\" correspond, \",", "\"OR\", and \"-\" correspond to the set operations"], ["next section, write, operations", "In the next section you will write a method to implement these operations."], ["deploying web applications using java, see http :// thinkdast, http :// thinkdast", "If you get a basic version of this exercise working, you might want to k n these optional exercises:\n- Read about TF-IDF at http://thinkdast.com/tfidf\n  and implement it. You might have to modify \"JavaIndex\" to\n  compute document frequencies; that is, the total number of times\n  each term appears on all pages in the index.\n- For queries with more than one search term, the total relevance for\n  each page is currently the sum of the relevance for each term. Think\n  about when this simple version might not work well, and try out some\n  alternatives.\n- Build a user interface that allows users to enter queries with\n  boolean operators. Parse the queries, generate the results, then\n  sort them by relevance and display the highest-scoring\n  URLs. Consider generating \"snippets\" that show where the search\n  terms appeared on the page. If you want to make a Web application\n  for your user interface, consider using Heroku as a simple option\n  for developing and deploying Web applications using Java.  See\n  http://thinkdast.com/heroku."], ["read e n sort wikipedia page, inner loop never runs, takes two parameters", "We'll start with insertion sort, mostly because it is simple to e d implement. It is not very efficient, but it has some g s, as we'll see.\nRather than explain the algorithm here, I suggest you read e n sort Wikipedia page t p://thinkdast.com/insertsort, which s e and animated examples. Come back when you get the l a.\n\"insertionSort\" takes two parameters, a \"List\" of any d d a \"Comparator\" that knows how to compare type \"T\"\nIn the worst case, insertion sort is quadratic. However:\n- If the elements are already sorted, or nearly so, insertion sort is\n  linear. Specifically, if each element is no more than k\n  locations away from where it should be, the inner loop never runs more\n  than k times, and the total runtime is O(kn).\n- Because the implementation is simple, the overhead is low; that is,\n  although the runtime is a n^2, the coefficient of the leading\n  term, a, is probably small.\nSo if we know that the array is nearly sorted, or is not very big,\ninsertion sort might be a good choice. But for large arrays, we n o better. In fact, much better."], ["override public int compare, elt_j ); j --;, public void insertionsort", "Here's an implementation of insertion sort in Java:\npublic class ListSorter<T> {\n    public void insertionSort(List<T> list, Comparator<T> comparator) {\n        for (int i=1; i < list.size(); i++) {\n            T elt_i = list.get(i);\n            int j = i;\n            while (j > 0) {\n                T elt_j = list.get(j-1);\n                if (comparator.compare(elt_i, elt_j) >= 0) {\n                    break;\n                }\n                list.set(j, elt_j);\n                j--;\n            }\n            list.set(j, elt_i);\n        }\n    }\n}\nI define a class, \"ListSorter\", as a container for t s. By using the type parameter, \"T\", we can e s that work on lists containing any object type.\n\"Integer\" objects:\n        List<Integer> list = new ArrayList<Integer>(\n            Arrays.asList(3, 5, 1, 4, 2));\n        Comparator<Integer> comparator = new Comparator<Integer>() {\n            @Override\n            public int compare(Integer elt1, Integer elt2) {\n                return elt1.compareTo(elt2);\n            }\n        };\n        ListSorter<Integer> sorter = new ListSorter<Integer>();\n        sorter.insertionSort(list, comparator);\n        System.out.println(list);"], ["modifies e g list, outer loop iterates, place \",", "objects. It sorts the list \"in place\", which means it modifies e g list and does not have to allocate any new space.\nThe outer loop iterates from 1 to \"list.size()\", so it is r n the size of the list, n."], ["following example shows, method, list", "The following example shows how to call this method with a \"List\" of"], ["two nested loops, inner loop runs, inner loop runs", "\"insertionSort\" has two nested loops, so you might guess t s runtime is quadratic. In this case, that turns out to be correct,\nbut before you jump to that conclusion, you have to check that e r of times each loop runs is proportional to n, the e f the array.\nTherefore, the total number of times the inner loop runs is quadratic.\nIf you are not sure about that, here's the argument:\n- The first time through, i=1 and the inner loop runs at most\n  once.\n- The second time, i=2 and the inner loop runs at most twice.\n- The last time, i=n-1 and the inner loop runs at most\n  n-1 times.\nSo the total number of times the inner loop runs is the sum of e s 1, 2, ... , n-1, which is n (n-1) / 2. And e g term of that expression (the one with the highest exponent) s n^2."], ["inner loop iterates, also linear, n", "The inner loop iterates from \"i\" to 0, so it is also linear in n."], ["make two new arrays, steps f e algorithm, l f n elements", "To classify the runtime of merge sort, it helps to think in terms f s of recursion and how much work is done on each level. e e start with a list that contains n elements. Here are the steps f e algorithm:\n- Make two new arrays and copy half of the elements into each.\n- Sort the two halves.\n- Merge the halves.\nThe first step copies each of the elements once, so it is linear. e d step also copies each element once, so it is also linear. Now e d to figure out the complexity of step 2. To do that, it helps o s at a different picture of the computation, which shows the s f recursion, as in\nwe have to split the arrays in half, which takes time proportional o n on every level. On the way back up, we have to merge a l f n elements, which is also linear."], ["top level, next level, every level", "At the top level, we have 1 list with n elements.\nFor simplicity, let's assume n is a power of 2.\nAt the next level there are 2 lists with n/2 elements.\nThen 4 lists with n/4 elements, and so on until we t o n lists with 1 element.\nOn every level we have a total of n elements. On the way down,"], ["total amount, second question, nh ).", "If the number of levels is h, the total amount of work for e m is O(nh). So how many levels are there? There are o s to think about that:\n- How many times do we have to cut n in half to get to 1?\n- Or, how many times do we have to double 1 before we get to n?\nAnother way to ask the second question is \"What power of 2 s n?\"\n2^h = n"], ["r n n log n, theoretical lower bound r, see http :// thinkdast", "Taking the log_2 of both sides yields\nh = log_2 n\nSo the total time is O(n log n). I didn't bother to write e e of the logarithm because logarithms with different bases differ y a constant factor, so all logarithms are in the same order of growth.\nAlgorithms in O(n log n) are sometimes called\nIt turns out that O(n log n) is the theoretical lower bound r t algorithms that work by comparing elements to each other. t s there is no \"comparison sort\" whose order of growth is r n n log n.  See http://thinkdast.com/compsort."], ["n log n \"., linearithmic \",, say", "\"linearithmic\", but most people just say \"n log n\"."], ["take linear time, next section, see", "But as we'll see in the next section, there are non-comparison s t take linear time!"], ["chief executive eric schmidt jokingly asked, 2008 united states presidential campaign, k e bubble sort would", "During the 2008 United States Presidential Campaign, candidate k a was asked to perform an impromptu algorithm analysis when e d Google. Chief executive Eric Schmidt jokingly asked him for\n\"the most efficient way to sort a million 32-bit integers.\" a d apparently been tipped off, because he quickly replied, \"I k e bubble sort would be the wrong way to go.\" You can watch e o at http://thinkdast.com/obama."], ["even among quadratic sort algorithms, see http :// thinkdast, comparison ** sort algorithm", "Obama was right: bubble sort is conceptually simple but its runtime s c; and even among quadratic sort algorithms, its e s not very good.  See http://thinkdast.com/bubble.\nThe answer Schmidt was probably looking for is \"radix sort\", which s a **non-comparison** sort algorithm that works if the size of e s is bounded, like a 32-bit integer or a 20-character string."], ["index cards e h card contains, bucket contains one element, top row shows", "To see how this works, imagine you have a stack of index cards e h card contains a three-letter word. Here's how you could sort e s:\n- Make one pass through the cards and divide them into buckets based on\n  the first letter. So words starting with \"a\" should be\n  in one bucket, followed by words starting with \"b\", and so on.\n- Divide each bucket again based on the second letter. So words starting\n  with \"aa\" should be together, followed by words starting with\n  \"ab\", and so on. Of course, not all buckets will be full, but\n  that's OK.\n- Divide each bucket again based on the third letter.\nAt this point each bucket contains one element, and the buckets e d in ascending order.\nThe top row shows the unsorted words. The second row shows what e s look like after the first pass. The words in each bucket n h the same letter.\nAfter the second pass, the words in each bucket begin with the same o s. After the third pass, there can be only one word in h t, and the buckets are in order."], ["buckets allow addition, constant time, pass", "During each pass, we iterate through the elements and add them o s. As long as the buckets allow addition in constant time, h s is linear."], ["call w, words, words", "The number of passes, which I'll call w, depends on the \"width\"\nof the words, but it doesn't depend on the number of words, n."], ["wn ),, order, n", "So the order of growth is O(wn), which is linear in n."], ["p :// thinkdast, many ways, many variations", "There are many variations on radix sort, and many ways to t h one. You can read more about them t p://thinkdast.com/radix. As an l e, consider writing a version of radix sort."], ["queue takes n log n time, see http :// thinkdast, n transactions per day", "In addition to radix sort, which applies when the things you want o t are bounded in size, there is one other special-purpose g m you might encounter: bounded heap sort. Bounded heap sort s l if you are working with a very large dataset and you want o t the \"Top 10\" or \"Top k\" for some value of k h r than n.\nFor example, suppose you are monitoring a Web service that handles a n transactions per day. At the end of each day, you want o t the k biggest transactions (or slowest, or any r e). One option is to store all transactions, sort them t e end of the day, and select the top k. That would take e l to n log n, and it would be very slow because e y can't fit a billion transactions in the memory of a e m. We would have to use an \"out of core\" sort algorithm. u n read about external sorting at http://thinkdast.com/extsort.\nUsing a bounded heap, we can do much better! Here's how we l d:\n- I'll explain (unbounded) heap sort.\n- You'll implement it.\n- I'll explain bounded heap sort and analyze it.\nTo understand heap sort, you have to understand a heap, which is a a e similar to a binary search tree (BST). Here are the differences:\n- In a BST, every node, \"x\", has the \"BST property\": all nodes\n  in the left subtree of \"x\" are less than \"x\" and all\n  nodes in the right subtree are greater than \"x\".\n- In a heap, every node, \"x\", has the \"heap property\": all\n  nodes in both subtrees of \"x\" are greater than \"x\".\n- Heaps are like balanced BSTs; when you add or remove elements, they\n  do some extra work to rebalance the tree.  As a result, they can\n  be implemented efficiently using an array of elements.\nThe smallest element in a heap is always at the root, so we can d t in constant time. Adding and removing elements from a heap s e proportional to the height of the tree h. And because the p s always balanced, h is proportional to log n.  You can d e about heaps at http://thinkdast.com/heap.\nThis way of sorting is called heap sort (see http://thinkdast.com/heapsort).\nAdding n elements to the queue takes n log n time. So s removing n elements. So the runtime for heap sort is"], ["collection f n elements like, takes log n time, takes log n time", "The Java \"PriorityQueue\" is implemented using a heap.\n\"PriorityQueue\" provides the methods specified in the\n\"Queue\" interface, including \"offer\" and \"poll\":\n- \"offer\": Adds an element to the queue, updating the heap so\n  that every node has the \"heap property\". Takes log n time.\n- \"poll\": Removes the smallest element in the queue from the root\n  and updates the heap. Takes log n time.\nGiven a \"PriorityQueue\", you can easily sort of a collection f n elements like this:\n- Add all elements of the collection to a \"PriorityQueue\" using\n  \"offer\".\n- Remove the elements from the queue using \"poll\" and add them to\n  a \"List\".\nIn the repository for this book, in \"ListSorter.java\" you'll d e outline of a method called \"heapSort\". Fill it in and n n \"ant ListSorterTest\" to confirm that it works."], ["smallest element remaining, e e, ascending order", "Because \"poll\" returns the smallest element remaining in e e, the elements are added to the \"List\" in ascending order."], ["n log n ).", "O(n log n)."], ["keep track f e largest k elements, e k largest elements like, largest k elements", "A bounded heap is a heap that is limited to contain at most k s. If you have n elements, you can keep track of e k largest elements like this:\nInitially, the heap is empty.  For each element, \"x\":\n- Branch 1: If the heap is not full, add \"x\" to the heap.\n- Branch 2: If the heap is full, compare \"x\" to the\n  smallest element in the heap. If \"x\" is smaller, it\n  cannot be one of the largest k elements, so you can discard\n  it.\n- Branch 3: If the heap is full and \"x\" is greater than the\n  smallest element in the heap, remove the smallest element from the\n  heap and add \"x\".\nUsing a heap with the smallest element at the top, we can keep track f e largest k elements. Let's analyze the performance of s m. For each element, we perform one of:\n- Branch 1: Adding an element to the heap is O(log k).\n- Branch 2: Finding the smallest element in the heap is O(1).\n- Branch 3: Removing the smallest element is O(log k). Adding\n  \"x\" is also O(log k).\n\"topK\" that takes a \"List\", a \"Comparator\", and n r k. It should return the k largest elements in the"], ["n log k ),, n branch 3, process n", "In the worst case, if the elements appear in ascending order, we s n Branch 3. In that case, the total time to process n s is O(n log k), which is linear in n."], ["method called listsortertest, works, outline", "In \"ListSorter.java\" you'll find the outline of a method called\n  ListSorterTest\" to confirm that it works."], ["ascending order, run, list", "\"List\" in ascending order. Fill it in and then run \"ant"], ["uses less space might make better use, often much smaller n n, run time often increases dramatically", "Until now we have talked a lot about runtime analysis, but for y s we are also concerned about space. For example, one of e s of merge sort is that it makes copies of the data. In r n, the total amount of space it allocates is\nIn contrast, insertion sort doesn't copy the data because it sorts e s in place. It uses temporary variables to compare two s t a time, and it uses a few other local variables. But its space e n't depend on n.\nO(1) space.\nOne of the benefits of the bounded heap algorithm you just d s that it only needs space proportional to k (the number f s we want to keep), and k is often much smaller n n.\nSoftware developers tend to pay more attention to runtime than space, d r many applications, that's appropriate. But for large datasets, e n be just as important or more so. For example:\n- If a dataset doesn't fit into the memory of one program, the run\n  time often increases dramatically, or it might not run at all. If you\n  choose an algorithm that needs less space, and that makes it possible\n  to fit the computation into memory, it might run much faster. In the\n  same vein, a program that uses less space might make better use of\n  CPU caches and run\n  faster (see http://thinkdast.com/cache).\n- On a server that runs many programs at the same time, if you can\n  reduce the space needed for each program, you might be able to run\n  more programs on the same server, which reduces hardware and energy\n  costs.\nSo those are some reasons you should know at least a little bit t e space needs of algorithms."], ["get e e requirement, n log n )., n ).", "O(n log n). With a more clever implementation, you can get e e requirement down to O(n)."], ["run heap sort, heap sort creates, n );", "Our implementation of heap sort creates a new \"PriorityQueue\" o e the elements, so the space is O(n); but if you e d to sort the list in place, you can run heap sort with"]]}