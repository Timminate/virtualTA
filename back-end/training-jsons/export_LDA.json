{"conversations": [["r read p, methods class interface, integer int class, number implements comparable integer public int compareto integer anotherinteger int thisval int anotherval return thisval, type parameter h comparable generic type order implement interface class specify type refers provide compareto, package public interface comparable public int compareto interface definition, implements interface r, ternary operator, implementation compareto uses, variables number implements comparable integer, number inherits methods, java interface specifies", "A Java \"interface\" specifies a set of methods; any class t s this \"interface\" has to provide these methods. r e, here is the source code for \"Comparable\", which is an\n\"interface\" defined in the package \"java.lang\":\npublic interface Comparable<T> {\n    public int compareTo(T o);\n}\nThis \"interface\" definition uses a type parameter, \"T\", h s \"Comparable\" a **generic type**.\nIn order to implement this \"interface\", a class has to\n- Specify the type \"T\" refers to, and\n- Provide a d d \"compareTo\" that takes an object as a parameter and s n \"int\".\nFor example, here's the source code for \"java.lang.Integer\":\npublic final class Integer extends Number implements Comparable<Integer> {\n    public int compareTo(Integer anotherInteger) {\n        int thisVal = this.value;\n        int anotherVal = anotherInteger.value;\n        return (thisVal<anotherVal ? -1 : (thisVal==anotherVal ? 0 : 1));\n    }\n    // other methods omitted\n}\nThis class extends \"Number\", so it inherits the methods d e variables of \"Number\"; and it implements\n\"Comparable<Integer>\", so it provides a d named \"compareTo\" that takes an \"Integer\" d s an \"int\".\nWhen a class declares that it implements an \"interface\", the r s that it provides all methods defined by the\n\"interface\"."], ["source code comparable interface, r read p, integer int class, package public interface comparable public int compareto interface definition, ternary operator, implementation compareto uses, implements interface r, methods class interface", "As an aside, this implementation of \"compareTo\" uses the"], ["source code comparable interface, r read p, integer int class, package public interface comparable public int compareto interface definition, object parameter n int example source code public final class integer, ternary operator, implementation compareto uses, implements interface r, methods class interface", "\"ternary operator\", sometimes written \"?:\".  If you are t r with it, you can read about it t p://thinkdast.com/ternary."], ["linkedlist interface defines, arraylist way n future code uses, specifies kind list style, c n, java collections framework jcf", "The Java Collections Framework (JCF) defines an \"interface\" called\n\"List\" and provides two implementations, \"ArrayList\" and\n\"LinkedList\".\nThe \"interface\" defines what it means to be a \"List\"; y s that implements this \"interface\" has to provide a r set of methods, including \"add\", \"get\",\n\"ArrayList\" and \"LinkedList\" provide these methods, o y can be used interchangeably. A method written to work with a\n\"List\" will work with an \"ArrayList\", \"LinkedList\",\nwhenever possible and avoids specifying \"LinkedList\" or\n\"ArrayList\" unless it is necessary. For example, the e e is declared to be a \"List\", and \"getList\" s a \"List\", but neither specifies which kind of list.\nThis style is called **interface-based programming**,\nor more casually, \"programming to an interface\"\nHere we are talking about the general idea of an interface,\nnot a Java \"interface\".\nWhen you use a library, your code should only depend on the interface,\nlike \"List\".  It should not depend on a c n, like \"ArrayList\". That way, if the n s in the future, the code that uses it will still work.\nOn the other hand, if the interface changes, the code that depends n t has to change, too.  That's why library developers avoid g s unless absolutely necessary."], ["getlist returns reference e l list object main contains lines, public class listclientexample private list list public listclientexample list new linkedlist private list getlist return list public static void main string args listclientexample, new listclientexample list list list, object implements list listclientexample anything useful e l elements class, first exercise listclientexample constructor, list important thing example, e test methods, list contains list e use class, point k, linkedlist interface defines, arraylist way n future code uses, specifies kind list style, new linkedlist e r method, c n, java collections framework jcf", "\"remove\", and about 20 more."], ["object implements list listclientexample anything useful e l elements class, new listclientexample list list list, change mind decide, list important thing example, first exercise listclientexample constructor, list contains list e use class, point k, arraylist u change constructor", "or any other object that implements \"List\".\n\"ListClientExample\" doesn't do anything useful, but it has e l elements of a class that **encapsulates** a\n\"List\"; that is, it contains a \"List\" as an e e.  I'll use this class to make a point, and then you'll k h it in the first exercise.\nThe \"ListClientExample\" constructor initializes \"list\" by\nThe important thing about this example is that it uses \"List\""], ["getlist returns reference e l list object main contains lines, public class listclientexample private list list public listclientexample list new linkedlist private list getlist return list public static void main string args listclientexample, new listclientexample list list list, object implements list listclientexample anything useful e l elements class, change mind decide, first exercise listclientexample constructor, list important thing example, e test methods, arraylist u change constructor, new linkedlist e r method", "Here's a contrived example that demonstrates the point:\npublic class ListClientExample {\n    private List list;\n    public ListClientExample() {\n        list = new LinkedList();\n    }\n    private List getList() {\n        return list;\n    }\n    public static void main(String[] args) {\n        ListClientExample lce = new ListClientExample();\n        List list = lce.getList();\n        System.out.println(list);\n    }\n}\n**instantiating** (that is, creating) a new \"LinkedList\"; e r method called \"getList\" returns a reference to e l \"List\" object; and \"main\" contains a few lines f e to test these methods."], ["object implements list listclientexample anything useful e l elements class, new listclientexample list list list, change mind decide, list important thing example, first exercise listclientexample constructor, list contains list e use class, point k, arraylist u change constructor", "If you change your mind and decide to use an \"ArrayList\", u y have to change the constructor; you don't have to make any r s."], ["getlist returns reference e l list object main contains lines, public class listclientexample private list list public listclientexample list new linkedlist private list getlist return list public static void main string args listclientexample, new listclientexample list list list, object implements list listclientexample anything useful e l elements class, first exercise listclientexample constructor, list important thing example, e test methods, list contains list e use class, point k, linkedlist interface defines, arraylist way n future code uses, specifies kind list style, new linkedlist e r method, c n, java collections framework jcf", "(see http://thinkdast.com/interbaseprog)."], ["method swapelements, elements constant time operations second method, loop executes, constant time operations third method selectionsort sorts, lowindex sorts elements place", "For example, here's an implementation of a simple algorithm d n sort (see http://thinkdast.com/selectsort):\npublic class SelectionSort {\n    /**\n     * Swaps the elements at indexes i and j.\n     */\n    public static void swapElements(int[] array, int i, int j) {\n        int temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n    /**\n     * Finds the index of the lowest value\n     * starting from the index at start (inclusive)\n     * and going to the end of the array.\n     */\n    public static int indexLowest(int[] array, int start) {\n        int lowIndex = start;\n        for (int i = start; i < array.length; i++) {\n            if (array[i] < array[lowIndex]) {\n                lowIndex = i;\n            }\n        }\n        return lowIndex;\n    }\n    /**\n     * Sorts the elements (in place) using selection sort.\n     */\n    public static void selectionSort(int[] array) {\n        for (int i = 0; i < array.length; i++) {\n            int j = indexLowest(array, i);\n            swapElements(array, i, j);\n        }\n    }\n}\nThe first method, \"swapElements\", swaps two elements of e y. Reading and writing elements are constant time operations,\nThe second method, \"indexLowest\", finds the index of the t t of the array starting at a given index, \"start\". h e through the loop, it accesses two elements of the array d s one comparison. Since these are all constant time operations,\nThe third method, \"selectionSort\", sorts the array. It loops from\n0 to n-1, so the loop executes n times. h e, it calls \"indexLowest\" and then performs a constant e n, \"swapElements\".\nThe first time \"indexLowest\" is called, t s n comparisons. The second time, it s n-1 comparisons, and so on. The total number of comparisons is n + n-1 + n-2 + ... + 1 + 0. The sum of this series is n(n+1)/2, which s l to n^2; and that means that \"selectionSort\""], ["compute location, simple let number comparisons, call n times total number, number comparisons general number comparisons, array call start, loop time call, everything swapelements constant time whole method, result different way, know size elements location f e, addition e constant time operations", "because if we know the size of the elements and the location f e first, we can compute the location of any other t h one multiplication and one addition, d e are constant time operations. Since everything in\n\"swapElements\" is constant time, the whole method is t e.\n\"indexLowest\", the number of operations is l o n. We call it n times, so the total number f s is proportional to n^2."], ["matter ones, simple let number comparisons, call n times total number, number comparisons general number comparisons, array call start, loop time call, indexlowest traverses entire array total number comparisons, result different way", "it doesn't really matter which ones we count. To keep it simple, let's t the number of comparisons.\n- If \"start\" is 0, \"indexLowest\" traverses the entire\n  array, and the total number of comparisons is the length of\n  the array, which I'll call n.\n- If \"start\" is 1, the number of comparisons is n-1.\n- In general, the number of comparisons is n - \"start\", so\n  \"indexLowest\" is linear."], ["method swapelements, compute location, elements constant time operations second method, call n times total number, number comparisons general number comparisons, array call start, loop time call, everything swapelements constant time whole method, loop executes, result different way, know size elements location f e, constant time operations third method selectionsort sorts, lowindex sorts elements place, addition e constant time operations", "is quadratic."], ["matter ones, compute location, simple let number comparisons, call n times total number, number comparisons general number comparisons, array call start, loop time call, indexlowest traverses entire array total number comparisons, result different way", "To get to the same result a different way, we can think of"], ["simple let number comparisons, call n times total number, number comparisons general number comparisons, array call start, loop time call, result different way", "\"indexLowest\" as a nested loop. Each time we call"], ["general rules, runtimes big category example linear algorithms belong r f growth runtimes, e important kind analysis, convenient way, compose example", "All constant time algorithms belong to a set called O(1). So another y o say that an algorithm is constant time is to say that it is in O(1).\nSimilarly, all linear algorithms belong to O(n), and all c s belong to O(n^2). This way of classifying algorithms is called\nThis notation provides a convenient way to write general rules about w s behave when we compose them. For example, if you perform a r time algorithm followed by a constant algorithm, the total n e is linear. Using ∈ to mean \"is a member of\":\nIn fact, if you perform a linear operation any number of times,\nk, the total is linear, as long as k is a t t does not depend on n.\nIf f ∈ O(n) and k is a constant, kf ∈ O(n).\nBut if you perform a linear operation n times, the result s c:\nO(n). The leading constant, 2, and the additive term, 1, e t important for this kind of analysis. Similarly, n^2 + 100n + 1000 s n O(n^2).  Don't be distracted by the big numbers!\n\"Order of growth\" is another name for the same idea.  An order f h is a set of algorithms whose runtimes are in the same big O\ncategory; for example, all linear algorithms belong to the same r f growth because their runtimes are in O(n)."], ["exponent f e total number operations, linear operations, f n g n n, big notation note, general care, n f n nf, casual definition big notation e l treatment e p f n g, context order group", "\"big O notation\".\nNOTE: I am providing a casual definition of big O notation. For a e l treatment, e p://thinkdast.com/bigo.\nIf f ∈ O(n) and g ∈ O(1), f+g ∈ O(n).\nIf f ∈ O(n), nf ∈ O(n^2)."], ["exponent f e total number operations, linear operations, f n g n n, general care, casual definition big notation e l treatment e p f n g, context order group", "If you perform two linear operations, the total is still linear:"], ["exponent f e total number operations, linear operations, f n g n n, general care, casual definition big notation e l treatment e p f n g, context order group", "If f ∈ O(n) and g ∈ O(n), f+g ∈ O(n)."], ["exponent f e total number operations, linear operations, f n g n n, general care, casual definition big notation e l treatment e p f n g, context order group", "In general, we only care about the largest exponent of n. So f e total number of operations is 2n + 1, it belongs to"], ["imagine order r, exponent f e total number operations, linear operations, f n g n n, general care, e knights round table group knights, casual definition big notation e l treatment e p f n g, context order group", "In this context, an \"order\" is a group, like the \\emph{Order f e Knights of the Round Table}, which is a group of knights, not a y f lining them up. So you can imagine the \\emph{Order of r s} as a set of brave, chivalrous, and particularly t s."], ["many methods identify order growth, index invalid, n e special case, constant time, int index e element e old get index array index element return, e example implementation, elements average expect test half elements, e exercise public e, uses implementation, classified get classify set, n r", "For many methods, we can identify the order of growth by examining e e. For example, here's the implementation of \"get\" from\nwhich uses it. Here is our implementation of \"set\" from e s exercise:\n    public E set(int index, E element) {\n        E old = get(index);\n        array[index] = element;\n        return old;\n    }"], ["index invalid, n e special case, constant time, int index index, public int indexof object target int, elements average expect test half elements, new indexoutofboundsexception return array index, similar implementation public e, classified get classify set, n r, size equals", "\"MyArrayList\":\n    public E get(int index) {\n        if (index < 0 || index >= size) {\n            throw new IndexOutOfBoundsException();\n        }\n        return array[index];\n    }\nOne slightly clever part of this solution is that it does not check e s of the array explicitly; it takes advantage of \"get\",\nNext we'll look at some linear methods. For example, here's y n of \"indexOf\":\n    public int indexOf(Object target) {\n        for (int i = 0; i<size; i++) {\n            if (equals(target, array[i])) {\n                return i;\n            }\n        }\n        return -1;\n    }\nThe analysis of \"remove\" is similar. Here's my implementation:\n    public E remove(int index) {\n        E element = get(index);\n        for (int i=index; i<size-1; i++) {\n            array[i] = array[i+1];\n        }\n        size--;\n        return element;\n    }"], ["problem everything, method constant time e e, index invalid, n e special case, constant time, elements average expect test half elements, invocation get time, element loop, classified get classify set, n r", "Everything in \"get\" is constant time, so \"get\" is t e. No problem.\nEverything in \"set\", including the invocation of \"get\", s t time, so \"set\" is also constant time.\nIt uses \"get\", which is constant time, and then loops through e y, starting from \"index\". If we remove the element at the d f the list, the loop never runs and this method is constant time. If e e the first element, we loop through all of the remaining elements,"], ["index invalid, n e special case, constant time, classify equals first private boolean equals object target object element target null return element null, elements average expect test half elements, indexof invokes equals, depend size target element depend size array consider time purposes, element method invokes, classified get classify set, n r", "Now that we've classified \"get\", we can classify \"set\","], ["many methods identify order growth, index invalid, n e special case, constant time, int index e element e old get index array index element return, e example implementation, elements average expect test half elements, e exercise public e, uses implementation, classified get classify set, n r", "which raises an exception if the index is invalid."], ["n e special case, constant time, classify equals first private boolean equals object target object element target null return element null, classified get classify set, elements average expect test half elements, indexof invokes equals, depend size target element depend size array consider time purposes, element method invokes, index invalid, n r", "Each time through the loop, \"indexOf\" invokes \"equals\", o e have to classify \"equals\" first. Here it is:\n    private boolean equals(Object target, Object element) {\n        if (target == null) {\n            return element == null;\n        } else {\n            return target.equals(element);\n        }\n    }\nThis method invokes \"target.equals\"; the runtime of this d t depend on the size of \"target\" or \"element\", but t y doesn't depend on the size of the array, so we consider t t time for purposes of analyzing \"indexOf\"."], ["index invalid, many times, unlikely case e, array linear method, n e special case, constant time, elements average expect test half elements, element end e end, indexof everything, classified get classify set, n r", "Getting back to \"indexOf\", everything inside the loop is t e, so the next question we have to consider is: how many times s e loop execute?"], ["index invalid, n e special case, constant time, int index index, public int indexof object target int, elements average expect test half elements, new indexoutofboundsexception return array index, similar implementation public e, classified get classify set, n r, size equals", "If we get lucky, we might find the target object right away and n r testing only one element. If we are unlucky, we might have to t l of the elements. On average, we expect to test half of the elements,"], ["index invalid, many times, unlikely case e, array linear method, n e special case, constant time, elements average expect test half elements, element end e end, indexof everything, classified get classify set, n r", "so this method is considered linear (except in the unlikely case t e know the target element is at the beginning of the array).\nwhich is linear. So, again, this method is considered linear (except n e special case where we know the element is at the end or a t e from the end)."], ["analysis beginners key idea, cost copying array amortized series invocations, element size array, elements stores, case analysis", "Here's a version of \"add\" that takes n x and an element as parameters:\n    public void add(int index, E element) {\n        if (index < 0 || index > size) {\n            throw new IndexOutOfBoundsException();\n        }\n        // add the element to get the resizing\n        add(element);\n        // shift the other elements\n        for (int i=size-1; i>index; i--) {\n            array[i] = array[i-1];\n        }\n        // put the new one in the right place\n        array[index] = element;\n    }\nThis two-parameter version, called \"add(int, E)\", s e one-parameter version, called \"add(E)\", which puts e w element at the end. Then it shifts the other elements to the right,\nBefore we can classify the two-parameter \"add(int, E)\", we e o classify the one-parameter \"add(E)\":\n    public boolean add(E element) {\n        if (size >= array.length) {\n            // make a bigger array and copy over the elements\n            E[] bigger = (E[]) new Object[array.length * 2];\n            System.arraycopy(array, 0, bigger, 0, array.length);\n            array = bigger;\n        }\n        array[size] = element;\n        size++;\n        return true;\n    }\nassume we start with an array that has room for 2 elements.\n- The first time we call add, it finds unused space in the array, so it\n  stores 1 element.\n- The second time, it finds unused space in the array, so it stores 1\n  element.\n- The third time, we have to resize the array, copy 2 elements, and\n  store 1 element. Now the size of the array is 4.\n- The fourth time stores 1 element.\n- The fifth time resizes the array, copies 4 elements, and stores 1\n  element. Now the size of the array is 8.\n- The next 3 adds store 3 elements.\n- The next add copies 8 and stores 1. Now the size is 16.\n- The next 7 adds store 7 elements.\n\"add(int, E)\"? After calling \"add(E)\", it loops h t of the array and shifts elements. This loop is linear, except n e special case where we are adding at the end of the list. So"], ["new element correct place, potential confusion use average, note patrick, analysis beginners key idea, constant time, e n elements, e loops h array shifts elements, total number f, element size array, array size element return true assume start array room, elements first time call, indexof average sequence operations, array copy", "and puts the new element in the correct place.\nBy now you should see the pattern: to do n adds, we have o e n elements and copy n-2. So the total number f s is n + n - 2, which is 2n-2."], ["new element correct place, potential confusion use average, note patrick, analysis beginners key idea, constant time, e n elements, copied otherwise add, total number f, indexof average sequence operations, linear e time average key double length e time, amount e h array, hard analyze n unused space array constant time e array linear e proportional size array, strange algorithm", "The one-parameter version turns out to be hard to analyze. If there s n unused space in the array, it is constant time, but if we have o e the array, it's linear because \"System.arraycopy\" s e proportional to the size of the array.\nIt might seem strange that an algorithm that is sometimes linear can e t time on average. The key is that we double the length of e y each time it gets resized. That limits the number of times h t gets copied. Otherwise --- if we add a fixed amount to e h of the array, rather than multiplying by a fixed amount --- e s doesn't work."], ["new element correct place, potential confusion use average, note patrick, analysis beginners key idea, constant time, e n elements, total number f, element size array, e constant time, indexof average sequence operations", "So is {\\tt add} constant time or linear?\n\"add\" as constant time.\nNow, if \"add(E)\" is constant time, what about\n\"add(int, E)\" is linear."], ["new element correct place, average time invocations, potential confusion use average, note patrick, analysis beginners key idea, big e term, constant time, e n elements, add divide total n result, total number f, difference average way, indexof average sequence operations, confusing experts", "We can classify this method by thinking about the average number f s per add over a series of n adds. For simplicity,\nTo get the average number of operations per add, we divide the total y n; the result is 2 - 2/n. As n gets big, e d term, 2/n, gets small. Invoking the principle that e y care about the largest exponent of n, we can think of\n% was an average over a hypothetical set of inputs when we looked at\n% confusing for experts (who know the difference between average\nThis way of classifying an algorithm, by computing the average time in a s of invocations, is called **amortized analysis**.  You n d more about it at"], ["potential confusion use average, note patrick, analysis beginners key idea, constant time, copied otherwise add, element size array, e constant time, indexof average sequence operations, linear e time average key double length e time, amount e h array, hard analyze n unused space array constant time e array linear e proportional size array, strange algorithm", "And so on. Adding things up:\n- After 4 adds, we've stored 4 elements and copied 2.\n- After 8 adds, we've stored 8 elements and copied 6.\n- After 16 adds, we've stored 16 elements and copied 14."], ["new element correct place, potential confusion use average, note patrick, analysis beginners key idea, constant time, e n elements, total number f, element size array, e constant time, indexof average sequence operations", "% NOTE: Patrick notes potential confusion in my use of average, which"], ["new element correct place, potential confusion use average, note patrick, analysis beginners key idea, constant time, e n elements, e loops h array shifts elements, total number f, element size array, array size element return true assume start array room, elements first time call, indexof average sequence operations, array copy", "% indexOf, and here is the average over a sequence of operations."], ["potential confusion use average, note patrick, analysis beginners key idea, constant time, copied otherwise add, element size array, e constant time, indexof average sequence operations, linear e time average key double length e time, amount e h array, hard analyze n unused space array constant time e array linear e proportional size array, strange algorithm", "% I am inclined to leave this alone on the grounds that it it more"], ["new element correct place, potential confusion use average, note patrick, analysis beginners key idea, constant time, e n elements, cost copying array amortized series invocations, total number f, element size array, indexof average sequence operations, elements stores, case analysis", "% case analysis and amortized analysis) than for beginners (who will\nThe key idea is that the extra cost of copying the array s d, or \"amortized\", over a series of invocations."], ["potential confusion use average, note patrick, analysis beginners key idea, constant time, copied otherwise add, element size array, e constant time, indexof average sequence operations, linear e time average key double length e time, amount e h array, hard analyze n unused space array constant time e array linear e proportional size array, strange algorithm", "% not, I conjecture, be bothered)."], ["potential confusion use average, note patrick, analysis beginners key idea, constant time, copied otherwise add, element size array, e constant time, indexof average sequence operations, linear e time average key double length e time, amount e h array, hard analyze n unused space array constant time e array linear e proportional size array, strange algorithm", "http://thinkdast.com/amort."], ["removeall e n myarraylist, method loop, removeall linear collection elements, case removeall linear respect size e n proportional n removeall quadratic r e collection, removeall collection collection boolean flag true object obj collection flag, nm size collection, removeall invokes, obj return flag collection collection, removeall c, contains n elements", "The last example we'll consider is \"removeAll\"; here's e n in \"MyArrayList\":\n    public boolean removeAll(Collection<?> collection) {\n        boolean flag = true;\n        for (Object obj: collection) {\n            flag &= remove(obj);\n        }\n        return flag;\n    }\n\"collection\". If \"collection\" contains m elements and e t we are removing from contains n elements, this method is in\n\"removeAll\" is linear. But if \"collection\" y s 1\\% of the elements in the list, \"removeAll\" s c."], ["method loop, removeall linear collection elements, case removeall linear respect size e n proportional n removeall quadratic r e collection, nm size collection, removeall invokes, removeall c", "Each time through the loop, \"removeAll\" invokes \"remove\",\nIn this method, the loop runs once for each element in"], ["method loop, shortcut f g, removeall linear collection elements, case removeall linear respect size e n proportional n removeall quadratic r e collection, nm size collection, removeall invokes, removeall c", "which is linear.  So it is tempting to think that \"removeAll\" s c.  But that's not necessarily the case.\n\"removeAll\" is linear with respect to n. But if the size of e n is proportional to n, \"removeAll\" is quadratic. r e, if \"collection\" always contains 100 or fewer elements,"], ["method loop, removeall linear collection elements, last example, case removeall linear respect size e n proportional n removeall quadratic r e collection, nm size collection, removeall invokes, removeall c", "O(nm). If the size of \"collection\" can be considered constant,"], ["method loop, g e, removeall linear collection elements, case removeall linear respect size e n proportional n removeall quadratic r e collection, number iterations, n loops, nm size collection, removeall invokes, talk problem size l size, pitfall algorithm analysis, removeall c", "When we talk about **problem size**, we have to be l t which size, or sizes, we are talking about. This e s a pitfall of algorithm analysis: the tempting shortcut f g loops.  If there is one loop, the algorithm is n r.  If there are two loops (one nested inside the other), e m is often quadratic. But be careful! You have to k t how many times each loop runs. If the number of iterations s l to n for all loops, you can get away with just g e loops. But if, as in this example, the number of iterations is t s proportional to n, you have to give it more thought."], ["list contain number nodes, order e node next field, l ways, r data, new listnode", "For the next exercise I provide a partial implementation of the \"List\"\ninterface that uses a linked list to store the elements.\nbut this section provides a brief introduction.\nThe \"ListNode\" object has two instance variables: \"data\" is a e to some kind of \"Object\", and \"next\" is a reference o e next node in the list. In the last node in the list, by convention,\n\"ListNode\" provides several constructors, allowing you to provide s r \"data\" and \"next\", or initialize them to the t e, \"null\".\nYou can think of each \"ListNode\" as a list with a single element,\nbut more generally, a list can contain any number of nodes. There e l ways to make a new list. A simple option is to create a set of\n\"ListNode\" objects, like this:\n        ListNode node1 = new ListNode(1);\n        ListNode node2 = new ListNode(2);\n        ListNode node3 = new ListNode(3);"], ["p data structure, nodes contain references, order e node next field, object diagram, list u n, node contains, next node e, sequence instructions, contain references, node2 node3 null null, refer objects", "If you are not familiar with linked lists, you can read about them t p://thinkdast.com/linkedlist,\nA data structure is \"linked\" if it is made up of objects, often called\n\"nodes\", that contain references to other nodes. In a d t, each node contains a reference to the next node in e t. Other linked structures include trees and graphs, in which s n contain references to more than one other node."], ["public string, order e node next field, null public listnode object data data, object diagram, list u n, sequence instructions, node2 node3 null null, public listnode object, return listnode, listnode integer instance variables, refer objects", "Here's a class definition for a simple node:\npublic class ListNode {\n    public Object data;\n    public ListNode next;\n    public ListNode() {\n        this.data = null;\n        this.next = null;\n    }\n    public ListNode(Object data) {\n        this.data = data;\n        this.next = null;\n    }\n    public ListNode(Object data, ListNode next) {\n        this.data = data;\n        this.next = next;\n    }\n    public String toString() {\n        return \"ListNode(\" + data.toString() + \")\";\n    }\n}\n(like \"ListNode\" and \"Integer\") and their instance variables n e inside."], ["public string, order e node next field, null public listnode object data data, object diagram, list u n, sequence instructions, node2 node3 null null, public listnode object, return listnode, listnode integer instance variables, refer objects", "\"next\" is \"null\".\nAnd then link them up, like this:\n        node1.next = node2;\n        node2.next = node3;\n        node3.next = null;\n\"null\"."], ["create node link time r e, public string, list contain number nodes, order e node next field, null public listnode object data data, object diagram, list u n, r data, l ways, new listnode, public listnode object, return listnode, listnode integer instance variables, refer objects", "Alternatively, you can create a node and link it at the same time. r e, if you want to add a new node at the beginning of a list, u n do it like this:\n        ListNode node0 = new ListNode(0, node1);"], ["p data structure, nodes contain references, order e node next field, object diagram, list u n, node contains, next node e, sequence instructions, contain references, node2 node3 null null, refer objects", "After this sequence of instructions, we have four nodes containing the"], ["list contain number nodes, order e node next field, l ways, r data, object diagram, list u n, new listnode, sequence instructions, node2 node3 null null, refer objects", "\"Integer\"s 0, 1, 2, and 3 as data, linked up in increasing order. In e t node, the \"next\" field is"], ["order e node next field, object diagram, list u n, sequence instructions, node2 node3 null null, refer objects", "  In an object diagram,"], ["p data structure, nodes contain references, order e node next field, object diagram, list u n, node contains, next node e, sequence instructions, contain references, node2 node3 null null, refer objects", "variables appear as names inside boxes, with arrows that show t y refer to.  Objects appear as boxes with their type on the outside"], ["implementation clear method public void clear head null size, unused nodes, myarraylist previous exercise array, performance bug, list implementation shrinks, head null remove reference e node references, sense right thing, garbage collector work l number elements", "In \"MyArrayList\" from the previous exercise, the array grows f y, but it never shrinks. The array never gets garbage collected,\nOne advantage of the linked list implementation is that it shrinks n s are removed, and the unused nodes can get garbage d y."], ["implementation clear method public void clear head null size, performance bug, garbage collector work l number elements, head null remove reference e node references, e java lot work, sense right thing, garbage collection, list node get garbage, point reference second node, belong order growth", "and the elements don't get garbage collected until the list itself s d.\n\"Node\" (and there shouldn't be), it will get garbage collected.\nAt that point, the reference to the second \"Node\" is removed, o t gets garbage collected, too. This process continues until l s are collected.\nbut it doesn't belong to the order of growth we expected. In s e Java that do a lot of work, like garbage collection, behind e s, this kind of bug can be hard to find."], ["implementation clear method public void clear head null size, performance bug, garbage collector work l number elements, unused nodes, head null remove reference e node references, e java lot work, sense right thing, garbage collection, list node get garbage, point reference second node, belong order growth", "Here is my implementation of the \"clear\" method:\n    public void clear() {\n        head = null;\n        size = 0;\n    }"], ["implementation clear method public void clear head null size, performance bug, classify clear method contains time operations sure looks, head null remove reference e node references, sense right thing, garbage collector work l number elements", "When we set \"head\" to \"null\", we remove a reference to e t \"Node\". If there are no other references to that"], ["implementation clear method public void clear head null size, performance bug, constant time, classify clear method contains time operations sure looks, head null remove reference e node references, sense right thing, garbage collector work l number elements", "So how should we classify \"clear\"? The method itself contains o t time operations, so it sure looks like it's constant time. t n you invoke it, you make the garbage collector do work that's l to the number of elements. So maybe e d consider it linear!"], ["implementation clear method public void clear head null size, performance bug, classify clear method contains time operations sure looks, head null remove reference e node references, sense right thing, garbage collector work l number elements", "This is an example of what is sometimes called a **performance bug**:"], ["implementation clear method public void clear head null size, performance bug, unused nodes, constant time, classify clear method contains time operations sure looks, head null remove reference e node references, sense right thing, garbage collector work l number elements", "a program that is correct in the sense that it does the right thing,"], ["new node e g, order growth, advance next node list index, whole list method try, identify order growth read explanation public int indexof object target node node head int size equals", "My implementation of \"indexOf\" is below. Read through it and e f you can identify its order of growth before you read the explanation.\n    public int indexOf(Object target) {\n        Node node = head;\n        for (int i=0; i<size; i++) {\n            if (equals(target, node.data)) {\n                return i;\n            }\n            node = node.next;\n        }\n        return -1;\n    }\nSo what is the order of growth for this method?\n- Each time through the loop we invoke \"equals\", which is\n  constant time (it might depend on the size of \"target\" or\n  \"data\", but it doesn't depend on the size of the list). The\n  other operations in the loop are also constant time.\n- The loop might run n times, because in the worse case, we\n  might have to traverse the whole list.\nmethod. Again, you should try to classify it before you read e n.\n    public void add(int index, E element) {\n        if (index == 0) {\n            head = new Node(element, head);\n        } else {\n            Node node = getNode(index-1);\n            node.next = new Node(element, node.next);\n        }\n        size++;\n    }\nIf \"index==0\", we're adding the new \"Node\" at e g, so we handle that as a special case. Otherwise, we have o e the list to find the element at \"index-1\". We use e r method \"getNode\":\n    private Node getNode(int index) {\n        if (index < 0 || index >= size) {\n            throw new IndexOutOfBoundsException();\n        }\n        Node node = head;\n        for (int i=0; i<index; i++) {\n            node = node.next;\n        }\n        return node;\n    }\nSo, what's the order of growth for \"add\"?\n- \"getNode\" is similar to\n  \"indexOf\", and it is linear for the same reason.\n- In \"add\", everything before and after \"getNode\" is\n  constant time.\nFinally, let's look at \"remove\":\n    public E remove(int index) {\n        E element = get(index);\n        if (index == 0) {\n            head = head.next;\n        } else {\n            Node node = getNode(index-1);\n            node.next = node.next.next;\n        }\n        size--;\n        return element;\n    }\nIf \"index==0\", we handle that as a special case again. e e find the node at \"index-1\" and modify it to skip over"], ["decrement size return element, next implementation, head r node loop, order growth, advance next node list index, target return, helpful draw diagram operation, sure next node, list e e, getnode linear remove linear", "Initially \"node\" gets a copy of \"head\", so they both r o the same \"Node\". The loop variable, \"i\", counts from 0 to\n\"size-1\".  Each time through the loop, we use \"equals\" o e if we've found the target. If so, we return \"i\" immediately.\nNormally we would check to make sure the next \"Node\" is not\nit throws an exception. Otherwise it traverses the list and returns e d Node.\nJumping back to \"add\", once we find the right \"Node\", we create e w \"Node\" and put it between \"node\" and \"node.next\". u t find it helpful to draw a diagram of this operation to make e u understand it.\n\"node.next\" and link directly to \"node.next.next\". s y removes \"node.next\" from the list, and it can e e collected."], ["decrement size return element, next implementation, new node e g, order growth, advance next node list index, target return, whole list method try, identify order growth read explanation public int indexof object target node node head int size equals, getnode linear remove linear", "Otherwise we advance to the next \"Node\" in the list.\n\"index\". Then it removes the \"Node\" that contained it."], ["decrement size return element, next implementation, getnode linear remove linear, order growth, advance next node list index, null case safe loop, e end list, getnode checks, target return, size consistent h e actual number nodes list, index bounds", "\"null\", but in this case it is safe because the loop ends when e t to the end of the list (assuming \"size\" is consistent h e actual number of nodes in the list)."], ["decrement size return element, next implementation, head r node loop, order growth, advance next node list index, target return, helpful draw diagram operation, sure next node, list e e, getnode linear remove linear", "If we get through the loop without finding the target, we return"], ["find store element, decrement size return element, constant time, order growth, advance next node list index, new node e g, target return, whole list method try, identify order growth read explanation public int indexof object target node node head int size equals, getnode linear remove linear", "\"-1\"."], ["quadratic applies, operation n sum, decrement size return element, runtime method proportional length e people, linear operations, e e, next implementation, order growth, advance next node list index, target return, getnode linear remove linear", "So the runtime of this method is proportional to the length of e t.\nWhen people see two linear operations, they sometimes think the t s quadratic, but that only applies if one operation is nested e e other. If you invoke one operation after the other, the s d. If they are both in O(n), the sum is also in"], ["decrement size return element, next implementation, head r node loop, order growth, advance next node list index, target return, helpful draw diagram operation, sure next node, list e e, getnode linear remove linear", "Next, here is my implementation of the two-parameter \"add\"\nSo all together, \"add\" is linear."], ["decrement size return element, next implementation, getnode linear remove linear, order growth, advance next node list index, null case safe loop, e end list, getnode checks, target return, size consistent h e actual number nodes list, index bounds", "\"getNode\" checks whether \"index\" is out of bounds; if so,"], ["find store element, decrement size return element, next implementation, constant time, order growth, advance next node list index, target return, getnode linear remove linear", "\"remove\" uses \"get\" to find and store the element at\n\"remove\" is constant time except \"get\" and"], ["decrement size return element, next implementation, getnode linear remove linear, order growth, advance next node list index, null case safe loop, e end list, getnode checks, target return, size consistent h e actual number nodes list, index bounds", "Finally, we decrement \"size\" and return the element we d t the beginning."], ["decrement size return element, next implementation, new node e g, order growth, advance next node list index, target return, whole list method try, identify order growth read explanation public int indexof object target node node head int size equals, getnode linear remove linear", "So, what's the order of growth for \"remove\"? Everything in"], ["find store element, decrement size return element, next implementation, constant time, order growth, advance next node list index, target return, getnode linear remove linear", "\"getNode\", which are linear. So \"remove\" is linear."], ["find store element, decrement size return element, constant time, order growth, advance next node list index, new node e g, target return, whole list method try, identify order growth read explanation public int indexof object target node node head int size equals, getnode linear remove linear", "O(n)."], ["e n depends, constant time, n r r, use java, f growth, table summarizes differences", "The following table summarizes the differences between"], ["e end, e n depends, mylinkedlist myarraylist, constant time, operations mylinkedlist advantage g, n r r, means operations myarraylist advantage, use java, f growth, table summarizes differences", "\"MyLinkedList\" and \"MyArrayList\", where \"1\" means\nThe operations where \"MyArrayList\" has an advantage are adding t e end, removing from the end, getting and setting.\nThe operations where \"MyLinkedList\" has an advantage are g t the beginning and removing from the beginning."], ["e end, e n depends, mylinkedlist myarraylist, constant time, operations mylinkedlist advantage g, n r r, means operations myarraylist advantage, use java, f growth, table summarizes differences", "O(1) or constant time and n means O(n) r r."], ["e n depends, constant time, n r r, use java, f growth, table summarizes differences", "For the other operations, the two implementations are in the same r f growth."], ["e n depends, constant time, n r r, use java, f growth, table summarizes differences", "Which implementation is better? It depends on which operations you e y to use the most. And that's why Java provides more than e n, because it depends."], ["column problem size n second column e milliseconds first measurements, measure case n elements list, timeable object title parameters, startn low runtime, arraylist linkedlist arraylist, method java implementations, modify example code next step, clear relationship problem size code run, next section, u e comfortable anonymous classes", "For the next exercise I provide a class called \"Profiler\" t s code that runs a method with a range of problem sizes,\nYou will use \"Profiler\" to classify the e f the \"add\" method for the Java implementations of\nBut you don't need to know much for the next exercise; even if u e not comfortable with anonymous classes, you n y and modify the example code.\nThe next step is to create the \"Profiler\" object, passing the\nThe \"Profiler\" provides \"timingLoop\" which uses the\nWhen you run the experiments, you might have to adjust e s. If \"startN\" is too low, the runtime might be o t to measure accurately. If \"endMillis\" is too low, you t t get enough data to see a clear relationship between problem size d e.\nThis code is in \"ProfileListAdd.java\", which you'll run in the t e. When I ran it, I got this output:\n4000, 3\n8000, 0\n16000, 1\n32000, 2\n64000, 3\n128000, 6\n256000, 18\n512000, 30\n1024000, 88\n2048000, 185\n4096000, 242\n8192000, 544\n16384000, 1325"], ["loop start endmillis, column problem size n second column e milliseconds first measurements, measure case n elements list, exceeds threshold timingloop stops, timeable object title parameters, startn value, arraylist linkedlist arraylist, timingloop increases problem size runtime increases, next section, timingloop xyseries data pass series plotresults", "measures runtimes, and plots the results.\n\"timeMe\" method on the \"Timeable\" object several s h a range of values of n. \"timingLoop\" takes o s:\n- \"startN\" is the value of n the timing loop should\n  start at.\n- \"endMillis\" is a threshold in milliseconds. As\n  \"timingLoop\" increases the problem size, the runtime increases;\n  when the runtime exceeds this threshold, \"timingLoop\" stops.\nThe result from \"timingLoop\" is an \"XYSeries\" t s this data. If you pass this series to \"plotResults\", t s a plot like the one in"], ["column problem size n second column e milliseconds first measurements, measure case n elements list, timeable object title parameters, arraylist linkedlist arraylist, new element end n e code show results, next section", "\"ArrayList\" and \"LinkedList\".\n\"ArrayList\", which adds the new element at the end. I'll n e code and then show the results."], ["instance variable invokes, profiler public static void profilearraylistaddend timeable timeable new timeable list string list public void setup int n list new arraylist string public void timeme int n int n, methods setup timeme code, column problem size n second column e milliseconds first measurements, measure case n elements list, timeable object title parameters, profiler profiler new profiler title timeable int startn, arraylist linkedlist arraylist, timeable object, xyseries series startn endmillis series order, timeable anonymous class new implementation timeable interface instance new class time, next section, int endmillis, example shows", "Here's an example that shows how to use the profiler:\n    public static void profileArrayListAddEnd() {\n        Timeable timeable = new Timeable() {\n            List<String> list;\n            public void setup(int n) {\n                list = new ArrayList<String>();\n            }\n            public void timeMe(int n) {\n                for (int i=0; i<n; i++) {\n                    list.add(\"a string\");\n                }\n            }\n        };\n        String title = \"ArrayList add end\";\n        Profiler profiler = new Profiler(title, timeable);\n        int startN = 4000;\n        int endMillis = 1000;\n        XYSeries series = profiler.timingLoop(startN, endMillis);\n        profiler.plotResults(series);\n    }\nIn order to use \"Profiler\", we need to create a \"Timeable\"\nobject that provides two methods: \"setup\" and \"timeMe\".\nThe code that creates \"timeable\" is an **anonymous class** t s a new implementation of the \"Timeable\" interface d s an instance of the new class at the same time. If you are t r with anonymous classes, you can read about them here:\n\"Timeable\" object stored as an instance variable. It invokes the"], ["column problem size n second column e milliseconds first measurements, measure case n elements list, timeable object title parameters, startn low runtime, arraylist linkedlist arraylist, method java implementations, modify example code next step, clear relationship problem size code run, next section, u e comfortable anonymous classes", "This method measures the time it takes to run \"add\" on an\nThe \"setup\" method does whatever needs to be done before we t e clock; in this case it creates an empty list. Then \"timeMe\""], ["column problem size n second column e milliseconds first measurements, measure case n elements list, timeable object title parameters, arraylist linkedlist arraylist, new element end n e code show results, next section", "does whatever operation we are trying to measure; in this case it s n elements to the list."], ["column problem size n second column e milliseconds first measurements, measure case n elements list, timeable object title parameters, startn low runtime, arraylist linkedlist arraylist, method java implementations, modify example code next step, clear relationship problem size code run, new element end n e code show results, next section, u e comfortable anonymous classes", "http://thinkdast.com/anonclass."], ["column problem size n second column e milliseconds first measurements, measure case n elements list, timeable object title parameters, arraylist linkedlist arraylist, timeable object, xyseries series startn endmillis series order, next section, int endmillis, example shows", "\"Timeable\" object and a title as parameters."], ["column problem size n second column e milliseconds first measurements, measure case n elements list, timeable object title parameters, arraylist linkedlist arraylist, new element end n e code show results, next section", "The first column is problem size, n; the second column s e in milliseconds. The first few measurements are pretty noisy; t t have been better to set \"startN\" around 64000."], ["column problem size n second column e milliseconds first measurements, measure case n elements list, timeable object title parameters, arraylist linkedlist arraylist, new element end n e code show results, next section", "The next section explains how to interpret it."], ["constant time add elements, constant time, straight line slope slope, fit data prints, important point, slope mean algorithm linear n e proportional exponent k, understanding arraylist, total time, suggests total time r, straight line graph, figure previous section estimate e e eye call plotresults", "Based on our understanding of how \"ArrayList\" works, we t e \"add\" method to take constant time when we add elements o e end. So the total time to add n elements should be linear.\nwhich is close to 1; and that suggests that the total time r n adds is linear, so each add is constant time, as expected."], ["order growth, difference line parabola measurements, mathematically write e n line runtime b n intercept line b e hand, way interpret noisy measurements, total runtime versus problem size", "To test that theory, we could plot total runtime versus problem size,\nand we should see a straight line, at least for problem sizes that e g enough to measure accurately. Mathematically, we can write e n for that line: runtime = a + b n, where a is the intercept of the line and b is e e.\nOn the other hand, if \"add\" is linear, the total time r n adds would be quadratic. If we plot runtime versus m e, we expect to see a parabola. Or mathematically, something like: runtime = a + b n + c n^2. With perfect data, we might be able to tell the difference between a t line and a parabola, but if the measurements are noisy, it n e hard to tell. A better way to interpret noisy measurements is to t e and problem size on a **log-log** scale.\nWhy? Let's suppose that runtime is proportional to n^k, but e n't know what the exponent k is. We can write e p like this: runtime = a + b n + ... + c n^k. For large values of n, the term with the largest exponent s e most important, so: runtime ≈ c n^k, where ≈ means \"approximately equal\". Now, if e e the logarithm of both sides of this equation: log(runtime) ≈ log(c) + k log(n). This equation implies that if we plot runtime versus n on a g-log scale, we expect to see a straight line with t g(c) and slope k. We don't care much about e t, but the slope indicates the order of growth: f k=1, the algorithm is linear; if k=2, it's c."], ["straight line slope slope, important point, slope mean algorithm linear n e proportional exponent k, fit data prints, straight line graph, figure previous section estimate e e eye call plotresults", "Looking at the figure in the previous section, you can estimate e e by eye. But when you call \"plotResults\" it computes a t s fit to the data and prints the estimated slope. In s e:\nEstimated slope = 1.06194352346708\nthat does **not** mean that the algorithm is linear. If the n e is proportional to n^k for any exponent k, e t to see a straight line with slope k. If the slope s e to 1, that suggests the algorithm is linear. If it is close to 2,"], ["straight line slope slope, important point, slope mean algorithm linear n e proportional exponent k, fit data prints, straight line graph, figure previous section estimate e e eye call plotresults", "One important point: if you see a straight line on a graph like this,"], ["constant time add elements, constant time, order growth, runtime proportional e, difference line parabola measurements, mathematically write e n line runtime b n intercept line b e hand, plot runtime versus e, runtime b n c perfect data, understanding arraylist, large values n term, total time, suggests total time r, way interpret noisy measurements, total runtime versus problem size, exponent k write e p", "it's probably quadratic."], ["results problem size, fill body, reasonable describe, new element index, use average, note patrick, previous exercise, identical profilearraylistaddend e difference timeme, analysis average series operations, various method, additional data point", "In the previous exercise, we used \"Profiler.java\" to run various\nThis method is almost identical to \"profileArrayListAddEnd\". e y difference is in \"timeMe\", which uses the two-r n of \"add\" to put the new element at index 0. Also, e d \"endMillis\" to get one additional data point."], ["arraylist linkedlist operations, runtime versus problem size e, g new elements, proportional expect line slope, total time r", "\"ArrayList\" and \"LinkedList\" operations with a range f m sizes. We plotted runtime versus problem size on a log-g e and estimated the slope of the resulting curve, which s e leading exponent of the relationship between runtime and m e.\nFor example, when we used the \"add\" method to add s o the end of an \"ArrayList\", we found that the total time o m n adds was proportional to n; that is, e d slope was close to 1. We concluded that performing n s is in O(n), so on average the time for a single add s t time, or O(1), which is what we expect based on m s.\n\"profileArrayListAddBeginning\", which tests the performance f g new elements at the beginning of an \"ArrayList\". Based on r s, we expect each add to be linear, because it has to shift e r elements to the right; so we expect n adds to e c.\nRemember that a straight line on this graph does **not** mean t e algorithm is linear. Rather, if the runtime is proportional o n^k for any exponent, k, we expect to see a t e with slope k. In this case, we expect the total time r n adds to be proportional to n^2, so we expect a t line with slope 2. In fact, the estimated slope is 1.992, h s so close I would be afraid to fake data this good."], ["rather runtime proportional exponent k, fill body, results problem size, use average, reasonable describe, note patrick, e remember, analysis average series operations, e slope case", "% NOTE: Again, Patrick is concerned that my use of \"average\" might"], ["results problem size, fill body, reasonable describe, new element index, use average, note patrick, previous exercise, identical profilearraylistaddend e difference timeme, analysis average series operations, various method, additional data point", "% be confusing, but I think it's reasonable to describe amortized\n% analysis as an average over a series of operations."], ["results problem size, fill body, reasonable describe, use average, note patrick, analysis average series operations", "The exercise asks you to fill in the body of"], ["results problem size, fill body, reasonable describe, runprofiler arraylist, use average, note patrick, n e solution directory repository public static void, timeable timeable new timeable list string list public void setup int n list new arraylist string public void timeme int n int, analysis average series operations, timeable startn endmillis, int startn", "Here's a solution, which you can find n e {\\tt solution} directory of the repository.\n    public static void profileArrayListAddBeginning() {\n        Timeable timeable = new Timeable() {\n            List<String> list;\n            public void setup(int n) {\n                list = new ArrayList<String>();\n            }\n            public void timeMe(int n) {\n                for (int i=0; i<n; i++) {\n                    list.add(0, \"a string\");\n                }\n            }\n        };\n        int startN = 4000;\n        int endMillis = 10000;\n        runProfiler(\"ArrayList add beginning\", timeable, startN, endMillis);\n    }"], ["results problem size, fill body, reasonable describe, runprofiler arraylist, use average, note patrick, n e solution directory repository public static void, timeable timeable new timeable list string list public void setup int n list new arraylist string public void timeme int n int, analysis average series operations, timeable startn endmillis, int startn", "Here are the timing results (problem size on the left, runtime n s on the right):\n4000, 14\n8000, 35\n16000, 150\n32000, 604\n64000, 2518\n128000, 11555"], ["constant time n, list shift, good range data, linear solution public static void, e l time, squares fit results, make changes, startn endmillis, timeable timeable new timeable list string list public void setup int n list new linkedlist string public void timeme int n int, previous batch e e results, timeable startn endmillis arraylist linkedlist", "In the previous exercise you also profiled the performance of adding w s at the beginning of a \"LinkedList\". Based on r s, we expect each \"add\" to take constant time, because n a linked list, we don't have to shift the existing elements; we can t d a new node at the beginning. So we expect the total time r n adds to be linear.\nHere's a solution:\n    public static void profileLinkedListAddBeginning() {\n        Timeable timeable = new Timeable() {\n            List<String> list;\n            public void setup(int n) {\n                list = new LinkedList<String>();\n            }\n            public void timeMe(int n) {\n                for (int i=0; i<n; i++) {\n                    list.add(0, \"a string\");\n                }\n            }\n        };\n        int startN = 128000;\n        int endMillis = 2000;\n        runProfiler(\"LinkedList add beginning\", timeable, startN, endMillis);\n    }\n\"ArrayList\" with \"LinkedList\" and adjusting\nso each add is constant time."], ["good range data, e l time, startn endmillis, make changes, e f, previous batch e e results", "We only had a make a few changes, replacing"], ["good range data, e l time, squares fit results, startn endmillis, make changes, e f, previous batch e e results", "\"startN\" and \"endMillis\" to get a good range of data."], ["constant time n, list shift, good range data, linear solution public static void, squares fit results, make changes, startn endmillis, timeable timeable new timeable list string list public void setup int n list new linkedlist string public void timeme int n int, e f, previous batch e e results, timeable startn endmillis arraylist linkedlist", "The measurements were noisier than the previous batch; e e the results:\n128000, 16\n256000, 19\n512000, 28\n1024000, 77\n2048000, 330\n4096000, 892\n8192000, 1047\n16384000, 4755"], ["straight line slope, e l time, good range data, squares fit results, startn endmillis, make changes, e f, previous batch e e results", "It's not a very straight line, and the slope is not exactly 1; the e f the least squares fit is 1.23. But these results indicate that e l time for n adds is at least approximately O(n),"], ["analysis fact, constant time, arraylist r g elements, total time r, implementation traverse entire list add n end linear", "Adding elements at the beginning is one of the operations where e t \"LinkedList\" to be faster than \"ArrayList\". But r g elements at the end, we expect \"LinkedList\" to be slower."], ["analysis fact, constant time, arraylist r g elements, public static void profilelinkedlistaddend timeable timeable new timeable list string list public void setup int n list new linkedlist string public void timeme int n int n, int endmillis, total time r, runprofiler linkedlist add end timeable startn endmillis, int startn, implementation traverse entire list add n end linear", "In my implementation, we have to traverse the entire list to add n t to the end, which is linear. So we expect the total time r n adds to be quadratic."], ["analysis fact, constant time, arraylist r g elements, public static void profilelinkedlistaddend timeable timeable new timeable list string list public void setup int n list new linkedlist string public void timeme int n int n, int endmillis, total time r, runprofiler linkedlist add end timeable startn endmillis, int startn, implementation traverse entire list add n end linear", "Well, it's not.  Here's the code:\n    public static void profileLinkedListAddEnd() {\n        Timeable timeable = new Timeable() {\n            List<String> list;\n            public void setup(int n) {\n                list = new LinkedList<String>();\n            }\n            public void timeMe(int n) {\n                for (int i=0; i<n; i++) {\n                    list.add(\"a string\");\n                }\n            }\n        };\n        int startN = 64000;\n        int endMillis = 1000;\n        runProfiler(\"LinkedList add end\", timeable, startN, endMillis);\n    }"], ["analysis fact, constant time, arraylist r g elements, total time r, int startn, implementation traverse entire list add n end linear", "Here are the results:\n64000, 9\n128000, 9\n256000, 21\n512000, 24\n1024000, 78\n2048000, 235\n4096000, 851\n8192000, 950\n16384000, 6160"], ["analysis fact, measurements noisy line, arraylist r g elements, constant time, total time r, slope close e, int startn, implementation traverse entire list add n end linear", "Again, the measurements are noisy and the line is not y t, but the estimated slope is 1.19, which is close to t e got adding elements at the beginning, and not very close to 2, h s what we expected based on our analysis. In fact, it is closer to 1,"], ["analysis fact, constant time, arraylist r g elements, total time r, int startn, implementation traverse entire list add n end linear", "which suggests that adding elements at the end is constant time."], ["analysis fact, constant time, arraylist r g elements, total time r, int startn, implementation traverse entire list add n end linear", "What's going on?"], ["end list traverse r result, index familiar lists, object contains links, list mylinkedlist, previous node, g end list constant time, quote quote, e http short version node, next myarraylist object link first node, last elements list arraylist mylinkedlist linkedlist, table summarizes performance", "My implementation of a linked list, \"MyLinkedList\", uses a y-linked list; that is, each element contains a link to the next,\nand the \"MyArrayList\" object itself has a link to the first node.\nBut if you read the documentation of \"LinkedList\" t p://thinkdast.com/linked,\nDoubly-linked list implementation of the List and e s. [...] All of the operations perform s d be expected for a doubly-linked list. Operations t x into the list will traverse the list from the beginning or e d, whichever is closer to the specified index.\nIf you are not familiar with doubly-linked lists, you can read e t them at http://thinkdast.com/doublelist,\nbut the short version is:\n- Each node contains a link to the next node and a link to the previous\n  node.\n- The \"LinkedList\" object contains links to the first and last\n  elements of the list.\n\"ArrayList\", \"MyLinkedList\" (singly-linked), and\n\"LinkedList\" (doubly-linked):"], ["end list traverse r result, index familiar lists, object contains links, previous node, g end list constant time, quote quote, e http short version node, next myarraylist object link first node, last elements list arraylist mylinkedlist linkedlist, table summarizes performance", "it says:"], ["end list traverse r result, list mylinkedlist, previous node, g end list constant time, quote quote, table summarizes performance", "\\begin{quote}\n\\end{quote}"], ["end list traverse r result, list mylinkedlist, previous node, g end list constant time, quote quote, table summarizes performance", "So we can start at either end of the list and traverse it in r n. As a result, we can add and remove elements from e g and the end of the list in constant time!"], ["end list traverse r result, list mylinkedlist, previous node, g end list constant time, quote quote, table summarizes performance", "The following table summarizes the performance we expect from"], ["linear time, end linkedlist remember recommendations, space computer hardware, links links, g elements", "The doubly-linked implementation is better than \"ArrayList\" r g and removing at the beginning, and just as good as\n\"ArrayList\" for adding and removing at the end. So the y e of \"ArrayList\" is for \"get\" and \"set\",\nwhich require linear time in a linked list, even if it is doubly-linked.\nmight be the better choice. If the runtime depends on adding d g elements near the beginning or the end, \"LinkedList\"\nBut remember that these recommendations are based on the order of h r large problems. There are other factors to consider:\n- If these operations don't take up a substantial fraction of the\n  runtime for your application --- that is, if your applications spends\n  most of its time doing other things --- then your choice of a\n  \"List\" implementation won't matter very much.\n- If the lists you are working with are not very big, you might not get\n  the performance you expect. For small problems, a quadratic algorithm\n  might be faster than a linear algorithm, or linear might be faster\n  than constant time. And for small problems, the difference probably\n  doesn't matter.\n- Also, don't forget about space. So far we have focused on runtime, but\n  different implementations require different amounts of space. In an\n  \"ArrayList\", the elements are stored side-by-side in a single\n  chunk of memory, so there is little wasted space, and computer\n  hardware is often faster with contiguous chunks. In a linked list,\n  each element requires a node with one or two links. The links take up\n  space (sometimes more than the data!), and with nodes scattered\n  around in memory, the hardware might be less efficient."], ["runtime application, data structure, application important runtime application, guidance g structures, choice data structure problem size large enough order growth, software engineer, g f situation, elements arraylist summary analysis algorithms", "If you know that the runtime of your application depends on the time t s to \"get\" and \"set\" elements, an \"ArrayList\"\nIn summary, analysis of algorithms provides some guidance for g a structures, but only if\n- The runtime of your application is important,\n- The runtime of your application depends on your choice of data\n  structure, and\n- The problem size is large enough that the order of growth actually\n  predicts which data structure is better."], ["runtime application, linear time, good arraylist, much lists, application important runtime application, end linkedlist remember recommendations, list element, choice data structure problem size large enough order growth, choice runtime, runtime different implementations, software engineer, space computer hardware, links links, g f situation, g elements", "might be better."], ["runtime application, data structure, application important runtime application, choice data structure problem size large enough order growth, guidance g structures, software engineer, g f situation", "You could have a long career as a software engineer without ever g f in this situation."], ["web pages, program download web page parse extract text links pages, relevant means, google search bing, crawler goal crawler discover", "A **web search engine**, like Google Search or Bing, takes a t f \"search terms\" and returns a list of web pages that are t o those terms (I'll discuss what \"relevant\" means later).  You n d more at http://thinkdast.com/searcheng, but I'll n t you need as we go along.\nThe essential components of a search engine are:\n- Crawling: We'll need a program that can download a web page, parse it,\n  and extract the text and any links to other pages.\n- Indexing: We'll need a data structure that makes it possible to look up a\n  search term and find the pages that contain it.\n- Retrieval: And we'll need a way to collect results from the Index and\n  identify pages that are most relevant to the search terms.\nWe'll start with the crawler.  The goal of a crawler is to discover d d a set of web pages. For search engines like Google and Bing,\nthe goal is to find all web pages, but often crawlers are d o a smaller domain. In our case, we will only read pages m a."], ["e r, another page, first lowercase link main text article, quote quote, philosophy article chapters, l use crawler test, read history, first link, basic pieces r, philosophy conjecture", "As a first step, we'll build a crawler that reads a Wikipedia page,\nfinds the first link, follows the link to another page, and repeats. We l use this crawler to test the \"Getting to Philosophy\" conjecture,\nTesting the conjecture will allow us to build the basic pieces of a r without having to crawl the entire web, or even all f a. And I think the exercise is kind of fun!"], ["web pages, e r, need data structure, another page, google bing goal, pages relevant search terms, quote quote, philosophy article chapters, possible look search term, first lowercase link main text article, l use crawler test, read history, first link, basic pieces r, philosophy conjecture", "which states:"], ["e r, first lowercase link main text article, quote quote, philosophy article chapters, read history", "\\begin{quote}\n\\end{quote}"], ["e r, first lowercase link main text article, quote quote, philosophy article chapters, read history", "Clicking on the first lowercase link in the main text of a a article, and then repeating the process for t s, usually eventually gets one to the Philosophy article.\nIn a few chapters, we'll work on the indexer, and then we'll get to e r."], ["web pages, e r, need data structure, another page, google bing goal, pages relevant search terms, quote quote, philosophy article chapters, possible look search term, first lowercase link main text article, l use crawler test, read history, first link, basic pieces r, philosophy conjecture", "This conjecture is stated t p://thinkdast.com/getphil{},"], ["e r, first lowercase link main text article, quote quote, philosophy article chapters, read history", "and you can read its history there."], ["hello world text, chrome part web e, use element id, download web page contents, need parse html", "When you download a web page, the contents are written n t Markup Language, aka HTML.\nThe phrases \"This is a title\" and \"Hello world!\" are the text t y appears on the page; the other elements are **tags** t e how the text should be displayed.\nWhen our crawler downloads a page, it will need to parse the HTML n r to extract the text and find the links. To do that, we'll use\n**jsoup**, which is an open-source Java library that downloads d s HTML.\nMost web browsers provide tools for inspecting the DOM of the page u e viewing. In Chrome, you can right-click on any part of a web e d select \"Inspect\" from the menu that pops up. In Firefox, you n t-click and select \"Inspect Element\" from the menu. i s a tool called Web Inspector, which you can read about t p://thinkdast.com/safari.\nFor Internet Explorer, you can read the instructions t p://thinkdast.com/explorer.\n\"id=\"mw-content-text\"\". We'll use this element id to identify e n text of each article we download."], ["root html tag h links, example minimal html document doctype html html head title title body p hello world result, dom tree, node head, html document object model tree head title, text tags document elements relationships nodes, child body, document example, div element, first paragraph main f article, structure f", "For example, here is a minimal HTML document:\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>This is a title</title>\n  </head>\n  <body>\n    <p>Hello world!</p>\n  </body>\n</html>\nThe result of parsing HTML is a Document Object Model tree, or\n\"<head>\" and\n\"<title>\", and the"], ["root html tag h links, example minimal html document doctype html html head title title body p hello world result, dom tree, node head, html document object model tree head title, text tags document elements relationships nodes, child body, document example, div element, first paragraph main f article, structure f", "**DOM tree**, that contains the elements of the document, g t and tags. The tree is a linked data structure made up of nodes; e s represent text, tags, and other document elements.\nThe relationships between the nodes are determined by the structure f e document. In the example above, the first node, called the\n**root**, is the \"<html>\" tag, h s links to the two nodes it contains,\n\"<body>\"; these nodes are the\nEach node contains links to its children; in addition, each e s a link to its **parent**, so from any node it is e o navigate up and down the tree. The DOM tree for real pages is y e complicated than this example."], ["example minimal html document doctype html html head title title body p hello world result, node head, html document object model tree head title, child body, div element, first paragraph main f article", "**children** of the root node.\nThe \"<head>\" node has one child,\n\"<body>\" node has one child,"], ["html phrases, root html tag h links, example minimal html document doctype html html head title title body p hello world result, select inspect element menu tool, dom tree, structure f, html document object model tree head title, text tags document elements relationships nodes, inspect menu pops firefox, child body, div element, r extract text find links, crawler downloads, first paragraph main f article, document example", "\"<p>\" (which stands for \"paragraph\")."], ["html phrases, root html tag h links, example minimal html document doctype html html head title title body p hello world result, select inspect element menu tool, dom tree, structure f, html document object model tree head title, text tags document elements relationships nodes, inspect menu pops firefox, child body, div element, r extract text find links, crawler downloads, first paragraph main f article, document example", "com/java."], ["root html tag h links, example minimal html document doctype html html head title title body p hello world result, dom tree, node head, html document object model tree head title, text tags document elements relationships nodes, child body, document example, div element, first paragraph main f article, structure f", "The element that's highlighted is the first paragraph of the main t f the article, which is contained in a"], ["example minimal html document doctype html html head title title body p hello world result, node head, html document object model tree head title, child body, div element, first paragraph main f article", "\"<div>\" element with"], ["uml class diagram line hollow w, easy download parse web pages, http http p, know important classes, dom tree example string url http download parse document connection conn url document doc select content text pull paragraphs element content elements paragraphs p, skim documentation, another example, url string, uml diagrams, element textnode datanode comment elements collection element objects, method downloads html parses", "jsoup makes it easy to download and parse web pages, and to navigate the\nDOM tree. Here's an example:\n    String url = \"http://en.wikipedia.org/wiki/Java_(programming_language)\";\n    // download and parse the document\n    Connection conn = Jsoup.connect(url);\n    Document doc = conn.get();\n    // select the content text and pull out the paragraphs.\n    Element content = doc.getElementById(\"mw-content-text\");\n    Elements paragraphs = content.select(\"p\");\n\"Jsoup.connect\" takes a URL as a \"String\" and makes a connection o e web server; the \"get\" method downloads the HTML, parses it,"], ["returns document object, content return value elements, searches tree element, dom document, example returns", "and returns a \"Document\" object, which represents the DOM.\n\"Document\" provides methods for navigating e e and selecting nodes. In fact, it provides so many methods, it n e confusing. This example demonstrates two ways to select nodes:\n- \"getElementById\" takes a \"String\" and searches the tree for an\n  element that has a matching \"id\" field. Here it selects the node\n  \"<div id=\"mw-content-text\" lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">\",\n  which appears on every Wikipedia page to identify the\n  \"<div>\" element that contains the main\n  text of the page, as opposed to the navigation sidebar and other\n  elements.\n  The return value from \"getElementById\" is an \"Element\"\n  object that represents this \"<div>\" and\n  contains the elements in the \"<div>\" as\n  children, grandchildren, etc.\n- \"select\" takes a \"String\", traverses the tree, and returns all\n  the elements with tags that match the \"String\". In this example, it\n  returns all paragraph tags that appear in \"content\". The return\n  value is an \"Elements\" object."], ["uml class diagram line hollow w, http http p, know important classes, skim documentation, another example, uml diagrams, element textnode datanode comment elements collection element objects", "Before you go on, you should skim the documentation of these classes o u know what they can do. The most important classes are"], ["uml class diagram line hollow w, http http p, node dom tree l, know important classes, skim documentation, another example, uml diagrams, element textnode datanode comment elements collection element objects, element elements node", "\"Element\", \"Elements\", and \"Node\", which you can read\n\"Node\" represents a node in the DOM tree;  there are l s that extend \"Node\", including\n\"Element\", \"TextNode\", \"DataNode\", and \"Comment\".\n\"Elements\" is a \"Collection\" of \"Element\" objects."], ["value getelementbyid element object, uml class diagram line hollow w, etc select, http http p, node dom tree l, know important classes, every wikipedia page identify div element, nodes fact, uml diagrams, element textnode datanode comment elements collection element objects, div contains elements div children, element elements node", "about at"], ["uml class diagram line hollow w, http http p, know important classes, skim documentation, another example, uml diagrams, element textnode datanode comment elements collection element objects", "http://thinkdast.com/jsoupelt,\nhttp://thinkdast.com/jsoupelts, d p://thinkdast.com/jsoupnode."], ["uml class diagram line hollow w, http http p, know important classes, skim documentation, another example, uml diagrams, element textnode datanode comment elements collection element objects", "  In a UML class diagram, a line with a hollow w d indicates that one class extends another.  For example, s m indicates that \"Elements\" extends \"ArrayList\"."], ["uml class diagram line hollow w, http http p, know important classes, skim documentation, another example, uml diagrams, element textnode datanode comment elements collection element objects", "We'll get back to UML diagrams in Section~\\ref{uml-class-diagrams}."], ["nodes wikinodeiterable implements iterable node wikinodeiterable performs, provide class, selects e paragraph paragraphs creates, java computer, quote quote, h nodes order", "To make your life easier, I provide a class called"], ["nodes wikinodeiterable implements iterable node wikinodeiterable performs, page example print node, selects e paragraph paragraphs creates, provide class, java computer, quote quote, wikinodeiterable lets, h nodes order", "\"WikiNodeIterable\" that lets you iterate through the nodes in a\n\"WikiNodeIterable\", which implements\n\"Iterable<Node>\".\n\"WikiNodeIterable\" performs a \"depth-first search\", h s the nodes in the order they would appear on the page.\nIn this example, we print a \"Node\" only if it is a"], ["markup output, nodes wikinodeiterable implements iterable node wikinodeiterable performs, dom tree example shows, represent tags, provide class, selects e paragraph paragraphs creates, iterable node iter new wikinodeiterable firstpara node node iter node instanceof textnode node textnode ignore types node e element, java computer, quote quote, elements paragraphs p element firstpara, h nodes order", "DOM tree. Here's an example that shows how to use it:\n    Elements paragraphs = content.select(\"p\");\n    Element firstPara = paragraphs.get(0);\n    Iterable<Node> iter = new WikiNodeIterable(firstPara);\n    for (Node node: iter) {\n        if (node instanceof TextNode) {\n            System.out.print(node);\n        }\n    }\n\"TextNode\" and ignore other types of \"Node\", y e \"Element\" objects that represent tags. The result is e n text of the HTML paragraph without any markup. The output is:"], ["nodes wikinodeiterable implements iterable node wikinodeiterable performs, page example print node, selects e paragraph paragraphs creates, provide class, java computer, quote quote, wikinodeiterable lets, h nodes order", "This example picks up where the previous one leaves off. It selects e t paragraph in \"paragraphs\" and then creates a"], ["nodes wikinodeiterable implements iterable node wikinodeiterable performs, provide class, selects e paragraph paragraphs creates, java computer, quote quote, h nodes order", "\\begin{quote}\n\\end{quote}"], ["nodes wikinodeiterable implements iterable node wikinodeiterable performs, page example print node, selects e paragraph paragraphs creates, provide class, java computer, quote quote, wikinodeiterable lets, h nodes order", "Java is a general-purpose computer programming language that s t, class-based, object-oriented,{[}13{]} and y d ..."], ["root tree selects, several ways, stack data structure, common ways implement dfs, e children backtracks", "There are several ways you might reasonably traverse a tree, each h t applications. We'll start with \"depth-first search\", or DFS.\nDFS starts at the root of the tree and selects the first child. If e d has children, it selects the first child again. When it gets to a e with no children, it backtracks, moving up the tree to the t e, where it selects the next child if there is one; otherwise t s again. When it has explored the last child of the root, it's e.\nThere are two common ways to implement DFS, recursively and iteratively.\ntraversal. You can read about \"pre-order\", \"post-order\", and\n\"in-order\" traversals at http://thinkdast.com/treetrav.  r s application, the traversal order doesn't matter.\n(http://thinkdast.com/callstack) to p k of the child nodes and process them in the right order. As n e, we can use a stack data structure to keep track of e s ourselves; if we do that, we can avoid the recursion and e e tree iteratively."], ["example print contents textnode e g children example, call stack, every node tree g h root node, textnode contents node children, recursive implementation simple elegant private static void recursivedfs node node node instanceof textnode node node child recursivedfs child method, recursive calls", "The recursive implementation is simple and elegant:\nprivate static void recursiveDFS(Node node) {\n    if (node instanceof TextNode) {\n        System.out.print(node);\n    }\n    for (Node child: node.childNodes()) {\n        recursiveDFS(child);\n    }\n}\nThis method gets invoked on every \"Node\" in the tree, g h the root. If the \"Node\" it gets is a \"TextNode\", t s the contents. If the \"Node\" has any children, it invokes\nBy making recursive calls, \"recursiveDFS\" uses the call stack"], ["example print contents textnode e g children example, call stack, every node tree g h root node, textnode contents node children, recursive implementation simple elegant private static void recursivedfs node node node instanceof textnode node node child recursivedfs child method, recursive calls", "\"recursiveDFS\" on each one of them in order."], ["example print contents textnode e g children example, call stack, every node tree g h root node, textnode contents node children, recursive implementation simple elegant private static void recursivedfs node node node instanceof textnode node node child recursivedfs child method, recursive calls", "In this example, we print the contents of each \"TextNode\" e g the children, so this is an example of a \"pre-order\""], ["constant time operations, way avoid errors, impossible data structure, lifo stands last first e stack queue, e order", "Before I explain the iterative version of DFS, I'll n e stack data structure.  We'll start with the general concept of a k, which I'll call a \"stack\" with a lowercase \"s\". Then we'l k about two Java \"interfaces\" that define stack methods:\n\"Stack\" and \"Deque\".\nA stack is a data structure that is similar to a list: it is a n that maintains the order of the elements. The y e between a stack and a list is that the stack provides r s. In the usual convention, it provides:\n- \"push\": which adds an element to the top of the stack.\n- \"pop\": which removes and returns the top-most element from the stack.\n- \"peek\": which returns the top-most element without modifying\n  the stack.\n- \"isEmpty\": which indicates whether the stack is empty.\nBecause \"pop\" always returns the top-most element, a stack s o called a \"LIFO\", which stands for \"last in, first out\". An e to a stack is a \"queue\", which returns elements in e e order they are added; that is, \"first in, first out\", or FIFO.\nIt might not be obvious why stacks and queues are useful: they don't e any capabilities that aren't provided by lists; in fact, y e fewer capabilities. So why not use lists for everything? e e two reasons:\n- If you limit yourself to a small set of methods --- that is, a small\n  API --- your code will be more readable and less error-prone. For\n  example, if you use a list to represent a stack, you might\n  accidentally remove an element in the wrong order. With the stack API,\n  this kind of mistake is literally impossible. And the best way to\n  avoid errors is to make them impossible.\n- If a data structure provides a small API, it is easier to implement\n  efficiently. For example, a simple way to implement a stack is a\n  singly-linked list. When we push an element onto the stack, we add it\n  to the beginning of the list; when we pop an element, we remove it\n  from the beginning. For a linked list, adding and removing from the\n  beginning are constant time operations, so this implementation is\n  efficient. Conversely, big APIs are harder to implement efficiently.\nTo implement a stack in Java, you have three options:\n- Go ahead and use \"ArrayList\" or \"LinkedList\". If you use\n  \"ArrayList\", be sure to add and remove from the end,\n  which is a constant time operation. And be careful not to add elements\n  in the wrong place or remove them in the wrong order.\n- Java provides a class called \"Stack\" that provides the standard\n  set of stack methods. But this class is an old part of Java: it is not\n  consistent with the Java Collections Framework, which came later.\n- Probably the best choice is to use one of the implementations of the\n  \"Deque\" interface, like \"ArrayDeque\"."], ["deek java, deque interface, e deck people, push pop peek isempty use deque stack, term abstract data type", "% TODO: introduce the term \"Abstract Data Type\"?"], ["deek java, deque interface, e deck people, push pop peek isempty use deque stack, term abstract data type", "\"Deque\" stands for \"double-ended queue\"; it's supposed to e d \"deck\", but some people say \"deek\". In Java, the"], ["deek java, deque interface, e deck people, push pop peek isempty use deque stack, term abstract data type", "\"Deque\" interface provides \"push\", \"pop\",\n\"peek\", and \"isEmpty\", so you can use a \"Deque\" s a stack. It provides other methods, which you can read about t p://thinkdast.com/deque,"], ["lists fact, term abstract data type, e deck people, deek java, stack empty pop, deque interface, push pop peek isempty use deque stack, methods small api code readable, stack isempty, stack lowercase l", "but we won't use them for now."], ["private static void iterativedfs node root deque node, new linkedlist node assign, textnode e contents, empty time node stack, java iterator", "Here is an iterative version of DFS that uses an \"ArrayDeque\" o t a stack of \"Node\" objects:\n    private static void iterativeDFS(Node root) {\n        Deque<Node> stack = new ArrayDeque<Node>();\n        stack.push(root);\n        while (!stack.isEmpty()) {\n            Node node = stack.pop();\n            if (node instanceof TextNode) {\n                System.out.print(node);\n            }\n            List<Node> nodes = new ArrayList<Node>(node.childNodes());\n            Collections.reverse(nodes);\n            for (Node child: nodes) {\n                stack.push(child);\n            }\n        }\n    }\nThe loop continues until the stack is empty. Each time through, it s a \"Node\" off the stack. If it gets a \"TextNode\", it s e contents. Then it pushes the children onto the stack. In order o s the children in the right order, we have to push them onto e k in reverse order; we do that by copying the children into an\nOne advantage of the iterative version of DFS is that it is easier o t as a Java \"Iterator\"; you'll see how in the t r.\n\"List\" variable, like this:\nList<Node> deque = new LinkedList<Node>();\nAnd if you assign it like this:\nLinkedList<Node> deque = new LinkedList<Node>();"], ["e start, private static void iterativedfs node root deque node, new linkedlist node assign, textnode e contents, use methods, elements place g h, parameter root, empty time node stack, java iterator, use list methods deque methods, deque old friend linkedlist linkedlist", "The parameter, \"root\", is the root of the tree we want o e, so we start by creating the stack and pushing the root o t."], ["e start, use methods, elements place g h, parameter root, use list methods deque methods, deque old friend linkedlist linkedlist", "\"ArrayList\", reversing the elements in place, and then g h the reversed \"ArrayList\"."], ["use example n linkedlist, e start, use methods, elements place g h, deqeue node, parameter root, another implementation implements interfaces list deque h e, last note deque interface n n arraydeque java, use list methods deque methods, new linkedlist node use methods deque interface l list interface assign, deque old friend linkedlist linkedlist", "But first, one last note about the \"Deque\" interface: n n to \"ArrayDeque\", Java provides another implementation of\nimplements both interfaces, \"List\" and \"Deque\". h e you get depends on how you use it. For example, if you n a \"LinkedList\" object to a \"Deque\" variable, like this:\nDeqeue<Node> deque = new LinkedList<Node>();\nyou can use the methods in the \"Deque\" interface, but not l s in the \"List\" interface. If you assign it to a"], ["e start, use methods, elements place g h, parameter root, use list methods deque methods, deque old friend linkedlist linkedlist", "\"Deque\", our old friend \"LinkedList\". \"LinkedList\""], ["use example n linkedlist, e start, use methods, elements place g h, deqeue node, parameter root, another implementation implements interfaces list deque h e, last note deque interface n n arraydeque java, use list methods deque methods, new linkedlist node use methods deque interface l list interface assign, deque old friend linkedlist linkedlist", "you can use \"List\" methods but not all \"Deque\" methods."], ["e start, private static void iterativedfs node root deque node, new linkedlist node assign, textnode e contents, use methods, elements place g h, parameter root, empty time node stack, java iterator, use list methods deque methods, deque old friend linkedlist linkedlist", "you can use all the methods. But if you combine methods m t interfaces, your code will be less readable and e r-prone."], ["recursive iterative implementations, dom tree explain code next section, utility class, dfs dom tree, jsoup download pages wikipedia help comply terms service class limits, ant build file, repository book", "In the repository for this book,"], ["simple bit starter code, outline code write exercise walk run ant wikiphilosophy, recursive iterative implementations, utility class, download pages, dfs dom tree, code help, jsoup download pages wikipedia help comply terms service class limits, ant build file, next page, repository book", "you'll find some code to help you get started:\n- \"WikiNodeExample.java\" contains the code from the previous\n  chapter, demonstrating recursive and iterative implementations of\n  depth-first search (DFS) in a DOM tree.\n- \"WikiNodeIterable.java\" contains an \"Iterable\" class for\n  traversing a DOM tree. I'll explain this code in the next section.\n- \"WikiFetcher.java\" contains a utility class that uses jsoup to\n  download pages from Wikipedia. To help you comply with Wikipedia's\n  terms of service, this class limits how fast you can download pages;\n  if you request more than one page per second, it sleeps before\n  downloading the next page.\n- \"WikiPhilosophy.java\" contains an outline of the code you will\n  write for this exercise. We'll walk through it below.\n\"build.xml\".  If you run \"ant WikiPhilosophy\", it will n a simple bit of starter code."], ["recursive iterative implementations, utility class, dfs dom tree, previous chapter, jsoup download pages wikipedia help comply terms service class limits, ant build file, repository book", "You'll also find the Ant build file"], ["new arraydeque node root override, recursive version, root root tree, return node, new wikinodeiterator root inner class wikinodeiterator real work private class wikinodeiterator implements iterator node deque node, iterative search, hasnext return override public node next throw new nosuchelementexception node node list node, previous chapter, public wikinodeiterator node, visit method", "In the previous chapter, I presented an iterative depth-first search"], ["recursive version, empty iterator, root root tree, previous chapter, iterative search, isempty checks, exception iterable, methods constructor, easy n separate logic iteration dfs r g nodes, visit method", "(DFS), and suggested that an advantage of the iterative version,\nThis code is almost identical to the iterative version of DFS, but w t's split into three methods:\n- The constructor initializes the stack (which is implemented using an\n  \"ArrayDeque\") and pushes the root node onto it.\n- \"isEmpty\" checks whether the stack is empty.\n- \"next\" pops the next \"Node\" off the stack, pushes its\n  children in reverse order, and returns the \"Node\" it popped. If\n  someone invokes \"next\" on an empty \"Iterator\", it throws\n  an exception.\n\"Iterable\" is called for, which makes it easy and y n to separate the logic of the iteration (DFS) from r g we are doing on the nodes."], ["recursive version, worthwhile rewrite method, root root tree, methods e e use wikinodeiterable, iterative search, previous chapter, visit method", "compared to the recursive version, is that it is easier to wrap in an\nIt might not be obvious that it is worthwhile to rewrite a y d method with two classes and five methods.  But now that we'e e it, we can use \"WikiNodeIterable\" anywhere an"], ["recursive version, new wikinodeiterable root node node iter visit node implementation, returns iterator, root root tree, previous chapter, iterative search, node root iterable node, visit method, stores reference root node iterator method, iterator object section see familiar iterator iterable http iterable node interface e loop", "\"Iterator\" object. In this section we'll see how to do that.\nIf you are not familiar with the \"Iterator\" and \"Iterable\"\nhttp://thinkdast.com/iterable.\n\"Iterable<Node>\" interface  so we can e t in a for loop like this:\n    Node root = ...\n    Iterable<Node> iter = new WikiNodeIterable(root);\n    for (Node node: iter) {\n        visit(node);\n    }\nThe implementation of \"WikiNodeIterable\" follows a l a:\n- The constructor takes and stores a reference to the root\n  \"Node\".\n- The \"iterator\" method creates a returns an \"Iterator\"\n  object."], ["recursive version, node root iterable node, empty iterator, stores reference root node iterator method, new wikinodeiterable root node node iter visit node implementation, worthwhile rewrite method, returns iterator, root root tree, methods e e use wikinodeiterable, isempty checks, exception iterable, iterator object section see familiar iterator iterable http iterable node interface e loop, methods constructor, easy n separate logic iteration dfs r g nodes, visit method", "interfaces, you can read about them t p://thinkdast.com/r d"], ["new arraydeque node root override, recursive version, root root tree, return node, new wikinodeiterator root inner class wikinodeiterator real work private class wikinodeiterator implements iterator node deque node, iterative search, hasnext return override public node next throw new nosuchelementexception node node list node, previous chapter, public wikinodeiterator node, visit method", "Take a look at the contents of \"WikiNodeIterable.java\". The r s, \"WikiNodeIterable\" implements the\nHere's what it looks like:\npublic class WikiNodeIterable implements Iterable<Node> {\n    private Node root;\n    public WikiNodeIterable(Node root) {\n        this.root = root;\n    }\n    @Override\n    public Iterator<Node> iterator() {\n        return new WikiNodeIterator(root);\n    }\n}\nThe inner class, \"WikiNodeIterator\", does all the real work:\n    private class WikiNodeIterator implements Iterator<Node> {\n        Deque<Node> stack;\n        public WikiNodeIterator(Node node) {\n            stack = new ArrayDeque<Node>();\n            stack.push(root);\n        }\n        @Override\n        public boolean hasNext() {\n            return !stack.isEmpty();\n        }\n        @Override\n        public Node next() {\n            if (stack.isEmpty()) {\n                throw new NoSuchElementException();\n            }\n            Node node = stack.pop();\n            List<Node> nodes = new ArrayList<Node>(node.childNodes());\n            Collections.reverse(nodes);\n            for (Node child: nodes) {\n                stack.push(child);\n            }\n            return node;\n        }\n    }"], ["recursive version, stores reference root node iterator method, new wikinodeiterable root node node iter visit node implementation, returns iterator, root root tree, methods e e use wikinodeiterable, iterative search, node root iterable node, iterator object section see familiar iterator iterable http iterable node interface e loop, previous chapter, visit method", "where \"root\" is the root of the tree we want to traverse and"], ["recursive version, new wikinodeiterable root node node iter visit node implementation, returns iterator, root root tree, previous chapter, iterative search, node root iterable node, visit method, stores reference root node iterator method, iterator object section see familiar iterator iterable http iterable node interface e loop", "\"visit\" is a method that does whatever we want when we \"visit\""], ["recursive version, node root iterable node, empty iterator, stores reference root node iterator method, new wikinodeiterable root node node iter visit node implementation, worthwhile rewrite method, returns iterator, root root tree, methods e e use wikinodeiterable, isempty checks, exception iterable, iterator object section see familiar iterator iterable http iterable node interface e loop, methods constructor, easy n separate logic iteration dfs r g nodes, visit method", "a \"Node\"."], ["reasonable interval, enough time requests, provide class, g help, multiple instances u avoid problem", "When you write a Web crawler, it is easy to download too many pages o t, which might violate the terms of service for the server you e g from. To help you avoid that, I provide a class called\n\"WikiFetcher\" that does two things:\n- It encapsulates the code we demonstrated in the previous chapter for\n  downloading pages from Wikipedia, parsing the HTML, and selecting the\n  content text.\n- It measures the time between requests and, if we don't leave enough\n  time between requests, it sleeps until a reasonable interval has\n  elapsed. By default, the interval is one second.\n\"WikiFetcher\" object and use it to handle all requests. If u e multiple instances of \"WikiFetcher\", they won't enforce e m interval between requests.\nNOTE: My implementation of \"WikiFetcher\" is simple, but it d e easy for someone to misuse it by creating multiple instances. u d avoid this problem by making \"WikiFetcher\" a \"singleton\","], ["url processparagraphs paragraphs, something important create, url throws ioexception, definition wikifetcher public class wikifetcher private long lastrequesttime private long mininterval, elements collection", "Here's the definition of \"WikiFetcher\":\npublic class WikiFetcher {\n    private long lastRequestTime = -1;\n    private long minInterval = 1000;\n    /**\n     * Fetches and parses a URL string,\n     * returning a list of paragraph elements.\n     *\n     * @param url\n     * @return\n     * @throws IOException\n     */\n    public Elements fetchWikipedia(String url) throws IOException {\n        sleepIfNeeded();\n        Connection conn = Jsoup.connect(url);\n        Document doc = conn.get();\n        Element content = doc.getElementById(\"mw-content-text\");\n        Elements paragraphs = content.select(\"p\");\n        return paragraphs;\n    }\n    private void sleepIfNeeded() {\n        if (lastRequestTime != -1) {\n            long currentTime = System.currentTimeMillis();\n            long nextRequestTime = lastRequestTime + minInterval;\n            if (currentTime < nextRequestTime) {\n                try {\n                    Thread.sleep(nextRequestTime - currentTime);\n                } catch (InterruptedException e) {\n                    System.err.println(\n                        \"Warning: sleep interrupted in fetchWikipedia.\");\n                }\n            }\n        }\n        lastRequestTime = System.currentTimeMillis();\n    }\n}\nThe only public method is \"fetchWikipedia\", which takes a URL s a \"String\" and returns an \"Elements\" collection that contains one\nThat's all there is to \"WikiFetcher\". Here's an example t s how it's used:\n    WikiFetcher wf = new WikiFetcher();\n    for (String url: urlList) {\n        Elements paragraphs = wf.fetchWikipedia(url);\n        processParagraphs(paragraphs);\n    }"], ["read p, mininterval milliseconds, something important create, dom element paragraph content text code k, urllist collection, processparagraphs method g h elements", "DOM element for each paragraph in the content text. This code d k familiar."], ["last request sleeps, read p, checks time, mininterval milliseconds, dom element paragraph content text code k, urllist collection, processparagraphs method g h elements, new code", "The new code is in \"sleepIfNeeded\", which checks the time e e last request and sleeps if the elapsed time is less than"], ["terms service, e interval requests note implementation wikifetcher simple e easy someone misuse, read p, mininterval milliseconds, pages wikipedia, dom element paragraph content text code k, urllist collection, processparagraphs method g h elements", "\"minInterval\", which is in milliseconds."], ["read p, something important create, mininterval milliseconds, dom element paragraph content text code k, urllist collection, processparagraphs method g h elements", "In this example, we assume that \"urlList\" is a collection of"], ["read p, something important create, mininterval milliseconds, dom element paragraph content text code k, urllist collection, processparagraphs method g h elements", "\"String\"s, and \"processParagraphs\" is a method that does g h the \"Elements\" object returned by \"fetchWikipedia\"."], ["url processparagraphs paragraphs, read p, something important create, mininterval milliseconds, url throws ioexception, dom element paragraph content text code k, definition wikifetcher public class wikifetcher private long lastrequesttime private long mininterval, urllist collection, elements collection, processparagraphs method g h elements", "This example demonstrates something important: you should create one"], ["terms service, e interval requests note implementation wikifetcher simple e easy someone misuse, read p, mininterval milliseconds, pages wikipedia, dom element paragraph content text code k, urllist collection, processparagraphs method g h elements", "which you can read about t p://thinkdast.com/singleton."], ["data structures top l, intersection intersection, index maps h term collection pages, search terms, f appear, e next question represent collection pages, perform r decision, fundamental operation index lookup addition termcounter, construct termcounter hashset treeset", "The fundamental operation of the index is a **lookup**;\nIn addition to the \"TermCounter\", which maps from search terms o s, we will define a class called \"Index\", which maps from a h term to a collection of pages where it appears. And that s e next question, which is how to represent a collection of pages."], ["alternative map data structure collection pairs, data structures top l, intersection intersection, search term, f appear, counts frequencies case, keys search terms, perform r decision, select ones, construct termcounter hashset treeset", "specifically, we need the ability to look up a term and find all s t contain it. The simplest implementation would be a collection f s. Given a search term, we could iterate through the contents of e s and select the ones that contain the search term. But the e d be proportional to the total number of words on all the pages,\nA better alternative is a **map**, which is a data structure t s a collection of **key-value pairs** and provides a t y to look up a **key** and find the corresponding **value**.\nwhich maps from each search term to the number of times it appears in a e. The keys are the search terms and the values are the counts (o d \"frequencies\").\nIn this case, we'll need to combine two or more collections and find e s that appear in all of them. You might recognize this operation as"], ["alternative map data structure collection pairs, data structures top l, intersection intersection, search term, f appear, counts frequencies case, keys search terms, perform r decision, select ones, construct termcounter hashset treeset", "which would be way too slow."], ["data structures top l, intersection intersection, f appear, element method checks, element method, perform r decision, set methods, element set, construct termcounter hashset treeset", "For example, the first map we'll construct is a \"TermCounter\",\n\"HashSet\" and \"TreeSet\".\nNow that we've designed our data structures from the top down, we'l t them from the inside out, starting with \"TermCounter\"."], ["e intersection, data structures top l, map specifies, key java, intersection intersection, new pair map key, f appear, replaces value, perform r decision, construct termcounter hashset treeset", "Java provides an interface called \"Map\" that specifies e s a map should provide; the most important are:\n- \"get(key)\": This method looks up a key and returns the\n  corresponding value.\n- \"put(key, value)\": This method adds a new key-value pair to the\n  \"Map\", or if the key is already in the map, it replaces the\n  value associated with \"key\".\nJava provides several implementations of \"Map\", including the o e will focus on, \"HashMap\" and \"TreeMap\". In g s, we'll look at these implementations and analyze their performance.\nAs you might expect by now, Java provides a \"Set\" interface t s the operations a set should perform. It doesn't actually e t intersection, but it provides methods that make it possible o t intersection and other set operations efficiently. The core\nJava provides several implementations of \"Set\", including"], ["data structures top l, intersection intersection, f appear, perform r decision, construct termcounter hashset treeset", "Again, if we think about the operations we want to perform, that s r decision."], ["alternative map data structure collection pairs, data structures top l, intersection intersection, search term, f appear, counts frequencies case, keys search terms, perform r decision, select ones, construct termcounter hashset treeset", "**set intersection**: the intersection of two sets is the set f s that appear in both."], ["data structures top l, intersection intersection, f appear, element method checks, element method, perform r decision, set methods, element set, construct termcounter hashset treeset", "\"Set\" methods are:\n- \"add(element)\": This method adds an element to a set; if the\n  element is already in the set, it has no effect.\n- \"contains(element)\": This method checks whether the given\n  element is in the set."], ["punctuation characters, e p, e p checks, string term integer count term return count, termcounter class", "\"TermCounter\" is a class that represents a mapping from h s to the number of times they appear in a page. Here is the t t of the class definition:\npublic class TermCounter {\n    private Map<String, Integer> map;\n    private String label;\n    public TermCounter(String label) {\n        this.label = label;\n        this.map = new HashMap<String, Integer>();\n    }\n}\nThe instance variables are \"map\", which contains the mapping m s to counts, and \"label\", which identifies the document e s came from; we'll use it to store URLs.\n\"TermCounter\" provides \"put\" and \"get\", which e d like this:\n    public void put(String term, int count) {\n        map.put(term, count);\n    }\n    public Integer get(String term) {\n        Integer count = map.get(term);\n        return count == null ? 0 : count;\n    }\n\"put\" on a \"TermCounter\", it calls \"put\" on e d map.\n\"get\" on a \"TermCounter\", it calls \"get\" on e p, and then checks the result. If the term does not appear in e p, \"TermCount.get\" returns 0. Defining \"get\" this y s it easier to write \"incrementTermCount\", which takes a m d increases by one the counter associated with that term.\n    public void incrementTermCount(String term) {\n        put(term, get(term) + 1);\n    }\nIn addition, \"TermCounter\" provides these other methods to p h indexing Web pages:\n    public void processElements(Elements paragraphs) {\n        for (Node node: paragraphs) {\n            processTree(node);\n        }\n    }\n    public void processTree(Node root) {\n        for (Node node: new WikiNodeIterable(root)) {\n            if (node instanceof TextNode) {\n                processText(((TextNode) node).text());\n            }\n        }\n    }\n    public void processText(String text) {\n        String[] array = text.replaceAll(\"\\\\pP\", \" \").\n                              toLowerCase().\n                              split(\"\\\\s+\");\n        for (int i=0; i<array.length; i++) {\n            String term = array[i];\n            incrementTermCount(term);\n        }\n    }\n- \"processElements\" takes an \"Elements\" object, which is a\n  collection of jsoup \"Element\" objects. It iterates through the\n  collection and calls \"processTree\" on each.\n- \"processTree\" takes a jsoup \"Node\" that represents the\n  root of a DOM tree. It iterates through the tree to find the nodes\n  that contain text; then it extracts the text and passes it to\n  \"processText\".\n- \"processText\" takes a \"String\" that contains words, spaces,\n  punctuation, etc. It removes punctuation characters by replacing\n  them with spaces, converts the remaining letters to lowercase, then\n  splits the text into words. Then it loops through the words it found\n  and calls \"incrementTermCount\" on each.  The \"replaceAll\"\n  and \"split\" methods take **regular expressions** as parameters;\n  you can read more about them at http://thinkdast.com/regex.\nFinally, here's an example that demonstrates how \"TermCounter\" s d:\n    String url = \"http://en.wikipedia.org/wiki/Java_(programming_language)\";\n    WikiFetcher wf = new WikiFetcher();\n    Elements paragraphs = wf.fetchWikipedia(url);\n    TermCounter counter = new TermCounter(url);\n    counter.processElements(paragraphs);\n    counter.printCounts();\n\"TermCounter\" and uses it to count the words in the page."], ["w works common choice use, new pair map e, next section chance run code test r g, old count, new count replaces old value, method call, wikifetcher download page parse main text creates, chose hashmap map coming chapters", "To implement the mapping, I chose \"HashMap\", which is the t y-used \"Map\". Coming up in a few chapters, you will see w t works and why it is a common choice.\nthen use \"put\" to add a new key-value pair to the map. If e m is already in the map, we get the old count, add 1, and then e e new count, which replaces the old value."], ["new pair map e, next section chance run code test r g, old count, new count replaces old value, method call, wikifetcher download page parse main text creates, chose hashmap map coming chapters", "\"put\" is just a **wrapper method**; when you call"], ["next section chance run code test r g, old count, new termcounter url paragraphs termcounter, new count replaces old value, write incrementtermcount, incrementtermcount replaceall split methods, counts label identifies, count words page, method call, wikifetcher download page parse main text creates, chose hashmap map coming chapters", "On the other hand, \"get\" actually does some work. When you call"], ["next section chance run code test r g, old count, new termcounter url paragraphs termcounter, new count replaces old value, write incrementtermcount, incrementtermcount replaceall split methods, counts label identifies, count words page, method call, wikifetcher download page parse main text creates, chose hashmap map coming chapters", "If the term has not been seen before, \"get\" returns 0; we add 1,"], ["new pair map e, next section chance run code test r g, old count, new count replaces old value, method call, wikifetcher download page parse main text creates, chose hashmap map coming chapters", "This example uses a \"WikiFetcher\" to download a page m a and parse the main text. Then it creates a"], ["new pair map e, next section chance run code test r g, old count, new count replaces old value, method call, wikifetcher download page parse main text creates, chose hashmap map coming chapters", "In the next section, you'll have a chance to run this code and test r g by filling in a missing method."], ["value override public k getkey, single instance variable much entry container value definition, inside mylinearlist, e methods map interface mylinearmap, key override public v getvalue return value, need exercise, pair e n public class entry implements k v private k key private v value public entry k key v value, mylinearmap n public class mylinearmap k v implements map k v private list entry, usual provide starter code fill g, type parameters k v, new arraylist entry mylinearmap implements map", "As usual, I provide starter code and you will fill in the g s. Here's the beginning of the \"MyLinearMap\" s n:\npublic class MyLinearMap<K, V> implements Map<K, V> {\n    private List<Entry> entries = new ArrayList<Entry>();\n\"MyLinearMap\" implements \"Map\", which means it has o e the methods in the \"Map\" interface.\nA \"MyLinearMap\" object has a single instance variable,\nThere's not much to it; an \"Entry\" is just a container for a y d a value. This definition is nested inside \"MyLinearList\", o t uses the same type parameters, \"K\" and \"V\"."], ["value override public k getkey, key override public v getvalue return value, need exercise, mylinearmap n public class mylinearmap k v implements map k v private list entry, type parameters k type f e keys v type values, pair e n public class entry implements k v private k key private v value public entry k key v value", "This class uses two type parameters, \"K\", which is the type f e keys, and \"V\", which is the type of the values.\nobjects. Each \"Entry\" contains a key-value pair. Here is e n:\n    public class Entry implements Map.Entry<K, V> {\n        private K key;\n        private V value;\n        public Entry(K key, V value) {\n            this.key = key;\n            this.value = value;\n        }\n        @Override\n        public K getKey() {\n            return key;\n        }\n        @Override\n        public V getValue() {\n            return value;\n        }\n    }"], ["value override public k getkey, key override public v getvalue return value, need exercise, mylinearmap n public class mylinearmap k v implements map k v private list entry, usual provide starter code fill g, type parameters k v, type parameters k type f e keys v type values, pair e n public class entry implements k v private k key private v value public entry k key v value", "\"entries\", which is an \"ArrayList\" of \"Entry\""], ["value override public k getkey, key override public v getvalue return value, need exercise, mylinearmap n public class mylinearmap k v implements map k v private list entry, usual provide starter code fill g, type parameters k type f e keys v type values, pair e n public class entry implements k v private k key private v value public entry k key v value", "That's all you need to do the exercise, so let's get started."], ["time first hear, entry call, possible next chapter present solution analyze e f core map methods, linear operations, core methods mylinearmap use findentry, runtime equals, trick increase number, h time, remember entries arraylist g n element end constant time average key map, n map core methods, n e number entries equals constant time, section present solution previous exercise e performance core methods summary core methods, linear reasoning get, number entries", "In this section I present a solution to the previous exercise d e the performance of the core methods.  Here are\nIn summary, the core methods are all linear, which is why we called s n \"MyLinearMap\" (ta-da!).\nIf we know that the number of entries will be small, this n t be good enough, but we can do better. In fact, there is n n of \"Map\" where all of the core methods e t time. When you first hear that, it might not seem possible.\nIn the next chapter, I'll present a solution, analyze the e f the core \"Map\" methods, and introduce a more t n."], ["findentry equals private entry findentry object target entry entry entries, core methods mylinearmap use findentry, object key entry entry findentry key entry null return null, public v, runtime equals, h time, remove look, n e number entries equals constant time, linear reasoning get, null private boolean equals object target object", "\"findEntry\" and \"equals\":\nprivate Entry findEntry(Object target) {\n    for (Entry entry: entries) {\n        if (equals(target, entry.getKey())) {\n            return entry;\n        }\n    }\n    return null;\n}\nprivate boolean equals(Object target, Object obj) {\n    if (target == null) {\n        return obj == null;\n    }\n    return target.equals(obj);\n}\nincluding \"put\", \"get\", and \"remove\". Here's t y look like:\npublic V put(K key, V value) {\n    Entry entry = findEntry(key);\n    if (entry == null) {\n        entries.add(new Entry(key, value));\n        return null;\n    } else {\n        V oldValue = entry.getValue();\n        entry.setValue(value);\n        return oldValue;\n    }\n}\npublic V get(Object key) {\n    Entry entry = findEntry(key);\n    if (entry == null) {\n        return null;\n    }\n    return entry.getValue();\n}\npublic V remove(Object key) {\n    Entry entry = findEntry(key);\n    if (entry == null) {\n        return null;\n    } else {\n        V value = entry.getValue();\n        entries.remove(entry);\n        return value;\n    }\n}"], ["entry call, linear operations, core methods mylinearmap use findentry, runtime equals, trick increase number, h time, remember entries arraylist g n element end constant time average key map, n e number entries equals constant time, linear reasoning get, number entries", "The runtime of \"equals\" might depend on the size of the\n\"target\" and the keys, but does not generally depend n e number of entries, n. So \"equals\" is constant time."], ["core methods mylinearmap use findentry, runtime equals, big haystack c, h time, needle k constant time, proportional n, key g r, n e number entries equals constant time, general r f entries, linear reasoning get", "In \"findEntry\", we might get lucky and find the key we're g r at the beginning, but we can't count on it. In general, the r f entries we have to search is proportional to n, so\n\"findEntry\" is linear.\nWhat we are saying, in effect, is that you can find a needle in a k in constant time, regardless of how big the haystack is. It's c."], ["entry call, linear operations, core methods mylinearmap use findentry, runtime equals, trick increase number, h time, remember entries arraylist g n element end constant time average key map, n e number entries equals constant time, linear reasoning get, number entries", "Most of the core methods in \"MyLinearMap\" use \"findEntry\","], ["entry call, linear operations, trick increase number, remember entries arraylist g n element end constant time average key map, number entries", "After \"put\" calls \"findEntry\", everything else is t e. Remember that \"entries\" is an \"ArrayList\", so g n element at the end is constant time, on average. If the key s y in the map, we don't have to add an entry, but we have to call\n\"entries.remove\" might have to remove an element from e g or middle of the \"ArrayList\", and that takes r e. But that's OK: two linear operations are still linear.\nI'll explain how it works in two steps:\n- Instead of storing entries in one big \"List\", we'll break them\n  up into lots of short lists. For each key, we'll use a \\textbf{hash\n  code} (explained in the next section) to determine which list to use.\n- Using lots of short lists is faster than using just one, but as I'll\n  explain, it doesn't change the order of growth; the core operations\n  are still linear. But there is one more trick: if we increase the\n  number of lists to limit the number of entries per list, the result is\n  a constant-time map. You'll see the details in the next exercise, but\n  first: hashing!"], ["core methods mylinearmap use findentry, size target keys, runtime equals, h time, n e number entries equals constant time, linear reasoning get", "\"entry.getValue\" and \"entry.setValue\", and those are h t time. Putting it all together, \"put\" is linear.\nBy the same reasoning, \"get\" is also linear."], ["time first hear, possible next chapter present solution analyze e f core map methods, core methods mylinearmap use findentry, runtime equals, size target keys, h time, n map core methods, n e number entries equals constant time, section present solution previous exercise e performance core methods summary core methods, linear reasoning get, number entries", "\"remove\" is slightly more complicated because"], ["parameter mybettermap k times, maps new arraylist mylinearmap k v k int, search k runtime, list mylinearmap k v, proportional n mybettermap", "To improve the performance of \"MyLinearMap\", we'll write a w s, called \"MyBetterMap\", that contains a collection of\n\"MyLinearMap\" objects. It divides the keys among the d s, so the number of entries in each map is smaller, which speeds up\nHere's the beginning of the class definition:\npublic class MyBetterMap<K, V> implements Map<K, V> {\n    protected List<MyLinearMap<K, V>> maps;\n    public MyBetterMap(int k) {\n        makeMaps(k);\n    }\n    protected void makeMaps(int k) {\n        maps = new ArrayList<MyLinearMap<K, V>>(k);\n        for (int i=0; i<k; i++) {\n            maps.add(new MyLinearMap<K, V>());\n        }\n    }\n}\n\"MyLinearMap\" objects. The constructor takes a parameter,\n\"MyBetterMap\" are k times shorter than the entry list in\n\"MyLinearMap\", we expect the search to be k s r. But the runtime is still proportional to n, so\n\"MyBetterMap\" is still linear. In the next exercise, you'll see how e n fix that."], ["object object returns integer, reference map chose use choosemap, embedded maps, public v, findentry methods, use remainder operator guarantees, index valid index maps, makemaps creates, entry lists, k entries, instance variable maps collection arraylist java every object", "\"findEntry\" and the methods that depend on it."], ["object object returns integer, public v, findentry methods, makemaps creates, entry lists, instance variable maps collection arraylist java every object", "The instance variable, \"maps\", is a collection of\n\"ArrayList\".\nIn Java, every \"Object\" provides a method called"], ["reference map chose use choosemap, embedded maps, use remainder operator guarantees, index valid index maps, k entries", "\"k\", that determines how many maps to use, at least initially.\nNow, the key to making this work is that we need some way to look at a y and decide which of the embedded maps it should go into. When we\n\"put\" a new key, we choose one of the maps; when we \"get\"\nOne possibility is to choose one of the sub-maps at random and p k of where we put each key. But how should we keep track? It t m like we could use a \"Map\" to look up the key and find e t sub-map, but the whole point of the exercise is to write n t implementation of a \"Map\". We can't assume we y e one.\nthen use the remainder operator, \"\\%\", which guarantees that e t is between 0 and \"maps.size()-1\". So \"index\" s s a valid index into \"maps\". Then \"chooseMap\" s a reference to the map it chose.\nWe use \"chooseMap\" in both \"put\" and \"get\", so n e look up a key, we get the same map we chose when we added the key. At t, we should --- I'll explain a little later why this might t k.\nIf there are n entries split up among k sub-maps,\nthere will be n/k entries per map, on average. When we look p a key, we have to compute its hash code, which takes some time, then e h the corresponding sub-map."], ["parameter mybettermap k times, object object returns integer, public v, findentry methods, makemaps creates, maps new arraylist mylinearmap k v k int, search k runtime, entry lists, list mylinearmap k v, proportional n mybettermap, instance variable maps collection arraylist java every object", "Then \"makeMaps\" creates the embedded maps and stores them in an\nPretty simple, right? In both methods, we use \"chooseMap\" to d e right sub-map and then invoke a method on the sub-map."], ["parameter mybettermap k times, reference map chose use choosemap, e hash code store, embedded maps, k entries, hash function implementation, otherwise use hashcode get integer, approach use hash function, use remainder operator guarantees, maps new arraylist mylinearmap k v k int, index valid index maps, search k runtime, hash code importantly, list mylinearmap k v, proportional n mybettermap", "the same key, we have to remember where we put it."], ["object object returns integer, e hash code store, otherwise use hashcode get integer, hash function implementation, public v, approach use hash function, findentry methods, makemaps creates, hash code importantly, entry lists, instance variable maps collection arraylist java every object", "A better approach is to use a **hash function**, which takes an\n**hash code**.  Importantly, if it sees the same \"Object\"\nmore than once, it always returns the same hash code. That way, if e e the hash code to store a key, we'll get the same hash code when e k it up.\n\"hashCode\" that computes a hash function. The implementation f s method is different for different objects; we'll see an e n.\narbitrarily. Otherwise we use \"hashCode\" to get an integer,"], ["object object returns integer, public v, findentry methods, makemaps creates, entry lists, instance variable maps collection arraylist java every object", "\"Object\", any \"Object\", and returns an integer called a"], ["object object returns integer, helper method chooses, k key v value mylinearmap k v map choosemap key return key value public v get object key mylinearmap k v map choosemap key return key, mylinearmap k v choosemap object key int index, public v, key null index, findentry methods, makemaps creates, entry lists, instance variable maps collection arraylist java every object", "Here's a helper method that chooses the right sub-map for a n key:\nprotected MyLinearMap<K, V> chooseMap(Object key) {\n    int index = 0;\n    if (key != null) {\n        index = Math.abs(key.hashCode()) % maps.size();\n    }\n    return maps.get(index);\n}\nIf \"key\" is \"null\", we choose the sub-map with index 0,\nHere's my implementation of \"put\" and \"get\":\npublic V put(K key, V value) {\n  MyLinearMap<K, V> map = chooseMap(key);\n    return map.put(key, value);\n}\npublic V get(Object key) {\n    MyLinearMap<K, V> map = chooseMap(key);\n    return map.get(key);\n}"], ["parameter mybettermap k times, reference map chose use choosemap, e hash code store, embedded maps, k entries, hash function implementation, otherwise use hashcode get integer, approach use hash function, use remainder operator guarantees, maps new arraylist mylinearmap k v k int, index valid index maps, search k runtime, hash code importantly, list mylinearmap k v, proportional n mybettermap", "apply \"Math.abs\" to make sure it is non-negative,"], ["parameter mybettermap k times, reference map chose use choosemap, e hash code store, embedded maps, k entries, hash function implementation, otherwise use hashcode get integer, approach use hash function, use remainder operator guarantees, maps new arraylist mylinearmap k v k int, index valid index maps, search k runtime, hash code importantly, list mylinearmap k v, proportional n mybettermap", "That's how it works; now let's think about performance."], ["object object returns integer, public v, findentry methods, makemaps creates, entry lists, instance variable maps collection arraylist java every object", "Because the entry lists in"], ["code end e entries others, g good hash functions, int total return total hashcode important order work, n k maps, objects hash code hashcode", "The fundamental requirement for a hash function is that the same t d produce the same hash code every time. For immutable objects,\n\"SillyString\", but I'll use it to show how a class can e s own hash function:\n    @Override\n    public boolean equals(Object other) {\n        return this.toString().equals(other.toString());\n    }\n    @Override\n    public int hashCode() {\n        int total = 0;\n        for (int i=0; i<innerString.length(); i++) {\n            total += innerString.charAt(i);\n        }\n        return total;\n    }\n\"hashCode\". This is important. In order to work properly,\n\"equals\" has to be consistent with \"hashCode\", which s t if two objects are considered equal --- that is, \"equals\"\nreturns \"true\" --- they should have the same hash code. But s t only works one way; if two objects have the same hash code,\n\"hashCode\" works by iterating through the characters in the\nThis hash function satisfies the requirement: if two\nthey will get the same hash code.\nbecause it returns the same hash code for many different strings. If o s contain the same letters in any order, they will have the e h code. And even if they don't contain the same letters, they t d the same total, like \"\"ac\"\" and \"\"bb\"\".\nIf many objects have the same hash code, they end up in the e b-map.  If some sub-maps have more entries than others, the p n we have k maps might be much less than k. So one of the s f a hash function is to be uniform; that is, it should be y y to produce any value in the range.  You can read more t g good hash functions t p://thinkdast.com/hash."], ["good performance, easy objects mutable state k example immutable object define class, curious read, anything unicode, unicode code point, class useful", "that's relatively easy. For objects with mutable state, we have to k r.\nAs an example of an immutable object, I'll define a class called"], ["public string, good performance, easy objects mutable state k example immutable object define class, objects equal f r, curious read, notice sillystring, anything unicode, unicode code point, public class, class useful, instance variables equal sillystring objects", "\"SillyString\" that encapsulates a \"String\":\npublic class SillyString {\n    private final String innerString;\n    public SillyString(String innerString) {\n        this.innerString = innerString;\n    }\n    public String toString() {\n        return innerString;\n    }\nNotice that \"SillyString\" overrides both \"equals\" and\n\"innerString\". So two \"SillyString\" objects are equal f r \"innerString\" instance variables are equal.\n\"SillyString\" objects contain embedded strings that are equal,"], ["good performance, easy objects mutable state k example immutable object define class, curious read, anything unicode, unicode code point, class useful", "This class is not very useful, which is why it's called"], ["add character int java, good performance, easy objects mutable state k example immutable object define class, curious read, anything unicode, unicode code point, class useful, character integer", "they don't necessarily have to be equal."], ["add character int java, good performance, easy objects mutable state k example immutable object define class, curious read, anything unicode, unicode code point, class useful, character integer", "\"equals\" works by invoking \"toString\", which returns"], ["add character int java, good performance, easy objects mutable state k example immutable object define class, curious read, anything unicode, unicode code point, class useful, character integer", "\"String\" and adding them up. When you add a character to an \"int\",\nJava converts the character to an integer using its Unicode code point."], ["good performance, easy objects mutable state k example immutable object define class, curious read, anything unicode, unicode code point, class useful", "You don't need to know anything about Unicode to understand s e, but if you are curious, you can read more at"], ["add character int java, good performance, easy objects mutable state k example immutable object define class, curious read, anything unicode, unicode code point, class useful, character integer", "http://thinkdast.com/codepoint."], ["good performance, easy objects mutable state k example immutable object define class, curious read, anything unicode, unicode code point, class useful", "This works correctly, but it might not yield good performance,"], ["override public int hashcode int, c hash code mutation, int total array total return total sillyarray, return array override public boolean equals, public class sillyarray private final char array public sillyarray char array", "\"String\"s are immutable, and \"SillyString\" is also e e \"innerString\" is declared to be \"final\". Once u e a \"SillyString\", you can't make \"innerString\" r o a different \"String\", and you can't modify the \"String\" t s to. Therefore, it will always have the same hash code.\nBut let's see what happens with a mutable object. Here's a n r \"SillyArray\", which is identical to \"SillyString\",\nexcept that it uses an array of characters instead of a \"String\":\npublic class SillyArray {\n    private final char[] array;\n    public SillyArray(char[] array) {\n        this.array = array;\n    }\n    public String toString() {\n        return Arrays.toString(array);\n    }\n    @Override\n    public boolean equals(Object other) {\n        return this.toString().equals(other.toString());\n    }\n    @Override\n    public int hashCode() {\n        int total = 0;\n        for (int i=0; i<array.length; i++) {\n            total += array[i];\n        }\n        System.out.println(total);\n        return total;\n    }\n\"SillyArray\" also provides \"setChar\", which makes t e to modify the characters in the array:\npublic void setChar(int i, char c) {\n    this.array[i] = c;\n}\nthe hash code after the mutation is 441. With a different hash code,\nIn general, it is dangerous to use mutable objects as keys in a s that use hashing, which includes \"MyBetterMap\" and"], ["map changes, good idea avoid, good chance, e array, map sillyarray, new sillyarray word1, modify contents, wrong e, h e, c integer value array1, suppose create sillyarray", "Now suppose we create a \"SillyArray\" and add it to a map:\nSillyArray array1 = new SillyArray(\"Word1\".toCharArray());\nmap.put(array1, 1);\nThe hash code for this array is 461. Now if we modify the contents f e array and then try to look it up, like this:\narray1.setChar(0, 'C');\nInteger value = map.get(array1);"], ["map changes, good idea avoid, good chance, e array, map hashmap guarantee keys, wrong e, h e", "there's a good chance we'll go looking in the wrong sub-map. In t e, we won't find the key, even though it is in the map. And that's d.\n\"HashMap\". If you can guarantee that the keys won't be d e they are in the map, or that any changes won't affect the h e, it might be OK. But it is probably a good idea to avoid it."], ["unit work next time h, keys basic unit work count number f hash key, new key, e e, tower result uniform height, amortized analysis, much work, proportional k, important double number f k rehash, proportion n several core suppose initial number k, number entries", "If the number of entries in the biggest sub-map is proportional o n/k, and k grows in proportion to n, several of the core\nSuppose the initial number of sub-maps, k, is 2, and the d r is 1. Now let's see how much work it takes to \"put\" a s of keys. As the basic \"unit of work\", we'll count the number f s we have to hash a key and add it to a sub-map.\nThis diagram also shows why it is important to double the number f b-maps, k, when we rehash. If we only add to k d of multiplying, the towers would be too close together d y would start piling up. And that would not be t e."], ["unit work next time h, mybettermap methods, next time call, new key, e e, constant time public boolean containskey object target mylinearmap k v map choosemap target, tower result uniform height, unit hash new key size hash table, amortized analysis, important double number f k rehash, object key mylinearmap k v map choosemap key return key method hashes key constant time invokes constant time", "\"MyBetterMap\" methods become constant time:\n    public boolean containsKey(Object target) {\n        MyLinearMap<K, V> map = chooseMap(target);\n        return map.containsKey(target);\n    }\n    public V get(Object key) {\n        MyLinearMap<K, V> map = chooseMap(key);\n        return map.get(key);\n    }\n    public V remove(Object key) {\n        MyLinearMap<K, V> map = chooseMap(key);\n        return map.remove(key);\n    }\nEach method hashes a key, which is constant time, and then invokes a d on a sub-map, which is constant time."], ["unit work next time h, unit work e, e time average series invocations first time call, e e, r analyze rehash constant time linear way similar reason, new key, tower result uniform height, amortized analysis, important double number f k rehash, constant time average, good core method", "So far, so good. But the other core method, \"put\", is a e r to analyze. When we don't have to rehash, it is constant time,\nbut when we do, it's linear. In that way, it's similar to\nFor the same reason, \"MyHashMap.put\" turns out to e t time if we average over a series of invocations.\nThe first time we call \"put\" it takes 1 unit of work. The d e also takes 1 unit. The third time we have to rehash, so it takes 2\nwhich shows that the average work per \"put\" is about 2 units. d t means that \"put\" is constant time on average."], ["unit work next time h, mybettermap methods, unit work e, e time average series invocations first time call, e e, r analyze rehash constant time linear way similar reason, new key, tower result uniform height, next time call, constant time public boolean containskey object target mylinearmap k v map choosemap target, amortized analysis, unit hash new key size hash table, object key mylinearmap k v map choosemap key return key method hashes key constant time invokes constant time, constant time average, good core method", "\"ArrayList.add\", which we analyzed in Section~\\ref{classifying-add}.\n(see Section~\\ref{classifying-add})."], ["unit work next time h, new key, e e, tower result uniform height, amortized analysis, important double number f k rehash, target public v get object key mylinearmap k v map choosemap key return key public v, knock towers", "Again, the argument is based on amortized analysis"], ["unit work next time h, mybettermap methods, next time call, new key, e e, constant time public boolean containskey object target mylinearmap k v map choosemap target, tower result uniform height, unit hash new key size hash table, amortized analysis, important double number f k rehash, object key mylinearmap k v map choosemap key return key method hashes key constant time invokes constant time", "units to rehash the existing keys and 1 unit to hash the new key.\nNow the size of the hash table is 4, so the next time we call\n\"put\", it takes 1 unit of work. But the next time we have o h, which takes 4 units to rehash the existing keys and 1 unit o h the new key."], ["unit work next time h, new key, e e, tower result uniform height, amortized analysis, important double number f k rehash, knock towers", "As the arrows suggest, if we knock down the towers, each one fills e e before the next tower. The result is a uniform height of 2 units,"], ["linear example public void clear int, p f, limitation methods, clear clear number f proportional n, efficient way, containskey get", "We've shown that \"containsKey\", \"get\", and \"remove\""], ["linear example public void clear int, amount time l, constant time, p f, limitation methods, simple model n e unit work, clear clear number f proportional n, structure fit n, efficient way, containskey get, structure fit cache l memory", "are constant time, and \"put\" is constant time on average. We d take a minute to appreciate how remarkable that is. e e of these operations is pretty much the same no matter w g the hash table is. Well, sort of.\nRemember that our analysis is based on a simple model of n e each \"unit of work\" takes the same amount of time. l s are more complicated than that. In particular, they e y fastest when working with data structures small enough to fit n e; somewhat slower if the structure doesn't fit in cache but l s in memory; and much slower if the structure doesn't fit n y."], ["linear example public void clear int, p f, limitation methods, another limitation implementation, e g key, clear clear number f proportional n, efficient way, search e, key containsvalue, containskey get", "Another limitation of this implementation is that hashing doesn't p f we are given a value rather than a key: \"containsValue\" s r because it has to search all of the sub-maps. And e s no particularly efficient way to look up a value and find e g key (or possibly keys)."], ["linear example public void clear int, p f, limitation methods, clear clear number f proportional n, efficient way, containskey get", "And there's one more limitation: some of the methods that were t e in \"MyLinearMap\" have become linear. For example:\n    public void clear() {\n        for (int i=0; i<maps.size(); i++) {\n            maps.get(i).clear();\n        }\n    }"], ["linear example public void clear int, p f, limitation methods, clear clear number f proportional n, efficient way, containskey get", "\"clear\" has to clear all of the sub-maps, and the number f b-maps is proportional to n, so it's linear. Fortunately,"], ["linear example public void clear int, amount time l, constant time, p f, limitation methods, simple model n e unit work, clear clear number f proportional n, structure fit n, containskey get, structure fit cache l memory", "this operation is not used very often, so for most applications s f is acceptable."], ["java hashmap run, next section track error x confirm, endmillis find range f, constant time, suggests implementation constant time, contains performance bug, runtimes milliseconds, ran code, modify profiles implementation, java range problem", "Before we go on, we should check whether \"MyHashMap.put\" is y t time.\nBefore you read the next section, you should track down the error, x t, and confirm that \"put\" is now constant time, as expected."], ["ant profilemapput measures, constant time, build compile e, suggests implementation constant time, contains performance bug, ran code, modify profiles implementation", "Run \"ant build\" to compile the e s. Then run \"ant ProfileMapPut\". It measures the runtime of"], ["java hashmap run, next section track error x confirm, endmillis find range f, constant time, suggests implementation constant time, contains performance bug, runtimes milliseconds, ran code, modify profiles implementation, java range problem", "\"HashMap.put\" (provided by Java) with a range of problem sizes,\n\"MyHashMap\", instead of Java's \"HashMap\". Run e r again and see if the slope is near 1. You might have o t \"startN\" and \"endMillis\" to find a range f m sizes where the runtimes are more than a few milliseconds, t t more than a few thousand."], ["line slope, constant time, suggests implementation constant time, versus problem size scale n constant time total time n linear result, analysis get something, contains performance bug, ran code, modify profiles implementation", "and plots runtime versus problem size on a log-log scale. If s n is constant time, the total time for n s d be linear, so the result should be a straight line with slope\n1. When I ran this code, the estimated slope was close to 1, which s t with our analysis. You should get something similar."], ["next section track error x confirm, constant time, suggests implementation constant time, contains performance bug, ran code, modify profiles implementation", "Modify \"ProfileMapPut.java\" so it profiles your implementation,"], ["line slope, constant time, suggests implementation constant time, versus problem size scale n constant time total time n linear result, analysis get something, contains performance bug, ran code, modify profiles implementation", "When I ran this code, I got a surprise: the slope was about 1.7,"], ["next section track error x confirm, constant time, suggests implementation constant time, contains performance bug, ran code, modify profiles implementation", "which suggests that this implementation is not constant time after all."], ["line slope, constant time, suggests implementation constant time, versus problem size scale n constant time total time n linear result, analysis get something, contains performance bug, ran code, modify profiles implementation", "It contains a \"performance bug\"."], ["old size, new instance variable size zero size updating, object key mylinearmap k v map choosemap key size v, little e, added new entry use e", "The problem with \"MyHashMap\" is in \"size\", which s d from \"MyBetterMap\":\n    public int size() {\n        int total = 0;\n        for (MyLinearMap<K, V> map: maps) {\n            total += map.size();\n        }\n        return total;\n    }\n\"MyFixedHashMap.java\".  Here's the beginning of the class definition:\npublic class MyFixedHashMap<K, V> extends MyHashMap<K, V> implements Map<K, V> {\n    private int size = 0;\n    public void clear() {\n        super.clear();\n        size = 0;\n    }\nRather than modify \"MyHashMap\", I define a new class t s it. It adds a new instance variable, \"size\", which s d to zero.\n\"size\".\nUpdating \"remove\" and \"put\" is a little more t e when we invoke the method on the superclass, we can't l r the size of the sub-map changed. Here's how I worked d t:\n    public V remove(Object key) {\n        MyLinearMap<K, V> map = chooseMap(key);\n        size -= map.size();\n        V oldValue = map.remove(key);\n        size += map.size();\n        return oldValue;\n    }\n\"size\" is correct.\nWe have the same problem here: when we invoke \"put\" on e b-map, we don't know whether it added a new entry. So we use the e n, subtracting off the old size and then adding in the new size.\nNow the implementation of the \"size\" method is simple:\n    public int size() {\n        return size;\n    }"], ["k key v value v, number entries instance variable update r call method changes, old size, new instance variable size zero size updating, constant time, simple solution, object key mylinearmap k v map choosemap key size v, clear straightforward invoke clear n e superclass, little e, solution repository book, added new entry use e", "To add up the total size it has to iterate the sub-maps. Since e e the number of sub-maps, k, as the number of entries,\n\"remove\" uses \"chooseMap\" to find the right sub-map, n s away the size of the sub-map. It invokes \"remove\" n e sub-map, which may or may not change the size of the sub-map,\ndepending on whether it finds the key. But either way, we add the w e of the sub-map back to \"size\", so the final value of"], ["k key v value v, number entries instance variable update r call method changes, n increases, key value size factor rehash return oldvalue size linear, constant time, simple solution, total time g n keys, clear straightforward invoke clear n e superclass, proportional n, linear uses size public v, solution repository book", "n, increases, k is proportional to n, so\nWhen I profiled this solution, I found that the total time for g n keys is proportional to n, which means that each \"put\" s t time, as it's supposed to be."], ["k key v value v, number entries instance variable update r call method changes, n increases, key value size factor rehash return oldvalue size linear, constant time, simple solution, total time g n keys, clear straightforward invoke clear n e superclass, proportional n, linear uses size public v, solution repository book", "\"size\" is linear.\nAnd that makes \"put\" linear, too, because it uses \"size\":\n    public V put(K key, V value) {\n        V oldValue = super.put(key, value);\n        if (size() > maps.size() * FACTOR) {\n            rehash();\n        }\n        return oldValue;\n    }\n\"size\" is linear!"], ["k key v value v, number entries instance variable update r call method changes, constant time, simple solution, clear straightforward invoke clear n e superclass, solution repository book", "Everything we did to make \"put\" constant time is wasted if\nAnd that's pretty clearly constant time."], ["key value size size factor size, number entries instance variable update r call method changes, k key v value v, constant time, simple solution, rehash return oldvalue, clear straightforward invoke clear n e superclass, k key v value mylinearmap k v map choosemap key size v, rewritten version, similar public v, solution repository book", "Fortunately, there is a simple solution, and we have seen it before: e e to keep the number of entries in an instance variable and update t r we call a method that changes it."], ["k key v value v, number entries instance variable update r call method changes, constant time, simple solution, clear straightforward invoke clear n e superclass, solution repository book", "You'll find my solution in the repository for this book, in"], ["k key v value v, number entries instance variable update r call method changes, constant time, simple solution, clear straightforward invoke clear n e superclass, solution repository book", "Updating \"clear\" is straightforward; we invoke \"clear\" n e superclass (which clears the sub-maps), and then update"], ["key value size size factor size, number entries instance variable update r call method changes, k key v value v, constant time, simple solution, rehash return oldvalue, clear straightforward invoke clear n e superclass, k key v value mylinearmap k v map choosemap key size v, rewritten version, similar public v, solution repository book", "The rewritten version of \"put\" is similar:\n    public V put(K key, V value) {\n        MyLinearMap<K, V> map = chooseMap(key);\n        size -= map.size();\n        V oldValue = map.put(key, value);\n        size += map.size();\n        if (size() > maps.size() * FACTOR) {\n            size = 0;\n            rehash();\n        }\n        return oldValue;\n    }"], ["different arrows arrows solid head, code chapter, implements map myhashmap, relationships example instance mybettermap, many mylinearmap", "One challenge of working with the code in this chapter is that we e l classes that depend on each other. Here are some of e s between the classes:\n- \"MyLinearMap\" contains a \"LinkedList\" and implements\n  \"Map\".\n- \"MyBetterMap\" contains many \"MyLinearMap\" objects and\n  implements \"Map\".\n- \"MyHashMap\" extends \"MyBetterMap\", so it also contains\n  \"MyLinearMap\" objects, and it implements \"Map\".\n- \"MyFixedHashMap\" extends \"MyHashMap\" and\n  implements \"Map\".\nDifferent relationships are represented by different arrows:\n- Arrows with a solid head indicate HAS-A relationships. For example,\n  each instance of \"MyBetterMap\" contains multiple instances of\n  \"MyLinearMap\", so they are connected by a solid arrow.\n- Arrows with a hollow head and a solid line indicate IS-A\n  relationships. For example, \"MyHashMap\" extends\n  \"MyBetterMap\", so they are connected by an IS-A arrow.\n- Arrows with a hollow head and a dashed line indicate that a class\n  implements an interface; in this diagram, every class implements\n  \"Map\"."], ["n communicate alternative designs, n collection classes, class diagram class, uml uml class diagrams, software n use uml class diagrams uml, track relationships, concise way represent lot, shared mental map project g document design, box classes, several graphical standards", "To help keep track of relationships like these, software s n use **UML class diagrams**. UML stands for Unified g e\nA \"class diagram\" is one of several graphical standards defined by UML.\nUML class diagrams provide a concise way to represent a lot f n about a collection of classes. They are used during n s to communicate about alternative designs, during n s to maintain a shared mental map of the project, and g t to document the design."], ["different arrows arrows solid head, class diagram class, code chapter, uml uml class diagrams, software n use uml class diagrams uml, track relationships, implements map myhashmap, shared mental map project g document design, concise way represent lot, relationships example instance mybettermap, box classes, many mylinearmap", "(see http://thinkdast.com/uml)."], ["n collection classes, class diagram class, uml uml class diagrams, software n use uml class diagrams uml, track relationships, concise way represent lot, shared mental map project g document design, box classes", "In a class diagram, each class is represented by a box, d s between classes are represented y s. me/."], ["big hashing, binary search tree, another implementation hashing, good constant time, hash table", "At this point you should be familiar with the \"Map\" interface d e \"HashMap\" implementation provided by Java. And by making r n \"Map\" using a hash table, you should understand how\n\"HashMap\" works and why we expect its core methods to be t e.\nBecause of this performance, \"HashMap\" is widely used, but it s t the only implementation of \"Map\". There are a few reasons u t want another implementation:\n- Hashing can be slow, so even though \"HashMap\" operations are\n  constant time, the \"constant\" might be big.\n- Hashing works well if the hash function distributes the keys evenly\n  among the sub-maps.  But designing good hash functions is not easy,\n  and if too many keys end up in the same sub-map, the performance of\n  the \"HashMap\" may be poor.\n- The keys in a hash table are not stored in any particular order; in\n  fact, the order might change when the table grows and the keys are\n  rehashed. For some applications, it is necessary, or at least useful,\n  to keep the keys in order.\nIt is hard to solve all of these problems at the e e, but Java provides an implementation called \"TreeMap\" t s close:\n- It doesn't use a hash function, so it avoids the cost of hashing\n  and the difficulty of choosing a hash function.\n- Inside the \"TreeMap\", the keys are are stored in a\n  **binary search tree**, which makes it possible to traverse the\n  keys, in order, in linear time.\n- The runtime of the core methods is proportional to log n,\n  which is not quite as good as constant time, but it is still\n  very good.\nIn the next section, I'll explain how binary search trees work and then u l use one to implement a \"Map\". Along the way, we'll e e performance of the core map methods when implemented using a tree."], ["child keys, target tree target, current key search, nodes property, key node figure wikipedia page binary search trees", "A binary search tree (BST) is a tree where each node contains a key, d y \"node\" has the \"BST property\":\n- If \"node\" has a left child, all keys in the left subtree must\n  be less than the key in \"node\".\n- If \"node\" has a right child, all keys in the right subtree must\n  be greater than the key in \"node\".\nThis figure is from the Wikipedia page on binary search trees t p://thinkdast.com/bst, which u t find useful while you work on this exercise.\nThe key in the root is 8, and you can confirm that all keys to the t f the root are less than 8, and all keys to the right are greater. u n also check that the other nodes have this property.\nLooking up a key in a binary search tree is fast because we don't e o search the entire tree. Starting at the root, we can use e g algorithm:\n- Compare the key you are looking for, \"target\", to the key in\n  the current node. If they are equal, you are done.\n- If \"target\" is less than the current key, search the left tree.\n  If there isn't one, \"target\" is not in the tree.\n- If \"target\" is greater than the current key, search the right\n  tree. If there isn't one, \"target\" is not in the tree.\nAt each level of the tree, you only have to search one child. r e, if you look for \"target = 4\" in the previous diagram,\neven though the tree contains nine keys. In general, the number f s is proportional to the height of the tree, not the number f s in the tree.\nSo we expect that we can look up a key in a binary search tree in e l to log n. This is true if the tree is full, d n if the tree is only partially full. But it is not always true, s e will see."], ["right example, logarithmic log time belongs order growth, time proportional log n, e key, h level index, start root", "you start at the root, which contains the key \"8\". Because\n\"target\" is less than \"6\", you go left. And then you d e key you are looking for."], ["right example, logarithmic log time belongs order growth, time proportional log n, e key, h level index, start root", "\"target\" is less than \"8\", you go left. Because\n\"target\" is greater than \"3\" you go right. Because\nIn this example, it takes four comparisons to find the target,"], ["right example, logarithmic log time belongs order growth, full level contains, time proportional log n, tree proportional g n, nodes total number nodes h levels, e key, pattern number levels, h level index, start root, number nodes", "So what can we say about the relationship between the height of e e, \"h\", and the number of nodes, n? Starting l d working up:\n- If \"h=1\", the tree only contains one node, so \"n=1\".\n- If \"h=2\", we can add two more nodes, for a total of\n  \"n=3\".\n- If \"h=3\", we can add up to four more nodes, for a total\n  of \"n=7\".\n- If \"h=4\", we can add up to eight more nodes, for a total\n  of \"n=15\".\nBy now you might see the pattern. If we number the levels of the tree from\n2^{i-1} nodes. And the total number of nodes in \"h\" levels is 2^h-1.\nIf we have n = 2^h - 1, we can take the logarithm base 2 of both sides: log_2 n ≈ h, which means that the height of the tree is proportional o g n, if the tree is full; that is, if each level contains e m number of nodes.\nO(log n)."], ["right example, logarithmic log time belongs order growth, time proportional log n, e key, h level index, start root", "\"1\" to \"h\", the level with index \"i\" can have up to"], ["right example, logarithmic log time belongs order growth, time proportional log n, e key, h level index, start root", "An algorithm that takes time proportional to log n is called\n\"logarithmic\" or \"log time\", and it belongs to the order of growth"], ["build compile source files, methods contains unit tests mytreemap, todo help recursion, source files, previous section outlines, part map interface, helper method equals, tree replaces old value new returns old value key, puthelper private method, compareto method, repository book", "In the repository for this book, you'll find these source files:\n- \"MyTreeMap.java\" contains the code from the previous section\n  with outlines for the missing methods.\n- \"MyTreeMapTest.java\" contains the unit tests for\n  \"MyTreeMap\"."], ["build compile source files, next chapter r solutions, performance core methods, e k, todo help recursion, part map interface, helper method equals, several tests, puthelper private method, compareto method", "Run \"ant build\" to compile the source files. Then run \"ant"], ["next chapter r solutions, build compile source files, performance core methods, todo help recursion, compareto method, part map interface, helper method equals, several tests, puthelper private method, e k", "  MyTreeMapTest\".  Several tests should fail, because you have e k to do!\nWhen you are done, all tests should pass. In the next chapter, I'll o r my solutions and test the performance of the core methods."], ["private node findnode object target target null throw new illegalargumentexception suppresswarnings, part map interface, new linkedhashset k return set, new illegalargumentexception root, simple cases public v", "I've provided outlines for \"get\" and \"containsKey\".  Both f m use \"findNode\", which is a private method I defined; it s t part of the \"Map\" interface. Here's how it starts:\n    private Node findNode(Object target) {\n        if (target == null) {\n            throw new IllegalArgumentException();\n        }\n        @SuppressWarnings(\"unchecked\")\n        Comparable<? super K> k = (Comparable<? super K>) target;\n        // TODO: FILL THIS IN!\n        return null;\n    }\nThe parameter \"target\" is the key we're looking for. If\n\"target\" is \"null\", \"findNode\" throws an exception.\nSome implementations of \"Map\" can handle \"null\" as a key,\nThe next lines show how we can compare \"target\" to a key in e e. From the signature of \"get\" and \"containsKey\", e r considers \"target\" to be an \"Object\". But we d o be able to compare keys, so we typecast \"target\" to\nFortunately, dealing with Java's type system is not the point of s e. Your job is to fill in the rest of \"findNode\". If t s a node that contains \"target\" as a key, it should n e node. Otherwise it should return \"null\". When you get s g, the tests for \"get\" and \"containsKey\" d s.\nUnlike your previous solution for \"findNode\", your solution for\n  starter code that handles the simple cases:\n    public V put(K key, V value) {\n        if (key == null) {\n            throw new IllegalArgumentException();\n        }\n        if (root == null) {\n            root = new Node(key, value);\n            size++;\n            return null;\n        }\n        return putHelper(root, key, value);\n    }\n    private V putHelper(Node node, K key, V value) {\n        // TODO: Fill this in.\n    }\n\"HashSet\" implementation of \"Set\", which we used n n~\\ref{exercise6}, doesn't maintain the order of the keys, t e \"LinkedHashSet\" implementation does.  You can read about t t http://thinkdast.com/linkedhashset.\n\"LinkedHashSet\":\n    public Set<K> keySet() {\n        Set<K> set = new LinkedHashSet<K>();\n        return set;\n    }"], ["build compile source files, methods contains unit tests mytreemap, keys order, source files, previous section outlines, binary search tree, part map interface, todo help recursion, outline keyset creates returns, null problematic keep things simple implementation, tree replaces old value new returns old value key, e documentation http return set, puthelper private method, compareto method, repository book", "but in a binary search tree, we need to be able to compare keys, o g with \"null\" is problematic. To keep things simple,\nthis implementation does not allow \"null\" as a key.\n\"target\" and a given key. Note that the values in the tree (s d to the keys) are not necessarily comparable, so we can't use\n\"compareTo\"; we have to invoke \"equals\" on \"target\".\n\"containsValue\" does have to search the whole tree, so s e is proportional to the number of keys, n, not e t of the tree, \"h\".\nIf you try to put \"null\" as a key, \"put\" throws n n.\nFill in \"putHelper\" so it searches the tree and:\n- If \"key\" is already in the tree, it replaces the old value with\n  the new, and returns the old value.\n- If \"key\" is not in the tree, it creates a new node, finds the\n  right place to add it, and returns \"null\".\nYou should finish off this method so it adds the keys from the tree to"], ["write r, build compile source files, todo help recursion, time proportional height tree search whole tree tree, part map interface, helper method equals, puthelper private method, compareto method, h e, tree traversal p, order hint", "\"Comparable<? super K>\", which means t t is comparable to an instance of type \"K\", or any superclass of\n\"K\".  If you are not familiar with this use of \"e s\", you can read more t p://thinkdast.com/gentut."], ["write r, build compile source files, todo help recursion, time proportional height tree search whole tree tree, part map interface, helper method equals, puthelper private method, compareto method, h e, tree traversal p, order hint", "Note that your solution should only search one path through the tree, o t should take time proportional to the height of the tree. You d t search the whole tree!\nIf the tree is empty, \"put\" creates a new node and s e instance variable \"root\".\nYour implementation of \"put\" should take time proportional to e t of the tree, h, not the number of elements, n. Ideally u d search the tree only once, but if you find it easier to h e, you can do that; it will be slower, but it doesn't change e r of growth.\n\"set\" in ascending order. HINT: you might want to write a r d; you might want to make it recursive; and you might want o d about in-order tree traversal t p://thinkdast.com/inorder."], ["build compile source files, todo help recursion, private node findnode object target target null throw new illegalargumentexception suppresswarnings, part map interface, new linkedhashset k return set, helper method equals, puthelper private method, compareto method, new illegalargumentexception root, simple cases public v", "Your next task is to fill in \"containsValue\". To get you started,\nThe next method you should fill in is \"put\". I've provided"], ["build compile source files, next chapter r solutions, performance core methods, e k, todo help recursion, part map interface, helper method equals, several tests, puthelper private method, compareto method", "I've provided a helper method, \"equals\", that compares\nin increasing order according to the \"compareTo\" method.  The"], ["next chapter r solutions, build compile source files, performance core methods, todo help recursion, compareto method, part map interface, helper method equals, several tests, puthelper private method, e k", "Otherwise, it calls \"putHelper\", which is a private method I"], ["build compile source files, todo help recursion, private node findnode object target target null throw new illegalargumentexception suppresswarnings, part map interface, new linkedhashset k return set, helper method equals, puthelper private method, compareto method, new illegalargumentexception root, simple cases public v", "defined; it is not part of the \"Map\" interface."], ["build compile source files, keys order, todo help recursion, part map interface, binary search tree, helper method equals, outline keyset creates returns, null problematic keep things simple implementation, e documentation http return set, puthelper private method, compareto method", "Finally, you should fill in the body of \"keySet\".  According o e documentation at http://thinkdast.com/mapkeyset, this d d return a \"Set\" that iterates the keys in order; that is,\nI've provided an outline of \"keySet\" that creates and returns a"], ["next chapter r solutions, performance core methods, methods contains unit tests mytreemap, private node findnode object target target null throw new illegalargumentexception suppresswarnings, part map interface, new linkedhashset k return set, source files, previous section outlines, several tests, tree replaces old value new returns old value key, puthelper private method, e k, new illegalargumentexception root, simple cases public v, repository book", "\\index{in-order}"], ["build compile source files, next chapter r solutions, performance core methods, e k, todo help recursion, part map interface, helper method equals, several tests, puthelper private method, compareto method", "% TODO: more help with recursion?"], ["k supertype k, e part, outline mytreemap fill, comparable super k k comparable super k target actual search node node root, compareto method", "In the previous exercise I gave you the outline of \"MyTreeMap\" d d you to fill in the missing methods. Now I'll present a n, starting with \"findNode\":\nprivate Node findNode(Object target) {\n    // some implementations can handle null as a key, but not this one\n    if (target == null) {\n            throw new IllegalArgumentException();\n    }\n    // something to make the compiler happy\n    @SuppressWarnings(\"unchecked\")\n    Comparable<? super K> k = (Comparable<? super K>) target;\n    // the actual search\n    Node node = root;\n    while (node != null) {\n        int cmp = k.compareTo(node.key);\n        if (cmp < 0)\n            node = node.left;\n        else if (cmp > 0)\n            node = node.right;\n        else\n            return node;\n    }\n    return null;\n}\n\"findNode\" is a private method used by \"containsKey\" and\n\"get\"; it is not part of the \"Map\" interface. e r \"target\" is the key we're looking for. I explained e t part of this method in the previous exercise:\n- In this implementation, \"null\" is not a legal value for a key.\n- Before we can invoke \"compareTo\" on \"target\", we have to\n  typecast it to some kind of \"Comparable\". The \"type wildcard\"\n  used here is as permissive as possible; that is, it works with any\n  type that implements \"Comparable\" and whose \"compareTo\"\n  method accepts \"K\" or any supertype of \"K\"."], ["bottom tree, actual search, child equal return e node, node e h loop, current key move, p variable node refers, child r move, target e e tree return null", "After all that, the actual search is relatively simple. We initialize a p variable \"node\" so it refers to the root node. Each e h the loop, we compare the target to \"node.key\". If e t is less than the current key, we move to the left child. If it's r, we move to the right child. And if it's equal, we return e t node."], ["target e e tree return null, bottom tree, actual search, node e h loop, k supertype k, e part, current key move, p variable node refers, outline mytreemap fill, comparable super k k comparable super k target actual search node node root, compareto method, child r move", "If we get to the bottom of the tree without finding the target, e e that it is not in the tree and return \"null\"."], ["e e tree containsvalue, root f, previous exercise runtime, method visits every node tree, search whole tree r containsvalue search values, e l number nodes, findnode proportional height tree e r", "As I explained in the previous exercise, the runtime of"], ["e l number nodes, e e tree containsvalue, bst property apply values, previous exercise runtime, root f, method visits every node tree, tree additional parameter, search whole tree r containsvalue search values, findnode proportional height tree e r, target value parameter invokes", "\"findNode\" is proportional to the height of the tree, not e r of nodes, because we don't have to search the whole tree. t r \"containsValue\", we have to search the values, not the keys;\nthe BST property doesn't apply to the values, so we have to search e e tree.\n\"containsValue\" takes the target value as a parameter d y invokes \"containsValueHelper\", passing the root f e tree as an additional parameter."], ["bottom tree, true containsvaluehelper target, recursive call search target, subtree otherwise, null means", "My solution is recursive:\npublic boolean containsValue(Object target) {\n    return containsValueHelper(root, target);\n}\nprivate boolean containsValueHelper(Node node, Object target) {\n    if (node == null) {\n        return false;\n    }\n    if (equals(target, node.value)) {\n        return true;\n    }\n    if (containsValueHelper(node.left, target)) {\n        return true;\n    }\n    if (containsValueHelper(node.right, target)) {\n        return true;\n    }\n    return false;\n}\nHere's how \"containsValueHelper\" works:\n- The first \"if\" statement checks the base case of the recursion.\n  If \"node\" is \"null\", that means we have recursed to the\n  bottom of the tree without finding the \"target\", so we should\n  return \"false\". Note that this only means that the target did\n  not appear on one path through the tree; it is still possible that it\n  will be found on another.\n- The second case checks whether we've found what we're looking for. If\n  so, we return \"true\". Otherwise, we have to keep going.\n- The third case makes a recursive call to search for \"target\" in\n  the left subtree. If we find it, we can return \"true\"\n  immediately, without searching the right subtree. Otherwise, we keep\n  going.\n- The fourth case searches the right subtree. Again, if we find what we\n  are looking for, we return \"true\". Otherwise, having searched\n  the whole tree, we return \"false\"."], ["e e tree containsvalue, root f, previous exercise runtime, method visits every node tree, search whole tree r containsvalue search values, e l number nodes", "This method \"visits\" every node in the tree, so it takes e l to the number of nodes."], ["elements order e set implementations, order implementations map keys, nodes e, advantage keyset create linkedhashset addinorder traverse tree, subtree order add traverse, n e correct order, private void addinorder node node set k, subtree empty e return, otherwise traverse, set implementation, solution public set k keyset set k, keys n e correct order method visits, know elements, time proportional n", "The last method I asked you to write is \"keySet\", which s a \"Set\" that contains the keys from the tree in ascending order.\nIn other implementations of \"Map\", the keys returned by\n\"keySet\" are in no particular order, but one of the s f the tree implementation is that it is simple and efficient to t e keys. So we should take advantage of that.\nIn \"keySet\", we create a \"LinkedHashSet\", which is a\n\"addInOrder\" to traverse the tree.\nThe first parameter, \"node\", is initially the root of the tree,\nbut as you should expect by now, we use it to traverse the e y. \"addInOrder\" performs a classic \"in-r l\" of the tree.\nApplying the same argument recursively, we know that the elements m e left subtree are in order, as well as the elements from the t e.  And the base case is correct: if the subtree is empty, o s are added.  So we can conclude that this method adds all keys n e correct order.\nBecause this method visits every node in the tree, like"], ["elements order e set implementations, addinorder set, new linkedhashset k addinorder root, private void addinorder node node set k, set implementation, solution public set k keyset set k, node null return addinorder, time proportional n", "Here's my solution:\npublic Set<K> keySet() {\n    Set<K> set = new LinkedHashSet<K>();\n    addInOrder(root, set);\n    return set;\n}\nprivate void addInOrder(Node node, Set<K> set) {\n    if (node == null) return;\n    addInOrder(node.left, set);\n    set.add(node.key);\n    addInOrder(node.right, set);\n}"], ["elements order e set implementations, addinorder set, private void addinorder node node set k, set implementation, solution public set k keyset set k, node null return addinorder, time proportional n", "\"Set\" implementation that keeps the elements in order (e t other \"Set\" implementations). Then we call"], ["elements order e set implementations, nodes e, addinorder set, subtree order add traverse, n e correct order, private void addinorder node node set k, subtree empty e return, otherwise traverse, set implementation, solution public set k keyset set k, time proportional n", "If \"node\" is \"null\", that means the subtree is empty, o e return without adding anything to \"set\". Otherwise we:\n- Traverse the left subtree in order.\n- Add \"node.key\".\n- Traverse the right subtree in order.\nRemember that the BST property guarantees that all nodes in the t e are less than \"node.key\", and all nodes in the t e are greater. So we know that \"node.key\" has been added n e correct order."], ["elements order e set implementations, order implementations map keys, advantage keyset create linkedhashset addinorder traverse tree, addinorder set, private void addinorder node node set k, set implementation, solution public set k keyset set k, keys n e correct order method visits, know elements, time proportional n", "\"containsValue\", it takes time proportional to n."], ["size mytreemap final, log base, final size mytreemap, every time, logarithmic take time proportional log guarantee", "In \"MyTreeMap\", the methods \"get\" and \"put\" e e proportional to the height of the tree, h. In the s e, we showed that if the tree is full --- if every level of the e s the maximum number of nodes --- the height of the tree s l to log n.\nAnd I claimed that \"get\" and \"put\" are logarithmic; t s, they take time proportional to log n. But for t s, there's no guarantee that the tree is full. In general,\nthe shape of the tree depends on the keys and what order they are added.\nI ran this code with \"n=16384\" and measured the runtime and e t of the final tree. Here's the output:\nTime in milliseconds = 151\nFinal size of MyTreeMap = 16384\nlog base 2 of size of MyTreeMap = 14.0\nFinal height of MyTreeMap = 33\nI included \"log base 2 of size of MyTreeMap\" to see how tall the e d be if it were full. The result indicates that a full tree h t 14 would contain 16,384 nodes.\nThe actual tree of random strings has height 33, which is y e than the theoretical minimum, but not too bad. To find one key in a n of 16,384, we only have to make 33 comparisons. Compared to a r search, that's almost 500 times faster.\nThis performance is typical with random strings or other keys that e d in no particular order. The final height of the tree might be 2-3\nlog n grows so slowly as n increases, it can e t to distinguish logarithmic time from constant time n e.\nAnd let's see what happens when we run it:\nTime in milliseconds = 1158\nFinal size of MyTreeMap = 16384\nlog base 2 of size of MyTreeMap = 14.0\nFinal height of MyTreeMap = 16384\nlonger. If you wonder why, take a look at the final height of the tree:\nIf you think about how \"put\" works, you can figure out what's g on. Every time we add a new key, it's larger than all of the s n the tree, so we always choose the right subtree, and always add e w node as the right child of the rightmost node. The result is an\n\"unbalanced\" tree that only contains right children.\nThe height of this tree is proportional to n, t g n, so the performance of \"get\" and \"put\" s r, not logarithmic.\n  In the balanced tree, the height is 4 and the total number f s is 2^4-1 = 15.  In the unbalanced tree with the same number f s, the height is 15."], ["n tree, works practice test n h, size mytreemap final, log base, final size mytreemap, tree height, times theoretical minimum, proportional g, alphabetical order, sample datasets list random strings list", "To see how this works out in practice, we'll test our n h two sample datasets: a list of random strings and a list f s in increasing order."], ["n tree, sample datasets list random strings list, works practice test n h, size mytreemap final, log base, final size mytreemap, new mytreemap string integer int n string timestamp timestamp, tree height, times theoretical minimum, proportional g, alphabetical order, uses keys mytreemap string integer, code generates, strings map string integer, add keys", "Here's the code that generates random strings:\nMap<String, Integer> map = new MyTreeMap<String, Integer>();\nfor (int i=0; i<n; i++) {\n    String uuid = UUID.randomUUID().toString();\n    map.put(uuid, 0);\n}\n\"UUID\" is a class in the \"java.util\" package that n e a random \"universally unique identifier\". UUIDs are l r a variety of applications, but in this example we're g e of an easy way to generate random strings.\nHowever, binary search trees don't always behave so well. Let's see t s when we add keys in increasing order. Here's an example t s timestamps in nanoseconds and uses them as keys:\nMyTreeMap<String, Integer> map = new MyTreeMap<String, Integer>();\nfor (int i=0; i<n; i++) {\n    String timestamp = Long.toString(System.nanoTime());\n    map.put(timestamp, 0);\n}"], ["n tree, works practice test n h, size mytreemap final, log base, final size mytreemap, tree height, times theoretical minimum, proportional g, alphabetical order, sample datasets list random strings list", "times the theoretical minimum, but it is still proportional o g n, which is much less than n. In fact,"], ["n tree, works practice test n h, size mytreemap final, number convert timestamps strings, log base, final size mytreemap, previous case, tree height, times theoretical minimum, elapsed time nanoseconds time call, proportional g, alphabetical order, sample datasets list random strings list", "\"System.nanoTime\" returns an integer with type \"long\" t s elapsed time in nanoseconds. Each time we call it, we get a t bigger number. When we convert these timestamps to strings,\nThe runtime is more than seven times longer than in the previous case."], ["n tree, sample datasets list random strings list, works practice test n h, size mytreemap final, log base, final size mytreemap, new mytreemap string integer int n string timestamp timestamp, tree height, times theoretical minimum, proportional g, alphabetical order, uses keys mytreemap string integer, code generates, strings map string integer, add keys", "they appear in increasing alphabetical order."], ["n tree, sample datasets list random strings list, size mytreemap final, works practice test n h, log base, final size mytreemap, new mytreemap string integer int n string timestamp timestamp, times theoretical minimum, proportional g, tree height, uses keys mytreemap string integer, code generates, strings map string integer, add keys, alphabetical order", "16384!"], ["summary binary search tree implement get, mytreemap java, keys map order, example code, possible solutions problem, problem additional work time new key, avl tree avl initials, random timestamps fact timestamps, logarithmic time keys, read trees", "There are two possible solutions to this problem:\n- You could avoid adding keys to the \"Map\" in order. But this is\n  not always possible.\n- You could make a tree that does a better job of handling keys if they\n  happen to be in order.\nThe second solution is better, and there are several ways to do it. e t common is to modify \"put\" so that it detects when the e s starting to become unbalanced and, if so, rearranges the nodes. s h this capability are called \"self-balancing\". n f-balancing trees include the AVL tree (\"AVL\" are the initials f e inventors), and the red-black tree, which is what the Java\n\"TreeMap\" uses.\n\"put\" in logarithmic time, but only if the keys are added in n r that keeps the tree sufficiently balanced. Self-balancing s d this problem by doing some additional work each time a new key s d."], ["summary binary search tree implement get, mytreemap java, example code, random timestamps fact timestamps, read trees", "In our example code, if we replace \"MyTreeMap\" with the Java"], ["summary binary search tree implement get, mytreemap java, keys map order, example code, possible solutions problem, problem additional work time new key, avl tree avl initials, random timestamps fact timestamps, logarithmic time keys, read trees", "\"TreeMap\", the runtimes are about the same for the random s d the timestamps. In fact, the timestamps run faster, even though y e in order, probably because they take less time to hash."], ["summary binary search tree implement get, mytreemap java, example code, random timestamps fact timestamps, read trees", "In summary, a binary search tree can implement \"get\" and"], ["summary binary search tree implement get, mytreemap java, example code, random timestamps fact timestamps, read trees", "You can read more about self-balancing trees t p://thinkdast.com/balancing."], ["node middle f e tree rearrange, bst removing node, previous exercise implement, idea k, figure r u read explanation p, tree similar operations", "In the previous exercise you didn't have to implement \"remove\","], ["node middle f e tree rearrange, bst removing node, previous exercise implement, idea k, figure r u read explanation p, tree similar operations", "but you might want to try it. If you remove a node from the middle f e tree, you have to rearrange the remaining nodes to restore the BST\nRemoving a node and rebalancing a tree are similar operations: if you o s exercise, you will have a better idea of how self-balancing s k."], ["node middle f e tree rearrange, bst removing node, previous exercise implement, idea k, figure r u read explanation p", "property.  You can probably figure out how to do that on your own, r u can read the explanation t p://thinkdast.com/bstdel."], ["program ends, unique strings keys key redis, term e r times, similar java set, web page index search term, previous version indexer stores index, lists strings similar java list hashes similar java map sets, termcounter maps, data contains values", "The previous version of the indexer stores the index in two a s: a \"TermCounter\" that maps from a search term to e r of times it appears on a web page, and an \"Index\" t s from a search term to the set of pages where it appears."], ["unique strings keys key redis, index data, data structures, redis database, example due power outage changes, data persistent store file e e program ends, role reference java n object, file system, data contains values", "These data structures are stored in the memory of a running a m, which means that when the program stops running, the index s t. Data stored only in the memory of a running program is called\nData that persists after the program that created it ends is called\n\"persistent\". In general, files stored in a file system e t, as well as data stored in databases.\nA simple way to make data persistent is to store it in a file. e e program ends, it could translate its data structures into a t e JSON (http://thinkdast.com/json) and then write m o a file. When it starts again, it could read the file and d e data structures.\nBut there are several problems with this solution:\n- Reading and writing large data structures (like a Web index) would be\n  slow.\n- The entire data structure might not fit into the memory of a single\n  running program.\n- If a program ends unexpectedly (for example, due to a power outage),\n  any changes made since the program last started would be lost.\nThe database I recommend for this exercise is Redis, which s t data structures that are similar to Java data structures."], ["program ends, unique strings keys key redis, term e r times, similar java set, lists strings similar java list hashes similar java map sets, termcounter maps, data contains values", "\"volatile\", because it vaporizes when the program ends."], ["program ends, unique strings keys key redis, g whole thing many kinds database management systems dbms e capabilities, write parts database, overview p, alternative database, similar java set, lists strings similar java list hashes similar java map sets, persistent storage e ability, termcounter maps, data contains values", "A better alternative is a database that provides persistent storage d e ability to read and write parts of the database without reading d g the whole thing.\nThere are many kinds of database management systems (DBMS) that e t capabilities. You can read an overview t p://thinkdast.com/database."], ["program ends, unique strings keys key redis, term e r times, similar java set, web page index search term, previous version indexer stores index, lists strings similar java list hashes similar java map sets, termcounter maps, data contains values", "Specifically, it provides:\n- Lists of strings, similar to Java \"List\".\n- Hashes, similar to Java \"Map\".\n- Sets of strings, similar to Java \"Set\"."], ["program ends, unique strings keys key redis, similar java set, data structures, redis database, role reference java n object, lists strings similar java list hashes similar java map sets, termcounter maps, data contains values", "Redis is a \"key-value database\", which means that the data s t contains (the values) are identified by unique strings (the keys). A\nkey in Redis plays the same role as a reference in Java: it s n object. We'll see some examples soon."], ["configuration page make note url, client recommend jedis java, redis cloud, classes methods, redis detailed instructions", "Redis is usually run as a remote service; in fact, the name stands for\n\"REmote DIctionary Server\". To use Redis, you have to run the s r somewhere and then connect to it using a Redis client. There e y ways to set up a server and many clients you could use. For s e, I recommend:\n- Rather than install and run the server yourself, consider using a\n  service like RedisToGo (http://thinkdast.com/redistogo), which runs\n  Redis in the cloud. They offer a free plan with enough resources for\n  the exercise.\n- For the client I recommend Jedis, which is a Java library that\n  provides classes and methods for working with Redis.\nHere are more detailed instructions to help you get started:\n- Create an account on RedisToGo, at\n  http://thinkdast.com/redissign,\n  and select the plan you want (probably the free plan to get started).\n- Create an \"instance\", which is a virtual machine running the Redis\n  server. If you click on the \"Instances\" tab, you should see your new\n  instance, identified by a host name and a port number. For example, I\n  have an instance named \"dory-10534\".\n- Click on the instance name to get the configuration page. Make a note\n  of the URL near the top of the page, which looks like this:\n  \\begin{verbatim}\n  redis://redistogo:1234567feedfacebeefa1e1234567@dory.redistogo.com:10534"], ["password need, remote dictionary server use redis run r, host name, new instance, redis client e ways, free plan, click instance name, free plan enough resources, port number, information next step, redis server click instances tab", "\\end{itemize}"], ["password need, host name, client recommend jedis java, free plan, click instance name, port number, information next step", "This URL contains the server's host name, \"dory.redistogo.com\","], ["password need, host name, free plan, click instance name, remote service fact name, port number, information next step", "the port number, \"10534\", and the password you will need o t to the server, which is the long string of letters and s n the middle. You will need this information for the next step."], ["r exercise previous exercises u e confident solutions, versions files, next section explain code works, data types methods, impossible put e n repo, repository book", "In the repository for this book,"], ["redistogo url, jedismaker class helper class, previous exercises, starter code exercise, use text editor create end edit paste url", "you'll find the source files for this exercise:\n- \"JedisMaker.java\" contains example code for connecting to a\n  Redis server and running a few Jedis methods.\n- \"JedisIndex.java\" contains starter code for this exercise.\n- \"JedisIndexTest.java\" contains test code for\n  \"JedisIndex\".\n- \"WikiFetcher.java\" contains the code we saw in previous exercises to\n  read web pages and parse them using jsoup.\nYou will also need these files, which you worked on in s s:\n- \"Index.java\" implements an index using Java data structures.\n- \"TermCounter.java\" represents a map from terms to their\n  frequencies.\n- \"WikiNodeIterable.java\" iterates through the nodes in a DOM\n  tree produced by jsoup.\nThe first step is to use Jedis to connect to your Redis server.\n\"RedisMaker.java\" shows how to do this. It reads n t your Redis server from a file, connects to it and logs in g r password, then returns a \"Jedis\" object you can use o m Redis operations.\nIf you open \"JedisMaker.java\", you should see the\n\"JedisMaker\" class, which is a helper class that provides e c method, \"make\", which creates a \"Jedis\" object. e s object is authenticated, you can use it to communicate with r s database.\n\"JedisMaker\" reads information about your Redis server from a e named \"redis_url.txt\", which you should put in e y \"src/resources\":\n- Use a text editor to create end edit\n  \"ThinkDataStructures/code/src/resources/redis_url.txt\".\n- Paste in the URL of your server. If you are using RedisToGo, the URL\n  will look like this:\n\"redis://redistogo:1234567feedfacebeefa1e1234567@dory.redistogo.com:10534\"\nNow run \"ant build\" to compile e e files and \"ant JedisMaker\" to run the example code in\n\"main\":\n    public static void main(String[] args) {\n        Jedis jedis = make();\n        // String\n        jedis.set(\"mykey\", \"myvalue\");\n        String value = jedis.get(\"mykey\");\n        System.out.println(\"Got value: \" + value);\n        // Set\n        jedis.sadd(\"myset\", \"element1\", \"element2\", \"element3\");\n        System.out.println(\"element2 is member: \" +\n                           jedis.sismember(\"myset\", \"element2\"));\n        // List\n        jedis.rpush(\"mylist\", \"element1\", \"element2\", \"element3\");\n        System.out.println(\"element at index 1: \" +\n                           jedis.lindex(\"mylist\", 1));\n        // Hash\n        jedis.hset(\"myhash\", \"word1\", Integer.toString(2));\n        jedis.hincrBy(\"myhash\", \"word2\", 1);\n        System.out.println(\"frequency of word1: \" +\n                           jedis.hget(\"myhash\", \"word1\"));\n        System.out.println(\"frequency of word1: \" +\n                            jedis.hget(\"myhash\", \"word2\"));\n        jedis.close();\n    }"], ["r exercise previous exercises u e confident solutions, versions files, next section explain code works, impossible put e n repo, data types methods, repository book", "If you have working versions of these files, you can use them r s exercise.  If you didn't do the previous exercises, or u e not confident in your solutions, you can copy my s m the {\\tt solutions} folder."], ["r exercise previous exercises u e confident solutions, versions files, file public repository help, next section explain code works, accident repository contains, impossible put e n repo, file contains, data types methods, redis server u, repository book", "Because this file contains the password for your Redis server, u d not put this file in a public repository. To help you d g that by accident, the repository contains a {\\tt .gitignore}"], ["r exercise previous exercises u e confident solutions, versions files, file public repository help, next section explain code works, accident repository contains, impossible put e n repo, file contains, data types methods, redis server u, repository book", "file that makes it harder (but not impossible) to put this e n your repo."], ["r exercise previous exercises u e confident solutions, versions files, next section explain code works, element2 frequency, exercise run output got value e t2 member e index, data types methods, impossible put e n repo, repository book", "This example demonstrates the data types and methods you are most y o use for this exercise. When you run it, the output should be:\nGot value: e t2 is member: e t at index 1: element2\nfrequency of word1: 2\nfrequency of word2: 1"], ["r exercise previous exercises u e confident solutions, versions files, next section explain code works, element2 frequency, exercise run output got value e t2 member e index, data types methods, impossible put e n repo, repository book", "In the next section, I'll explain how the code works."], ["use key hash, another key, hash read redis data types p, hash structure similar java map string string method example, current value h", "Redis is basically a map from keys, which are strings, o s, which can be one of several data types. The most basic s a type is a \\redis{string}.  I will write Redis types n s to distinguish them from Java types.\nRedis provides a \\redis{set} structure, which s r to a Java\n\"Set<String>\". To add elements to a Redis \\redis{set},\nyou choose a key to identify the \\redis{set} and then use\nYou don't have to create the \\redis{set} as a separate step. If it doesn't t, Redis creates it. In this case, it creates a \\redis{set} named\nRedis also provides a \\redis{list} structure, which s r to a Java\nFinally, Redis provides a \\redis{hash} structure, which is similar to a Java\n\"Map<String, String>\". The method\nThis example creates a \\redis{hash} named \"myhash\" that contains e y, which maps from the key \"word1\" to the value \"\"2\"\".\nThe keys and values are \\redis{string}s, so if we want to e n \"Integer\", we have to convert it o a \"String\" before we call \"hset\".\nWorking with Redis \\redis{hash}es can be confusing, because we use a key o y which \\redis{hash} we want, and then another key to identify a value n e \\redis{hash}. In the context of Redis, the second key is called a \"field\",\nidentifies a particular \\redis{hash}, and then a \"field\" like \"word1\"\nidentifies a value in the \\redis{hash}.\nFor many applications, the values in a Redis \\redis{hash} are integers, so s s a few special methods, like \"hincrby\", that treat e s as numbers:\n        jedis.hincrBy(\"myhash\", \"word2\", 1);\n1, and writes the result back to the \\redis{hash}.\nYou can read more about Redis data types t p://thinkdast.com/redistypes."], ["list string method, k integer, value mykey example key mykey value, current value h, structure g elements example, index returns, look value, right side list mylist element1 element2 element3 string element mylist, new entry hash myhash, string value myhash word1", "To add a \\redis{string} to the database,"], ["look value, list string method, k integer, value mykey example key mykey value, current value h, structure g elements example, index returns, right side list mylist element1 element2 element3 string element mylist, new entry hash myhash, string value myhash word1", "use \"jedis.set\", which is similar to \"Map.put\"; e s are the new key and the corresponding value. To look up a y and get its value, use \"jedis.get\":\n        jedis.set(\"mykey\", \"myvalue\");\n        String value = jedis.get(\"mykey\");\nIn this example, the key is \"\"mykey\"\" and the value is\n\"jedis.sadd\":\n        jedis.sadd(\"myset\", \"element1\", \"element2\", \"element3\");\n        boolean flag = jedis.sismember(\"myset\", \"element2\");\nThe method \"jedis.sismember\" checks whether an element is in a\n\"jedis.rpush\" adds elements to the end (right side) of a\n\\redis{list}:\n        jedis.rpush(\"mylist\", \"element1\", \"element2\", \"element3\");\n        String element = jedis.lindex(\"mylist\", 1);\nThe method \"jedis.lindex\" takes an integer index and returns e d element of a \\redis{list}. Adding and accessing elements e t time operations.\n\"jedis.hset\" adds a new entry to the \\redis{hash}:\n        jedis.hset(\"myhash\", \"word1\", Integer.toString(2));\n        String value = jedis.hget(\"myhash\", \"word1\");"], ["list string method, k integer, value mykey example key mykey value, current value h, structure g elements example, index returns, look value, right side list mylist element1 element2 element3 string element mylist, new entry hash myhash, string value myhash word1", "\"\"myvalue\"\"."], ["myset contains, list string method, k integer, current value h, structure g elements example, look value", "\"myset\" that contains three elements.\nAgain, you don't have to create the structure before you t g elements. This example creates a \\redis{list} named \"mylist\" t s three elements."], ["membership constant e, constant e, adding elements, list string method, k integer, myhash contains, current value h, structure g elements example, use create, look value", "\\redis{set}. Adding elements and checking membership are constant e s.\nSetting, getting, and incrementing entries in a \\redis{hash} are constant e s."], ["look value, list string method, k integer, value mykey example key mykey value, current value h, structure g elements example, index returns, right side list mylist element1 element2 element3 string element mylist, new entry hash myhash, string value myhash word1", "\"List<String>\". The method"], ["list string method, k integer, current value h, structure g elements example, look value", "And when we look up the value using \"hget\","], ["myset contains, list string method, k integer, current value h, structure g elements example, look value", "the result is a \"String\", so we might have to convert it k o \"Integer\"."], ["list string method, k integer, value mykey example key mykey value, current value h, structure g elements example, index returns, look value, right side list mylist element1 element2 element3 string element mylist, new entry hash myhash, string value myhash word1", "which might help keep things straight. So a \"key\" like \"myhash\""], ["use key hash, another key, list string method, k integer, hash read redis data types p, hash structure similar java map string string method example, current value h, structure g elements example, look value", "This method accesses \"myhash\", gets the current value d h \"word2\" (or 0 if it doesn't already exist), increments it by"], ["time assemble pieces complete solution try write whole thing, program mess something database fix start, exercise u get, long time, deleteurlsets deletetermcounters deleteallkeys", "At this point you have all the information you need to do the exercise, o u can get started if you are ready. But I have a few suggestions u t want to read first:\n- For this exercise I provide less guidance than in previous\n  exercises.  You will have to make some design decisions; in\n  particular, you will have to figure out how to divide the problem\n  into pieces that you can test one at a time, and then assemble the\n  pieces into a complete solution. If you try to write the whole thing\n  at once, without testing smaller pieces, it might take a very long\n  time to debug.\n- One of the challenges of working with persistent data is that it is\n  persistent. The structures stored in the database might change every\n  time you run the program. If you mess something up in the database,\n  you will have to fix it or start over before you can proceed. To help\n  you keep things under control, I've provided methods called\n  \"deleteURLSets\", \"deleteTermCounters\", and\n  \"deleteAllKeys\", which you can use to clean out the database\n  and start fresh. You can also use \"printIndex\" to print the\n  contents of the index.\n- Each time you invoke a \"Jedis\" method, your client sends a\n  message to the server, then the server performs the action you\n  requested and sends back a message. If you perform many small\n  operations, it will probably take a long time. You can improve\n  performance by grouping a series of operations into a\n  \"Transaction\".\nthis method would take a long time to run. We can speed it up with a"], ["example simple version deleteallkeys public void deleteallkeys set string keys, void deleteallkeys set string keys transaction string key keys, key keys key transaction, time invoke del, index contains pages", "For example, here's a simple version of \"deleteAllKeys\":\n    public void deleteAllKeys() {\n        Set<String> keys = jedis.keys(\"*\");\n        for (String key: keys) {\n            jedis.del(key);\n        }\n    }\n\"Transaction\" object:\n    public void deleteAllKeys() {\n        Set<String> keys = jedis.keys(\"*\");\n        Transaction t = jedis.multi();\n        for (String key: keys) {\n            t.del(key);\n        }\n        t.exec();\n    }"], ["example simple version deleteallkeys public void deleteallkeys set string keys, h methods jedis, returns transaction, void deleteallkeys set string keys transaction string key keys, time invoke del, key keys key transaction, exec sends, e method transaction, h operations, index contains pages", "Each time you invoke \"del\" requires a round-trip from the t o the server and back. If the index contains more than a few pages,"], ["example simple version deleteallkeys public void deleteallkeys set string keys, h methods jedis, returns transaction, void deleteallkeys set string keys transaction string key keys, time invoke del, key keys key transaction, exec sends, e method transaction, h operations, index contains pages", "\"jedis.multi\" returns a \"Transaction\" object, h s all the methods of a \"Jedis\" object. But when you e a method on a \"Transaction\", it doesn't run the n y, and it doesn't communicate with the server. It saves up a h of operations until you invoke \"exec\". Then it sends all f e saved operations to the server at the same time, which is y h faster."], ["good luck, w get, solution way divide things, tests first figure w test method, f help, information need, code basic redis commands", "Now you really have all the information you need; you d t working on the exercise. But if you get stuck, or if you really don't w how to get started, you can come back for a few more hints."], ["good luck, w get, solution way divide things, tests first figure w test method, f help, information need, code basic redis commands", "\\textbf{Don't read the following until you have run the test code, d t some basic Redis commands, and written a few methods in\nFor each method, consider writing the tests first. When you figure t w to test a method, you often get ideas about how to write it."], ["good luck, solution way divide things, associated term public void, url public integer getcount string url string term pushes contents termcounter redis public list object pushtermcountertoredis termcounter tc, tests first figure w test method, f help, information need, term termcounter tc looks search term returns, k adds url, urls public set string geturls", "\"JedisIndex.java\"}."], ["good luck, associated term public void, solution way divide things, url public integer getcount string url string term pushes contents termcounter redis public list object pushtermcountertoredis termcounter tc, tests first figure w test method, f help, information need, term termcounter tc looks search term returns, code basic redis commands, k adds url, urls public set string geturls", "OK, if you are really stuck, here are some methods you might want o k on:\n    /**\n     * Adds a URL to the set associated with term.\n     */\n    public void add(String term, TermCounter tc) {}\n    /**\n     * Looks up a search term and returns a set of URLs.\n     */\n    public Set<String> getURLs(String term) {}\n    /**\n     * Returns the number of times the given term appears at the given URL.\n     */\n    public Integer getCount(String url, String term) {}\n    /**\n     * Pushes the contents of the TermCounter to Redis.\n     */\n    public List<Object> pushTermCounterToRedis(TermCounter tc) {}"], ["good luck, solution way divide things, tests first figure w test method, f help, information need, code basic redis commands", "These are the methods I used in my solution, but they are y t the only way to divide things up. So please take these s f they help, but ignore them if they don't."], ["good luck, solution way divide things, tests first figure w test method, f help, information need, code basic redis commands", "Good luck!"], ["current url second part exercise, term map string integer, term number times, write getcounts, field new term finds", "In my solution, we store two kinds of structures in Redis:\n- For each search term, we have a \"URLSet\", which is a Redis \\redis{set}\n  of URLs that contain the search term.\n- For each URL, we have a \"TermCounter\", which is a Redis \\redis{hash}\n  that maps each search term to the number of times it appears.\nWe discussed these data types in the previous chapter. You can o d about Redis structures at http://thinkdast.com/redistypes\nIn \"JedisIndex\", I provide a method that takes a search m d returns the Redis key of its \"URLSet\":\nprivate String urlSetKey(String term) {\n    return \"URLSet:\" + term;\n}\nAnd a method that takes a URL and returns the Redis key of its\nHere's the new code that pushes a \"TermCounter\" to Redis:\npublic List<Object> pushTermCounterToRedis(TermCounter tc) {\n    Transaction t = jedis.multi();\n    String url = tc.getLabel();\n    String hashname = termCounterKey(url);\n    // if this page has already been indexed, delete the old hash\n    t.del(hashname);\n    // for each term, add an entry in the TermCounter and a new\n    // member of the index\n    for (String term: tc.keySet()) {\n        Integer count = tc.get(term);\n        t.hset(hashname, term, count.toString());\n        t.sadd(urlSetKey(term), url);\n    }\n    List<Object> res = t.exec();\n    return res;\n}\nIt loops through the terms in the \"TermCounter\". For each one it\n- Finds or creates a \"TermCounter\" on Redis, then adds a field\n  for the new term.\n- Finds or creates a \"URLSet\" on Redis, then adds the current\n  URL.\nThe second part of the exercise asked you to write \"getCounts\", h s a search term and returns a map from each URL where the m s to the number of times it appears there. Here is my solution:\n    public Map<String, Integer> getCounts(String term) {\n        Map<String, Integer> map = new HashMap<String, Integer>();\n        Set<String> urls = getURLs(term);\n        for (String url: urls) {\n            Integer count = getCount(url, term);\n            map.put(url, count);\n        }\n        return map;\n    }\nThis method uses two helper methods:\n- \"getURLs\" takes a search term and returns the Set of URLs where\n  the term appears.\n- \"getCount\" takes a URL and a term and returns the number of\n  times the term appears at the given URL."], ["url p elements, transaction collect operations, new contents, indexed delete, termcounter count terms, public integer getcount string url string term string rediskey termcounterkey url string count rediskey term, urlsetkey term return, index page make java termcounter contents page, contains dom, index methods simple", "\"TermCounter\":\nprivate String termCounterKey(String url) {\n    return \"TermCounter:\" + url;\n}\nHere's the implementation of \"indexPage\", which takes a URL and a p \"Elements\" object that contains the DOM tree of e s we want to index:\npublic void indexPage(String url, Elements paragraphs) {\n    System.out.println(\"Indexing \" + url);\n    // make a TermCounter and count the terms in the paragraphs\n    TermCounter tc = new TermCounter(url);\n    tc.processElements(paragraphs);\n    // push the contents of the TermCounter to Redis\n    pushTermCounterToRedis(tc);\n}\nHere are the implementations:\n    public Set<String> getURLs(String term) {\n        Set<String> set = jedis.smembers(urlSetKey(term));\n        return set;\n    }\n    public Integer getCount(String url, String term) {\n        String redisKey = termCounterKey(url);\n        String count = jedis.hget(redisKey, term);\n        return new Integer(count);\n    }"], ["small operations way, transaction collect operations, new contents, new pages, indexed delete, index page make java termcounter contents page, code previous exercise push contents termcounter redis termcounter, index methods simple", "To index a page, we\n- Make a Java \"TermCounter\" for the contents of the page, using\n  code from a previous exercise.\n- Push the contents of the \"TermCounter\" to Redis.\n\"TermCounter\" before pushing the new contents.\nThat's it for indexing new pages."], ["small operations way, transaction collect operations, new contents, new pages, indexed delete, index page make java termcounter contents page, code previous exercise push contents termcounter redis termcounter, index methods simple", "This method uses a \"Transaction\" to collect the operations d d them to the server all at once, which is much faster than sending a s of small operations.\nBecause of the way we designed the index, these methods are simple d t."], ["small operations way, transaction collect operations, new contents, new pages, indexed delete, index page make java termcounter contents page, index methods simple", "If the page has already been indexed, we delete its old"], ["time proportional number urls n search term rare terms, common terms, think answer continue, unique search terms, large n, small number, search term geturls, exercise u n, suppose indexed n pages", "Suppose we have indexed N pages and discovered M"], ["time proportional number urls n search term rare terms, common terms, think answer continue, unique search terms, large n, small number, search term geturls, exercise u n, suppose indexed n pages", "unique search terms. How long will it take to look up a search term?\n\"getURLs\" takes time proportional to the number of URLs t n the search term. For rare terms, that might be a small number,"], ["common terms, think answer continue, large n, exercise u n, suppose indexed n pages", "Think about your answer before you continue."], ["look search term run getcounts, common terms, map runs geturls get set urls url set, think answer continue, large n, entry hashmap inside, exercise u n, suppose indexed n pages, getcount finds", "To look up a search term, we run \"getCounts\", which\n- Creates a map.\n- Runs \"getURLs\" to get a Set of URLs.\n- For each URL in the Set, runs \"getCount\" and adds an entry\n  to a \"HashMap\".\nInside the loop, we run \"getCount\", which finds a"], ["common terms, think answer continue, large n, exercise u n, suppose indexed n pages", "but for common terms it might be as large as N."], ["e runtime proportional number pages, termcounter redis, common terms, think answer continue, large n, exercise u n, e term, entry constant time operations, getcounts n, suppose indexed n pages", "\"TermCounter\" on Redis, looks up a term, and adds an entry to a p. Those are all constant time operations, so the l y of \"getCounts\" is O(N) in the worst case. However, n e the runtime is proportional to the number of pages that n e term, which is normally much less than N."], ["common terms, think answer continue, c complexity, large n, exercise u n, algorithm efficient terms, suppose indexed n pages, many l redis", "This algorithm is as efficient as it can be, in terms f c complexity, but it is very slow because it sends many l s to Redis. You can make it faster using a"], ["time proportional number urls n search term rare terms, common terms, think answer continue, unique search terms, large n, small number, search term geturls, exercise u n, suppose indexed n pages", "\"Transaction\". You might want to do that as an exercise, or u n see my solution in \"RedisIndex.java\"."], ["termcounter redis, split strings search terms, termcounter furthermore useful help, way improve performance, index page traverse dom tree find, data structures, common words first, term add element urlset add element redis termcounter, lot f, every urlset, termcounter linear number unique terms", "Using the data structures we designed, how long will it take to index a e? Again, think about your answer before you continue.\nThis analysis suggests a way to improve performance: we should y d indexing very common words. First of all, they take up a lot f e and space, because they appear in almost every \"URLSet\" and"], ["termcounter redis, split strings search terms, termcounter furthermore useful help, index page traverse dom tree find, term add element urlset add element redis termcounter, relevant pages, termcounter linear number unique terms", "To index a page, we traverse its DOM tree, find all the"], ["termcounter redis, split strings search terms, termcounter furthermore useful help, way improve performance, index page traverse dom tree find, data structures, common words first, term add element urlset add element redis termcounter, lot f, every urlset, termcounter linear number unique terms", "\"TextNode\" objects, and split up the strings into search terms."], ["case performance, termcounter redis, time proportional number words page term increment counter hashmap e operation, split strings search terms, termcounter furthermore useful help, index page traverse dom tree find, case practice, termcounter proportional number unique terms, term add element urlset add element redis termcounter, termcounter proportional e r words page, termcounter linear number unique terms", "That all takes time proportional to the number of words on the page.\nFor each term, we increment a counter in a HashMap, which is a t e operation. So making the \"TermCounter\" takes e l to the number of words on the page.\nBoth of these are constant time operations, so the total time to h e \"TermCounter\" is linear in the number of unique search terms.\nIn summary, making the \"TermCounter\" is proportional to e r of words on the page. Pushing the \"TermCounter\" to s s proportional to the number of unique terms.\nSince the number of words on the page usually exceeds the number f e search terms, the overall complexity is proportional to e r of words on the page. In theory a page might contain all h s in the index, so the worst case performance is O(M), but we don't t to see the worse case in practice."], ["termcounter redis, split strings search terms, termcounter furthermore useful help, index page traverse dom tree find, search engines, stop words http, common words, term add element urlset add element redis termcounter, termcounter linear number unique terms", "Pushing the \"TermCounter\" to Redis requires deleting a\nThen for each term we have to\n- Add an element to a \"URLSet\", and\n- Add an element to a Redis \"TermCounter\"."], ["termcounter redis, split strings search terms, termcounter furthermore useful help, index page traverse dom tree find, term add element urlset add element redis termcounter, relevant pages, termcounter linear number unique terms", "\"TermCounter\", which is linear in the number of unique terms."], ["termcounter redis, split strings search terms, termcounter furthermore useful help, index page traverse dom tree find, term add element urlset add element redis termcounter, relevant pages, termcounter linear number unique terms", "\"TermCounter\". Furthermore, they are not very useful because y n't help identify relevant pages."], ["termcounter redis, split strings search terms, termcounter furthermore useful help, index page traverse dom tree find, search engines, stop words http, common words, term add element urlset add element redis termcounter, termcounter linear number unique terms", "Most search engines avoid indexing common words, which are known in s t as stop words (http://thinkdast.com/stopword)."], ["kind crawler n e, source node crawler, web crawler, load next page program, lifo stack crawler performs", "If you did the \"Getting to Philosophy\" exercise n r~\\ref{getphilo}, you already have a program that reads a a e, finds the first link, uses the link to load the next page, d s. This program is a specialized kind of crawler, but n e say \"Web crawler\" they usually mean a program that\n- Loads a starting page and indexes the contents,\n- Finds all the links on the page and adds the linked URLs to a collection,\n  and\n- Works its way through the collection, loading pages, indexing them, and\n  adding new URLs.\n- If it finds a URL that has already been indexed, it skips\n  it.\nStarting from a source node, a crawler traverses this graph,\nThe collection we use to store the URLs determines what kind f l the crawler performs:\n- If it's a first-in-first-out (FIFO) queue, the crawler performs a\n  breadth-first traversal.\n- If it's a last-in-first-out (LIFO) stack, the crawler performs a\n  depth-first traversal.\n- More generally, the items in the collection might be prioritized. For\n  example, we might want to give higher priority to pages that have not\n  been indexed for a long time.\nYou can read more about graph traversal t p://thinkdast.com/graphtrav."], ["long time, graph collection use store urls, graph traversal p, e page node link, e another familiar graphs, reachable node", "You can think of the Web as a h e each page is a node and each link is a directed edge from one e o another. If you are not familiar with graphs, you can read t m at http://thinkdast.com/graph.\nvisiting each reachable node once."], ["new wikifetcher implementation public string crawl boolean testing, exercise lot new material, chance bring pieces, create wikicrawler provide source source, links pages languages, returns url page indexed, internal links, reminder fields wikicrawler class public class wikicrawler, new method, use offer add elements, return url complexity method", "First, let's go over our solution to the previous exercise. I provided n e of \"WikiCrawler\"; your job was to fill in \"crawl\".\n\"WikiCrawler.queueInternalLinks\"."], ["new wikifetcher implementation public string crawl boolean testing, returns url page indexed, internal links, reminder fields wikicrawler class public class wikicrawler, return url complexity method", "As a reminder, here are the fields in the \"WikiCrawler\" class:\npublic class WikiCrawler {\n    // keeps track of where we started\n    private final String source;\n    // the index where the results go\n    private JedisIndex index;\n    // queue of URLs to be indexed\n    private Queue<String> queue = new LinkedList<String>();\n    // fetcher used to get pages from Wikipedia\n    final static WikiFetcher wf = new WikiFetcher();\n}\nHere's my implementation of \"WikiCrawler.crawl\":\n    public String crawl(boolean testing) throws IOException {\n        if (queue.isEmpty()) {\n            return null;\n        }\n        String url = queue.poll();\n        System.out.println(\"Crawling \" + url);\n        if (testing==false && index.isIndexed(url)) {\n            System.out.println(\"Already indexed.\");\n            return null;\n        }\n        Elements paragraphs;\n        if (testing) {\n            paragraphs = wf.readWikipedia(url);\n        } else {\n            paragraphs = wf.fetchWikipedia(url);\n        }\n        index.indexPage(url, paragraphs);\n        queueInternalLinks(paragraphs);\n        return url;\n    }\nMost of the complexity in this method is there to make it easier o t. Here's the logic:\n- If the queue is empty, it returns \"null\" to indicate that it\n  did not index a page.\n- Otherwise it removes and stores the next URL from the queue.\n- If the URL has already been indexed, \"crawl\" doesn't index it\n  again, unless it's in testing mode.\n- Next it reads the contents of the page: if it's in testing mode, it\n  reads from a file; otherwise it reads from the Web.\n- It indexes the page.\n- It parses the page and adds internal links to the queue.\n- Finally, it returns the URL of the page it indexed."], ["exercise lot new material, chance bring pieces, link internal check, create wikicrawler provide source source, links pages languages, new method, use offer add elements", "When we create a \"WikiCrawler\", we provide \"source\" and\n\"source\"."], ["href element elt elts, elements paragraphs element paragraph paragraphs queueinternallinks, relurl href string absurl abs, exercise lot new material, chance bring pieces, create wikicrawler provide source source, links pages languages, second n real work void, methods queue interface, new method, use offer add elements", "\"index\". Initially, \"queue\" contains only one element,\nNotice that the implementation of \"queue\" is a\n\"LinkedList\" object to a \"Queue\" variable, we t s to using methods in the \"Queue\" interface; specifically,\nThe first version just loops through the paragraphs. The second n s the real work.\n    void queueInternalLinks(Elements paragraphs) {\n        for (Element paragraph: paragraphs) {\n            queueInternalLinks(paragraph);\n        }\n    }\n    private void queueInternalLinks(Element paragraph) {\n        Elements elts = paragraph.select(\"a[href]\");\n        for (Element elt: elts) {\n            String relURL = elt.attr(\"href\");\n            if (relURL.startsWith(\"/wiki/\")) {\n                String absURL = elt.attr(\"abs:href\");\n                queue.offer(absURL);\n            }\n        }\n    }"], ["linkedlist add elements, exercise lot new material, chance bring pieces, constant time, create wikicrawler provide source source, links pages languages, link internal check, new method, use offer add elements", "\"LinkedList\", so we can add elements at the end --- and e m from the beginning --- in constant time. By assigning a"], ["exercise lot new material, chance bring pieces, link internal check, create wikicrawler provide source source, links pages languages, new method, use offer add elements", "we'll use \"offer\" to add elements and \"poll\" to e m."], ["linkedlist add elements, exercise lot new material, chance bring pieces, constant time, create wikicrawler provide source source, links pages languages, new method, use offer add elements", "I presented an implementation of \"Index.indexPage\" n n~\\ref{redis-indexer}. So the only new method is"], ["href element elt elts, elements paragraphs element paragraph paragraphs queueinternallinks, relurl href string absurl abs, exercise lot new material, chance bring pieces, create wikicrawler provide source source, links pages languages, second n real work void, methods queue interface, new method, use offer add elements", "I wrote two versions of this method with different parameters: e s an \"Elements\" object containing one DOM tree r h; the other takes an \"Element\" object that contains a e paragraph."], ["exercise lot new material, chance bring pieces, link internal check, create wikicrawler provide source source, links pages languages, new method, use offer add elements", "To determine whether a link is \"internal,\" we check whether the URL"], ["exercise lot new material, chance bring pieces, link internal check, create wikicrawler provide source source, links pages languages, new method, use offer add elements", "starts with \"/wiki/\". This might include some pages we don't want o x, like meta-pages about Wikipedia. And it might exclude some s e want, like links to pages in non-English languages. But this e t is good enough to get started."], ["href element elt elts, elements paragraphs element paragraph paragraphs queueinternallinks, relurl href string absurl abs, exercise lot new material, chance bring pieces, create wikicrawler provide source source, links pages languages, second n real work void, methods queue interface, new method, use offer add elements", "That's all there is to it. This exercise doesn't have a lot of new material;"], ["linkedlist add elements, exercise lot new material, chance bring pieces, constant time, create wikicrawler provide source source, links pages languages, new method, use offer add elements", "it is mostly a chance to bring the pieces together."], ["next phase project implement search tool, interface users, interested building web applications, search results general term, search terms, results lookup mechanism, search results multiple search terms algorithms, information retrieval exercise focus steps", "The next phase of this project is to implement a search tool. The s e'll need include:\n- An interface where users can provide search terms and view results.\n- A lookup mechanism that takes each search term and returns the pages\n  that contain it.\n- Mechanisms for combining search results from multiple search terms.\n- Algorithms for ranking and sorting search results.\nThe general term for processes like this is \"information retrieval\",\nIn this exercise, we'll focus on steps 3 and 4. We've already built a e n of 2. If you are interested in building Web applications, u t consider working on step 1."], ["next phase project implement search tool, interface users, interested building web applications, search results general term, search terms, search term returns pages, search results multiple search terms algorithms, information retrieval exercise focus steps", "which you can read more about at"], ["next phase project implement search tool, interface users, interested building web applications, search results general term, search terms, search term returns pages, search results multiple search terms algorithms, information retrieval exercise focus steps", "http://thinkdast.com/infret."], ["search results boolean operators, search engines, boolean logic expressions, u n combine results multiple search terms, search terms operators, next section write method implement operations, boolean searches", "Most search engines can perform \"boolean searches\", which means u n combine the results from multiple search terms using boolean logic.\nExpressions like these that contain search terms and operators e d \"queries\".\nWhen applied to search results, the boolean operators \"AND\","], ["java contain indonesia intersection union difference r e suppose s1, search results boolean operators, search engines, union s1 s2, boolean logic expressions, either term, search terms operators, next section write method implement operations, u n combine results multiple search terms, example search java programming, indonesia case intersection s1 s2", "For example:\n- The search \"java AND programming\" might return only pages that\n  contain both search terms: \"java\" and \"programming\".\n- \"java OR programming\" might return pages that contain either term\n  but not necessarily both.\n- \"java -indonesia\" might return pages that contain \"java\" and do\n  not contain \"indonesia\".\n\"intersection\", \"union\", and \"difference\". r e, suppose\n- \"s1\" is the set of pages containing \"java\",\n- \"s2\" is the set of pages containing \"programming\", and\n- \"s3\" is the set of pages containing \"indonesia\".\nIn that case:\n- The intersection of \"s1\" and \"s2\" is the set of pages\n  containing \"java\" AND \"programming\".\n- The union of \"s1\" and \"s2\" is the set of pages\n  containing \"java\" OR \"programming\".\n- The difference of \"s1\" and \"s2\" is the set of pages\n  containing \"java\" and not \"indonesia\"."], ["java contain indonesia intersection union difference r e suppose s1, search results boolean operators, union s1 s2, u n combine results multiple search terms, boolean logic expressions, search terms operators, next section write method implement operations, either term, boolean searches, example search java programming, indonesia case intersection s1 s2", "\"OR\", and \"-\" correspond to the set operations"], ["search results boolean operators, search engines, u n combine results multiple search terms, boolean logic expressions, search terms operators, next section write method implement operations", "In the next section you will write a method to implement these operations."], ["document frequencies total number times term, alternatives build user interface, web applications, results sort relevance display urls consider, make web application user interface", "If you get a basic version of this exercise working, you might want to k n these optional exercises:\n- Read about TF-IDF at http://thinkdast.com/tfidf\n  and implement it. You might have to modify \"JavaIndex\" to\n  compute document frequencies; that is, the total number of times\n  each term appears on all pages in the index.\n- For queries with more than one search term, the total relevance for\n  each page is currently the sum of the relevance for each term. Think\n  about when this simple version might not work well, and try out some\n  alternatives.\n- Build a user interface that allows users to enter queries with\n  boolean operators. Parse the queries, generate the results, then\n  sort them by relevance and display the highest-scoring\n  URLs. Consider generating \"snippets\" that show where the search\n  terms appeared on the page. If you want to make a Web application\n  for your user interface, consider using Heroku as a simple option\n  for developing and deploying Web applications using Java.  See\n  http://thinkdast.com/heroku."], ["insertion sort, inner loop, read e n sort wikipedia page p e, big insertion sort, simple e implement efficient g", "We'll start with insertion sort, mostly because it is simple to e d implement. It is not very efficient, but it has some g s, as we'll see.\nRather than explain the algorithm here, I suggest you read e n sort Wikipedia page t p://thinkdast.com/insertsort, which s e and animated examples. Come back when you get the l a.\n\"insertionSort\" takes two parameters, a \"List\" of any d d a \"Comparator\" that knows how to compare type \"T\"\nIn the worst case, insertion sort is quadratic. However:\n- If the elements are already sorted, or nearly so, insertion sort is\n  linear. Specifically, if each element is no more than k\n  locations away from where it should be, the inner loop never runs more\n  than k times, and the total runtime is O(kn).\n- Because the implementation is simple, the overhead is low; that is,\n  although the runtime is a n^2, the coefficient of the leading\n  term, a, is probably small.\nSo if we know that the array is nearly sorted, or is not very big,\ninsertion sort might be a good choice. But for large arrays, we n o better. In fact, much better."], ["type parameter e work lists, example shows, insertion sort, method list, new space outer loop, inner loop, read e n sort wikipedia page p e, linear n, implementation insertion sort java public class listsorter public void insertionsort list list comparator comparator int int j j, new comparator integer override public int compare integer, big insertion sort, simple e implement efficient g", "Here's an implementation of insertion sort in Java:\npublic class ListSorter<T> {\n    public void insertionSort(List<T> list, Comparator<T> comparator) {\n        for (int i=1; i < list.size(); i++) {\n            T elt_i = list.get(i);\n            int j = i;\n            while (j > 0) {\n                T elt_j = list.get(j-1);\n                if (comparator.compare(elt_i, elt_j) >= 0) {\n                    break;\n                }\n                list.set(j, elt_j);\n                j--;\n            }\n            list.set(j, elt_i);\n        }\n    }\n}\nI define a class, \"ListSorter\", as a container for t s. By using the type parameter, \"T\", we can e s that work on lists containing any object type.\n\"Integer\" objects:\n        List<Integer> list = new ArrayList<Integer>(\n            Arrays.asList(3, 5, 1, 4, 2));\n        Comparator<Integer> comparator = new Comparator<Integer>() {\n            @Override\n            public int compare(Integer elt1, Integer elt2) {\n                return elt1.compareTo(elt2);\n            }\n        };\n        ListSorter<Integer> sorter = new ListSorter<Integer>();\n        sorter.insertionSort(list, comparator);\n        System.out.println(list);"], ["r n size list n, method list, g list, objects sorts list place, new space outer loop, inner loop, linear n, example shows", "objects. It sorts the list \"in place\", which means it modifies e g list and does not have to allocate any new space.\nThe outer loop iterates from 1 to \"list.size()\", so it is r n the size of the list, n."], ["method list, new space outer loop, inner loop, objects sorts list place, linear n, example shows", "The following example shows how to call this method with a \"List\" of"], ["f array therefore total number times, quadratic case, correct jump conclusion check e r times, method list, new space outer loop, inner loop, objects sorts list place, proportional n, e g term expression, linear n, example shows", "\"insertionSort\" has two nested loops, so you might guess t s runtime is quadratic. In this case, that turns out to be correct,\nbut before you jump to that conclusion, you have to check that e r of times each loop runs is proportional to n, the e f the array.\nTherefore, the total number of times the inner loop runs is quadratic.\nIf you are not sure about that, here's the argument:\n- The first time through, i=1 and the inner loop runs at most\n  once.\n- The second time, i=2 and the inner loop runs at most twice.\n- The last time, i=n-1 and the inner loop runs at most\n  n-1 times.\nSo the total number of times the inner loop runs is the sum of e s 1, 2, ... , n-1, which is n (n-1) / 2. And e g term of that expression (the one with the highest exponent) s n^2."], ["type parameter e work lists, example shows, insertion sort, method list, new space outer loop, inner loop, new comparator integer override public int compare integer, implementation insertion sort java public class listsorter public void insertionsort list list comparator comparator int int j j, linear n, read e n sort wikipedia page p e, big insertion sort, simple e implement efficient g", "The inner loop iterates from \"i\" to 0, so it is also linear in n."], ["element every level total n elements way, half elements sort, linear e figure complexity step, linear time, many times, new arrays, n log n, f recursion split, different picture computation, next section, linearithmic people", "To classify the runtime of merge sort, it helps to think in terms f s of recursion and how much work is done on each level. e e start with a list that contains n elements. Here are the steps f e algorithm:\n- Make two new arrays and copy half of the elements into each.\n- Sort the two halves.\n- Merge the halves.\nThe first step copies each of the elements once, so it is linear. e d step also copies each element once, so it is also linear. Now e d to figure out the complexity of step 2. To do that, it helps o s at a different picture of the computation, which shows the s f recursion, as in\nwe have to split the arrays in half, which takes time proportional o n on every level. On the way back up, we have to merge a l f n elements, which is also linear."], ["element every level total n elements way, linear time, many times, top level, n log n, list n elements simplicity, lists elements n lists, next section, linearithmic people, next level", "At the top level, we have 1 list with n elements.\nFor simplicity, let's assume n is a power of 2.\nAt the next level there are 2 lists with n/2 elements.\nThen 4 lists with n/4 elements, and so on until we t o n lists with 1 element.\nOn every level we have a total of n elements. On the way down,"], ["element every level total n elements way, total amount work, linear time, many times, n total time n log, n log n, sides yields, next section, write e e, linearithmic people", "If the number of levels is h, the total amount of work for e m is O(nh). So how many levels are there? There are o s to think about that:\n- How many times do we have to cut n in half to get to 1?\n- Or, how many times do we have to double 1 before we get to n?\nAnother way to ask the second question is \"What power of 2 s n?\"\n2^h = n"], ["element every level total n elements way, total amount work, linear time, many times, n total time n log, n log n, sides yields, next section, write e e, linearithmic people", "Taking the log_2 of both sides yields\nh = log_2 n\nSo the total time is O(n log n). I didn't bother to write e e of the logarithm because logarithms with different bases differ y a constant factor, so all logarithms are in the same order of growth.\nAlgorithms in O(n log n) are sometimes called\nIt turns out that O(n log n) is the theoretical lower bound r t algorithms that work by comparing elements to each other. t s there is no \"comparison sort\" whose order of growth is r n n log n.  See http://thinkdast.com/compsort."], ["element every level total n elements way, lists elements, linear time, many times, n log n, next section, linearithmic people", "\"linearithmic\", but most people just say \"n log n\"."], ["element every level total n elements way, linear time, many times, n log n, n power, next section, linearithmic people", "But as we'll see in the next section, there are non-comparison s t take linear time!"], ["watch e http, united states presidential campaign candidate k, efficient way sort, long buckets, order growth, perform impromptu algorithm analysis e google chief executive eric schmidt, number words, width words, bubble sort, number passes, linear n, pass iterate elements", "During the 2008 United States Presidential Campaign, candidate k a was asked to perform an impromptu algorithm analysis when e d Google. Chief executive Eric Schmidt jokingly asked him for\n\"the most efficient way to sort a million 32-bit integers.\" a d apparently been tipped off, because he quickly replied, \"I k e bubble sort would be the wrong way to go.\" You can watch e o at http://thinkdast.com/obama."], ["long buckets, simple runtime c, order growth, number words, width words, integer string, radix sort sort algorithm, number passes, quadratic sort algorithms e good see http answer schmidt, linear n, pass iterate elements, size e", "Obama was right: bubble sort is conceptually simple but its runtime s c; and even among quadratic sort algorithms, its e s not very good.  See http://thinkdast.com/bubble.\nThe answer Schmidt was probably looking for is \"radix sort\", which s a **non-comparison** sort algorithm that works if the size of e s is bounded, like a 32-bit integer or a 20-character string."], ["words second row shows, h letter second pass words bucket, order top row shows, b divide bucket, third pass", "To see how this works, imagine you have a stack of index cards e h card contains a three-letter word. Here's how you could sort e s:\n- Make one pass through the cards and divide them into buckets based on\n  the first letter. So words starting with \"a\" should be\n  in one bucket, followed by words starting with \"b\", and so on.\n- Divide each bucket again based on the second letter. So words starting\n  with \"aa\" should be together, followed by words starting with\n  \"ab\", and so on. Of course, not all buckets will be full, but\n  that's OK.\n- Divide each bucket again based on the third letter.\nAt this point each bucket contains one element, and the buckets e d in ascending order.\nThe top row shows the unsorted words. The second row shows what e s look like after the first pass. The words in each bucket n h the same letter.\nAfter the second pass, the words in each bucket begin with the same o s. After the third pass, there can be only one word in h t, and the buckets are in order."], ["addition constant time h, long buckets, order growth, number words, width words, number passes, linear n, pass iterate elements", "During each pass, we iterate through the elements and add them o s. As long as the buckets allow addition in constant time, h s is linear."], ["many variations, long buckets, order growth, number words, width words, version radix sort, read p l e, number passes, linear n, pass iterate elements, many ways", "The number of passes, which I'll call w, depends on the \"width\"\nof the words, but it doesn't depend on the number of words, n."], ["many variations, long buckets, order growth, number words, width words, version radix sort, read p l e, number passes, linear n, pass iterate elements, many ways", "So the order of growth is O(wn), which is linear in n."], ["many variations, long buckets, order growth, number words, width words, version radix sort, read p l e, number passes, linear n, pass iterate elements, many ways", "There are many variations on radix sort, and many ways to t h one. You can read more about them t p://thinkdast.com/radix. As an l e, consider writing a version of radix sort."], ["constant time, heap sort, heap sort analyze understand heap sort, x heaps, array elements", "In addition to radix sort, which applies when the things you want o t are bounded in size, there is one other special-purpose g m you might encounter: bounded heap sort. Bounded heap sort s l if you are working with a very large dataset and you want o t the \"Top 10\" or \"Top k\" for some value of k h r than n.\nFor example, suppose you are monitoring a Web service that handles a n transactions per day. At the end of each day, you want o t the k biggest transactions (or slowest, or any r e). One option is to store all transactions, sort them t e end of the day, and select the top k. That would take e l to n log n, and it would be very slow because e y can't fit a billion transactions in the memory of a e m. We would have to use an \"out of core\" sort algorithm. u n read about external sorting at http://thinkdast.com/extsort.\nUsing a bounded heap, we can do much better! Here's how we l d:\n- I'll explain (unbounded) heap sort.\n- You'll implement it.\n- I'll explain bounded heap sort and analyze it.\nTo understand heap sort, you have to understand a heap, which is a a e similar to a binary search tree (BST). Here are the differences:\n- In a BST, every node, \"x\", has the \"BST property\": all nodes\n  in the left subtree of \"x\" are less than \"x\" and all\n  nodes in the right subtree are greater than \"x\".\n- In a heap, every node, \"x\", has the \"heap property\": all\n  nodes in both subtrees of \"x\" are greater than \"x\".\n- Heaps are like balanced BSTs; when you add or remove elements, they\n  do some extra work to rebalance the tree.  As a result, they can\n  be implemented efficiently using an array of elements.\nThe smallest element in a heap is always at the root, so we can d t in constant time. Adding and removing elements from a heap s e proportional to the height of the tree h. And because the p s always balanced, h is proportional to log n.  You can d e about heaps at http://thinkdast.com/heap.\nThis way of sorting is called heap sort (see http://thinkdast.com/heapsort).\nAdding n elements to the queue takes n log n time. So s removing n elements. So the runtime for heap sort is"], ["heap priorityqueue, outline method, add elements collection priorityqueue, offer poll, heap every node heap property takes log n time poll", "The Java \"PriorityQueue\" is implemented using a heap.\n\"PriorityQueue\" provides the methods specified in the\n\"Queue\" interface, including \"offer\" and \"poll\":\n- \"offer\": Adds an element to the queue, updating the heap so\n  that every node has the \"heap property\". Takes log n time.\n- \"poll\": Removes the smallest element in the queue from the root\n  and updates the heap. Takes log n time.\nGiven a \"PriorityQueue\", you can easily sort of a collection f n elements like this:\n- Add all elements of the collection to a \"PriorityQueue\" using\n  \"offer\".\n- Remove the elements from the queue using \"poll\" and add them to\n  a \"List\".\nIn the repository for this book, in \"ListSorter.java\" you'll d e outline of a method called \"heapSort\". Fill it in and n n \"ant ListSorterTest\" to confirm that it works."], ["heap priorityqueue, outline method, java priorityqueue, add elements collection priorityqueue, offer poll, heap every node heap property takes log n time poll, n log n, poll add list repository book, poll returns, e e elements, heap takes log n time given priorityqueue", "Because \"poll\" returns the smallest element remaining in e e, the elements are added to the \"List\" in ascending order."], ["adds element queue, java priorityqueue, n log n, poll add list repository book, poll returns, e e elements, heap takes log n time given priorityqueue, n ant listsortertest confirm works", "O(n log n)."], ["k elements, element heap, finding smallest element, analyze performance element perform, heap full add x", "A bounded heap is a heap that is limited to contain at most k s. If you have n elements, you can keep track of e k largest elements like this:\nInitially, the heap is empty.  For each element, \"x\":\n- Branch 1: If the heap is not full, add \"x\" to the heap.\n- Branch 2: If the heap is full, compare \"x\" to the\n  smallest element in the heap. If \"x\" is smaller, it\n  cannot be one of the largest k elements, so you can discard\n  it.\n- Branch 3: If the heap is full and \"x\" is greater than the\n  smallest element in the heap, remove the smallest element from the\n  heap and add \"x\".\nUsing a heap with the smallest element at the top, we can keep track f e largest k elements. Let's analyze the performance of s m. For each element, we perform one of:\n- Branch 1: Adding an element to the heap is O(log k).\n- Branch 2: Finding the smallest element in the heap is O(1).\n- Branch 3: Removing the smallest element is O(log k). Adding\n  \"x\" is also O(log k).\n\"topK\" that takes a \"List\", a \"Comparator\", and n r k. It should return the k largest elements in the"], ["outline method, order fill, listsortertest confirm works, case elements, case total time process, n log k linear n, order n", "In the worst case, if the elements appear in ascending order, we s n Branch 3. In that case, the total time to process n s is O(n log k), which is linear in n."], ["outline method, listsortertest confirm works, order fill, case elements, case total time process, n log k linear n", "In \"ListSorter.java\" you'll find the outline of a method called\n  ListSorterTest\" to confirm that it works."], ["outline method, listsortertest confirm works, order fill, case elements, case total time process, n log k linear n, order n", "\"List\" in ascending order. Fill it in and then run \"ant"], ["algorithm needs, contrast insertion sort copy data sorts, energy costs reasons, copies data r, large datasets", "Until now we have talked a lot about runtime analysis, but for y s we are also concerned about space. For example, one of e s of merge sort is that it makes copies of the data. In r n, the total amount of space it allocates is\nIn contrast, insertion sort doesn't copy the data because it sorts e s in place. It uses temporary variables to compare two s t a time, and it uses a few other local variables. But its space e n't depend on n.\nO(1) space.\nOne of the benefits of the bounded heap algorithm you just d s that it only needs space proportional to k (the number f s we want to keep), and k is often much smaller n n.\nSoftware developers tend to pay more attention to runtime than space, d r many applications, that's appropriate. But for large datasets, e n be just as important or more so. For example:\n- If a dataset doesn't fit into the memory of one program, the run\n  time often increases dramatically, or it might not run at all. If you\n  choose an algorithm that needs less space, and that makes it possible\n  to fit the computation into memory, it might run much faster. In the\n  same vein, a program that uses less space might make better use of\n  CPU caches and run\n  faster (see http://thinkdast.com/cache).\n- On a server that runs many programs at the same time, if you can\n  reduce the space needed for each program, you might be able to run\n  more programs on the same server, which reduces hardware and energy\n  costs.\nSo those are some reasons you should know at least a little bit t e space needs of algorithms."], ["e e requirement n, e sort list place, n log, clever implementation, new priorityqueue e elements space", "O(n log n). With a more clever implementation, you can get e e requirement down to O(n)."], ["e e requirement n, e sort list place, n log, clever implementation, new priorityqueue e elements space", "Our implementation of heap sort creates a new \"PriorityQueue\" o e the elements, so the space is O(n); but if you e d to sort the list in place, you can run heap sort with"]]}