{"conversations": [["Java interface specifies, methods class interface, source code Comparable interface, package public interface Comparable public int compareTo interface definition, type parameter h Comparable generic type order implement interface class Specify type refers Provide compareTo", "A Java \"interface\" specifies a set of methods; any class t s this \"interface\" has to provide these methods. r e, here is the source code for \"Comparable\", which is an\n\"interface\" defined in the package \"java.lang\":\npublic interface Comparable<T> {\n    public int compareTo(T o);\n}\nThis \"interface\" definition uses a type parameter, \"T\", h s \"Comparable\" a **generic type**.\nIn order to implement this \"interface\", a class has to\n- Specify the type \"T\" refers to, and\n- Provide a d d \"compareTo\" that takes an object as a parameter and s n \"int\".\nFor example, here's the source code for \"java.lang.Integer\":\npublic final class Integer extends Number implements Comparable<Integer> {\n    public int compareTo(Integer anotherInteger) {\n        int thisVal = this.value;\n        int anotherVal = anotherInteger.value;\n        return (thisVal<anotherVal ? -1 : (thisVal==anotherVal ? 0 : 1));\n    }\n    // other methods omitted\n}\nThis class extends \"Number\", so it inherits the methods d e variables of \"Number\"; and it implements\n\"Comparable<Integer>\", so it provides a d named \"compareTo\" that takes an \"Integer\" d s an \"int\".\nWhen a class declares that it implements an \"interface\", the r s that it provides all methods defined by the\n\"interface\"."], ["implementation compareTo uses", "As an aside, this implementation of \"compareTo\" uses the"], ["ternary operator, r read p", "\"ternary operator\", sometimes written \"?:\".  If you are t r with it, you can read about it t p://thinkdast.com/ternary."], ["Java Collections Framework JCF, LinkedList interface defines, List implements, ArrayList LinkedList provide methods, work List work ArrayList LinkedList", "The Java Collections Framework (JCF) defines an \"interface\" called\n\"List\" and provides two implementations, \"ArrayList\" and\n\"LinkedList\".\nThe \"interface\" defines what it means to be a \"List\"; y s that implements this \"interface\" has to provide a r set of methods, including \"add\", \"get\",\n\"ArrayList\" and \"LinkedList\" provide these methods, o y can be used interchangeably. A method written to work with a\n\"List\" will work with an \"ArrayList\", \"LinkedList\",\nwhenever possible and avoids specifying \"LinkedList\" or\n\"ArrayList\" unless it is necessary. For example, the e e is declared to be a \"List\", and \"getList\" s a \"List\", but neither specifies which kind of list.\nThis style is called **interface-based programming**,\nor more casually, \"programming to an interface\"\nHere we are talking about the general idea of an interface,\nnot a Java \"interface\".\nWhen you use a library, your code should only depend on the interface,\nlike \"List\".  It should not depend on a c n, like \"ArrayList\". That way, if the n s in the future, the code that uses it will still work.\nOn the other hand, if the interface changes, the code that depends n t has to change, too.  That's why library developers avoid g s unless absolutely necessary."], ["object implements List ListClientExample anything useful e l elements class, List contains List e use class, point k, first exercise ListClientExample constructor, list important thing example", "or any other object that implements \"List\".\n\"ListClientExample\" doesn't do anything useful, but it has e l elements of a class that **encapsulates** a\n\"List\"; that is, it contains a \"List\" as an e e.  I'll use this class to make a point, and then you'll k h it in the first exercise.\nThe \"ListClientExample\" constructor initializes \"list\" by\nThe important thing about this example is that it uses \"List\""], ["public class ListClientExample private List list public ListClientExample list new LinkedList private List getList return list public static void main String args ListClientExample, new ListClientExample List list list, new LinkedList e r method, getList returns reference e l List object main contains lines, e test methods", "Here's a contrived example that demonstrates the point:\npublic class ListClientExample {\n    private List list;\n    public ListClientExample() {\n        list = new LinkedList();\n    }\n    private List getList() {\n        return list;\n    }\n    public static void main(String[] args) {\n        ListClientExample lce = new ListClientExample();\n        List list = lce.getList();\n        System.out.println(list);\n    }\n}\n**instantiating** (that is, creating) a new \"LinkedList\"; e r method called \"getList\" returns a reference to e l \"List\" object; and \"main\" contains a few lines f e to test these methods."], ["change mind decide, ArrayList u change constructor", "If you change your mind and decide to use an \"ArrayList\", u y have to change the constructor; you don't have to make any r s."], ["example implementation simple algorithm n sort, http public class SelectionSort Swaps elements indexes, public static void swapElements int array int int j int temp array array array j array j temp Finds index, end array public static int, int array int start int lowIndex", "For example, here's an implementation of a simple algorithm d n sort (see http://thinkdast.com/selectsort):\npublic class SelectionSort {\n    /**\n     * Swaps the elements at indexes i and j.\n     */\n    public static void swapElements(int[] array, int i, int j) {\n        int temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n    /**\n     * Finds the index of the lowest value\n     * starting from the index at start (inclusive)\n     * and going to the end of the array.\n     */\n    public static int indexLowest(int[] array, int start) {\n        int lowIndex = start;\n        for (int i = start; i < array.length; i++) {\n            if (array[i] < array[lowIndex]) {\n                lowIndex = i;\n            }\n        }\n        return lowIndex;\n    }\n    /**\n     * Sorts the elements (in place) using selection sort.\n     */\n    public static void selectionSort(int[] array) {\n        for (int i = 0; i < array.length; i++) {\n            int j = indexLowest(array, i);\n            swapElements(array, i, j);\n        }\n    }\n}\nThe first method, \"swapElements\", swaps two elements of e y. Reading and writing elements are constant time operations,\nThe second method, \"indexLowest\", finds the index of the t t of the array starting at a given index, \"start\". h e through the loop, it accesses two elements of the array d s one comparison. Since these are all constant time operations,\nThe third method, \"selectionSort\", sorts the array. It loops from\n0 to n-1, so the loop executes n times. h e, it calls \"indexLowest\" and then performs a constant e n, \"swapElements\".\nThe first time \"indexLowest\" is called, t s n comparisons. The second time, it s n-1 comparisons, and so on. The total number of comparisons is n + n-1 + n-2 + ... + 1 + 0. The sum of this series is n(n+1)/2, which s l to n^2; and that means that \"selectionSort\""], ["know size elements location f e, compute location, addition e constant time operations, everything swapElements constant time whole method, number operations", "because if we know the size of the elements and the location f e first, we can compute the location of any other t h one multiplication and one addition, d e are constant time operations. Since everything in\n\"swapElements\" is constant time, the whole method is t e.\n\"indexLowest\", the number of operations is l o n. We call it n times, so the total number f s is proportional to n^2."], ["matter ones, simple let number comparisons, indexLowest traverses entire array total number comparisons, array call start, number comparisons general number comparisons", "it doesn't really matter which ones we count. To keep it simple, let's t the number of comparisons.\n- If \"start\" is 0, \"indexLowest\" traverses the entire\n  array, and the total number of comparisons is the length of\n  the array, which I'll call n.\n- If \"start\" is 1, the number of comparisons is n-1.\n- In general, the number of comparisons is n - \"start\", so\n  \"indexLowest\" is linear."], ["result different way", "To get to the same result a different way, we can think of"], ["loop time call", "\"indexLowest\" as a nested loop. Each time we call"], ["constant time algorithms belong set, algorithm constant time, linear algorithms belong n c belong way, convenient way, general rules", "All constant time algorithms belong to a set called O(1). So another y o say that an algorithm is constant time is to say that it is in O(1).\nSimilarly, all linear algorithms belong to O(n), and all c s belong to O(n^2). This way of classifying algorithms is called\nThis notation provides a convenient way to write general rules about w s behave when we compose them. For example, if you perform a r time algorithm followed by a constant algorithm, the total n e is linear. Using ∈ to mean \"is a member of\":\nIn fact, if you perform a linear operation any number of times,\nk, the total is linear, as long as k is a t t does not depend on n.\nIf f ∈ O(n) and k is a constant, kf ∈ O(n).\nBut if you perform a linear operation n times, the result s c:\nO(n). The leading constant, 2, and the additive term, 1, e t important for this kind of analysis. Similarly, n^2 + 100n + 1000 s n O(n^2).  Don't be distracted by the big numbers!\n\"Order of growth\" is another name for the same idea.  An order f h is a set of algorithms whose runtimes are in the same big O\ncategory; for example, all linear algorithms belong to the same r f growth because their runtimes are in O(n)."], ["big notation NOTE, casual definition big notation e l treatment e p f n g, n f n nf", "\"big O notation\".\nNOTE: I am providing a casual definition of big O notation. For a e l treatment, e p://thinkdast.com/bigo.\nIf f ∈ O(n) and g ∈ O(1), f+g ∈ O(n).\nIf f ∈ O(n), nf ∈ O(n^2)."], ["linear operations", "If you perform two linear operations, the total is still linear:"], ["f n g n n", "If f ∈ O(n) and g ∈ O(n), f+g ∈ O(n)."], ["general care, exponent f e total number operations", "In general, we only care about the largest exponent of n. So f e total number of operations is 2n + 1, it belongs to"], ["context order group, e Knights Round Table group knights, imagine Order r", "In this context, an \"order\" is a group, like the \\emph{Order f e Knights of the Round Table}, which is a group of knights, not a y f lining them up. So you can imagine the \\emph{Order of r s} as a set of brave, chivalrous, and particularly t s."], ["many methods identify order growth, e example implementation, uses implementation, e exercise public E, int index E element E old get index array index element return", "For many methods, we can identify the order of growth by examining e e. For example, here's the implementation of \"get\" from\nwhich uses it. Here is our implementation of \"set\" from e s exercise:\n    public E set(int index, E element) {\n        E old = get(index);\n        array[index] = element;\n        return old;\n    }"], ["MyArrayList public E, int index index, index size, new IndexOutOfBoundsException return array index, clever part solution check e array", "\"MyArrayList\":\n    public E get(int index) {\n        if (index < 0 || index >= size) {\n            throw new IndexOutOfBoundsException();\n        }\n        return array[index];\n    }\nOne slightly clever part of this solution is that it does not check e s of the array explicitly; it takes advantage of \"get\",\nNext we'll look at some linear methods. For example, here's y n of \"indexOf\":\n    public int indexOf(Object target) {\n        for (int i = 0; i<size; i++) {\n            if (equals(target, array[i])) {\n                return i;\n            }\n        }\n        return -1;\n    }\nThe analysis of \"remove\" is similar. Here's my implementation:\n    public E remove(int index) {\n        E element = get(index);\n        for (int i=index; i<size-1; i++) {\n            array[i] = array[i+1];\n        }\n        size--;\n        return element;\n    }"], ["constant time, problem Everything, invocation get time, constant time, constant time", "Everything in \"get\" is constant time, so \"get\" is t e. No problem.\nEverything in \"set\", including the invocation of \"get\", s t time, so \"set\" is also constant time.\nIt uses \"get\", which is constant time, and then loops through e y, starting from \"index\". If we remove the element at the d f the list, the loop never runs and this method is constant time. If e e the first element, we loop through all of the remaining elements,"], ["classified get classify set", "Now that we've classified \"get\", we can classify \"set\","], ["index invalid", "which raises an exception if the index is invalid."], ["indexOf invokes equals, classify equals first private boolean equals Object target Object element target null return element null, element method invokes, depend size target element depend size array consider time purposes", "Each time through the loop, \"indexOf\" invokes \"equals\", o e have to classify \"equals\" first. Here it is:\n    private boolean equals(Object target, Object element) {\n        if (target == null) {\n            return element == null;\n        } else {\n            return target.equals(element);\n        }\n    }\nThis method invokes \"target.equals\"; the runtime of this d t depend on the size of \"target\" or \"element\", but t y doesn't depend on the size of the array, so we consider t t time for purposes of analyzing \"indexOf\"."], ["indexOf everything, loop e next question, many times, loop execute", "Getting back to \"indexOf\", everything inside the loop is t e, so the next question we have to consider is: how many times s e loop execute?"], ["n r, elements average expect test half elements", "If we get lucky, we might find the target object right away and n r testing only one element. If we are unlucky, we might have to t l of the elements. On average, we expect to test half of the elements,"], ["unlikely case e, array linear method, n e special case, element end e end", "so this method is considered linear (except in the unlikely case t e know the target element is at the beginning of the array).\nwhich is linear. So, again, this method is considered linear (except n e special case where we know the element is at the end or a t e from the end)."], ["n x element parameters, int index E element index, index size, new IndexOutOfBoundsException add element, add element shift elements int index array array", "Here's a version of \"add\" that takes n x and an element as parameters:\n    public void add(int index, E element) {\n        if (index < 0 || index > size) {\n            throw new IndexOutOfBoundsException();\n        }\n        // add the element to get the resizing\n        add(element);\n        // shift the other elements\n        for (int i=size-1; i>index; i--) {\n            array[i] = array[i-1];\n        }\n        // put the new one in the right place\n        array[index] = element;\n    }\nThis two-parameter version, called \"add(int, E)\", s e one-parameter version, called \"add(E)\", which puts e w element at the end. Then it shifts the other elements to the right,\nBefore we can classify the two-parameter \"add(int, E)\", we e o classify the one-parameter \"add(E)\":\n    public boolean add(E element) {\n        if (size >= array.length) {\n            // make a bigger array and copy over the elements\n            E[] bigger = (E[]) new Object[array.length * 2];\n            System.arraycopy(array, 0, bigger, 0, array.length);\n            array = bigger;\n        }\n        array[size] = element;\n        size++;\n        return true;\n    }\nassume we start with an array that has room for 2 elements.\n- The first time we call add, it finds unused space in the array, so it\n  stores 1 element.\n- The second time, it finds unused space in the array, so it stores 1\n  element.\n- The third time, we have to resize the array, copy 2 elements, and\n  store 1 element. Now the size of the array is 4.\n- The fourth time stores 1 element.\n- The fifth time resizes the array, copies 4 elements, and stores 1\n  element. Now the size of the array is 8.\n- The next 3 adds store 3 elements.\n- The next add copies 8 and stores 1. Now the size is 16.\n- The next 7 adds store 7 elements.\n\"add(int, E)\"? After calling \"add(E)\", it loops h t of the array and shifts elements. This loop is linear, except n e special case where we are adding at the end of the list. So"], ["new element correct place, e n elements, total number f", "and puts the new element in the correct place.\nBy now you should see the pattern: to do n adds, we have o e n elements and copy n-2. So the total number f s is n + n - 2, which is 2n-2."], ["hard analyze n unused space array constant time e array linear e proportional size array, strange algorithm, linear e time average key double length e time, limits number times, copied Otherwise add", "The one-parameter version turns out to be hard to analyze. If there s n unused space in the array, it is constant time, but if we have o e the array, it's linear because \"System.arraycopy\" s e proportional to the size of the array.\nIt might seem strange that an algorithm that is sometimes linear can e t time on average. The key is that we double the length of e y each time it gets resized. That limits the number of times h t gets copied. Otherwise --- if we add a fixed amount to e h of the array, rather than multiplying by a fixed amount --- e s doesn't work."], ["constant time, constant time, E constant time", "So is {\\tt add} constant time or linear?\n\"add\" as constant time.\nNow, if \"add(E)\" is constant time, what about\n\"add(int, E)\" is linear."], ["average number, add series, simplicity get average number operations, add divide total n result, big e term", "We can classify this method by thinking about the average number f s per add over a series of n adds. For simplicity,\nTo get the average number of operations per add, we divide the total y n; the result is 2 - 2/n. As n gets big, e d term, 2/n, gets small. Invoking the principle that e y care about the largest exponent of n, we can think of\n% was an average over a hypothetical set of inputs when we looked at\n% confusing for experts (who know the difference between average\nThis way of classifying an algorithm, by computing the average time in a s of invocations, is called **amortized analysis**.  You n d more about it at"], ["NOTE Patrick, potential confusion use average", "% NOTE: Patrick notes potential confusion in my use of average, which"], ["indexOf average sequence operations", "% indexOf, and here is the average over a sequence of operations."], ["case analysis, analysis beginners key idea, cost copying array amortized series invocations", "% case analysis and amortized analysis) than for beginners (who will\nThe key idea is that the extra cost of copying the array s d, or \"amortized\", over a series of invocations."], ["last example, removeAll e n MyArrayList, removeAll Collection collection boolean flag true Object obj collection flag, obj return flag collection collection, contains n elements", "The last example we'll consider is \"removeAll\"; here's e n in \"MyArrayList\":\n    public boolean removeAll(Collection<?> collection) {\n        boolean flag = true;\n        for (Object obj: collection) {\n            flag &= remove(obj);\n        }\n        return flag;\n    }\n\"collection\". If \"collection\" contains m elements and e t we are removing from contains n elements, this method is in\n\"removeAll\" is linear. But if \"collection\" y s 1\\% of the elements in the list, \"removeAll\" s c."], ["removeAll invokes, method loop", "Each time through the loop, \"removeAll\" invokes \"remove\",\nIn this method, the loop runs once for each element in"], ["case removeAll linear respect size e n proportional n removeAll quadratic r e collection", "which is linear.  So it is tempting to think that \"removeAll\" s c.  But that's not necessarily the case.\n\"removeAll\" is linear with respect to n. But if the size of e n is proportional to n, \"removeAll\" is quadratic. r e, if \"collection\" always contains 100 or fewer elements,"], ["nm size collection", "O(nm). If the size of \"collection\" can be considered constant,"], ["talk problem size l size, pitfall algorithm analysis, shortcut f g, loop algorithm, quadratic careful k many times", "When we talk about **problem size**, we have to be l t which size, or sizes, we are talking about. This e s a pitfall of algorithm analysis: the tempting shortcut f g loops.  If there is one loop, the algorithm is n r.  If there are two loops (one nested inside the other), e m is often quadratic. But be careful! You have to k t how many times each loop runs. If the number of iterations s l to n for all loops, you can get away with just g e loops. But if, as in this example, the number of iterations is t s proportional to n, you have to give it more thought."], ["next exercise, partial implementation List interface, list store elements section, brief introduction ListNode, instance variables data", "For the next exercise I provide a partial implementation of the \"List\"\ninterface that uses a linked list to store the elements.\nbut this section provides a brief introduction.\nThe \"ListNode\" object has two instance variables: \"data\" is a e to some kind of \"Object\", and \"next\" is a reference o e next node in the list. In the last node in the list, by convention,\n\"ListNode\" provides several constructors, allowing you to provide s r \"data\" and \"next\", or initialize them to the t e, \"null\".\nYou can think of each \"ListNode\" as a list with a single element,\nbut more generally, a list can contain any number of nodes. There e l ways to make a new list. A simple option is to create a set of\n\"ListNode\" objects, like this:\n        ListNode node1 = new ListNode(1);\n        ListNode node2 = new ListNode(2);\n        ListNode node3 = new ListNode(3);"], ["p data structure, nodes contain references, node contains, next node e, contain references", "If you are not familiar with linked lists, you can read about them t p://thinkdast.com/linkedlist,\nA data structure is \"linked\" if it is made up of objects, often called\n\"nodes\", that contain references to other nodes. In a d t, each node contains a reference to the next node in e t. Other linked structures include trees and graphs, in which s n contain references to more than one other node."], ["class definition simple node public class ListNode public Object data public ListNode next public ListNode, null public ListNode Object data data, public ListNode Object, ListNode next data, public String", "Here's a class definition for a simple node:\npublic class ListNode {\n    public Object data;\n    public ListNode next;\n    public ListNode() {\n        this.data = null;\n        this.next = null;\n    }\n    public ListNode(Object data) {\n        this.data = data;\n        this.next = null;\n    }\n    public ListNode(Object data, ListNode next) {\n        this.data = data;\n        this.next = next;\n    }\n    public String toString() {\n        return \"ListNode(\" + data.toString() + \")\";\n    }\n}\n(like \"ListNode\" and \"Integer\") and their instance variables n e inside."], ["next null link, node2 node3 null null", "\"next\" is \"null\".\nAnd then link them up, like this:\n        node1.next = node2;\n        node2.next = node3;\n        node3.next = null;\n\"null\"."], ["create node link time r e, list u n, new ListNode", "Alternatively, you can create a node and link it at the same time. r e, if you want to add a new node at the beginning of a list, u n do it like this:\n        ListNode node0 = new ListNode(0, node1);"], ["sequence instructions", "After this sequence of instructions, we have four nodes containing the"], ["order e node next field", "\"Integer\"s 0, 1, 2, and 3 as data, linked up in increasing order. In e t node, the \"next\" field is"], ["object diagram", "  In an object diagram,"], ["refer Objects", "variables appear as names inside boxes, with arrows that show t y refer to.  Objects appear as boxes with their type on the outside"], ["MyArrayList previous exercise array, list implementation shrinks, unused nodes", "In \"MyArrayList\" from the previous exercise, the array grows f y, but it never shrinks. The array never gets garbage collected,\nOne advantage of the linked list implementation is that it shrinks n s are removed, and the unused nodes can get garbage d y."], ["list Node get garbage, point reference second Node, belong order growth, e Java lot work, garbage collection", "and the elements don't get garbage collected until the list itself s d.\n\"Node\" (and there shouldn't be), it will get garbage collected.\nAt that point, the reference to the second \"Node\" is removed, o t gets garbage collected, too. This process continues until l s are collected.\nbut it doesn't belong to the order of growth we expected. In s e Java that do a lot of work, like garbage collection, behind e s, this kind of bug can be hard to find."], ["implementation clear method public void clear head null size", "Here is my implementation of the \"clear\" method:\n    public void clear() {\n        head = null;\n        size = 0;\n    }"], ["head null remove reference e Node references", "When we set \"head\" to \"null\", we remove a reference to e t \"Node\". If there are no other references to that"], ["classify clear method contains time operations sure looks, constant time, garbage collector work l number elements", "So how should we classify \"clear\"? The method itself contains o t time operations, so it sure looks like it's constant time. t n you invoke it, you make the garbage collector do work that's l to the number of elements. So maybe e d consider it linear!"], ["performance bug", "This is an example of what is sometimes called a **performance bug**:"], ["sense right thing", "a program that is correct in the sense that it does the right thing,"], ["implementation indexOf Read e, identify order growth read explanation public int indexOf Object target Node node head int size equals, return node return order growth method time loop invoke equals constant time, size target data, size list operations", "My implementation of \"indexOf\" is below. Read through it and e f you can identify its order of growth before you read the explanation.\n    public int indexOf(Object target) {\n        Node node = head;\n        for (int i=0; i<size; i++) {\n            if (equals(target, node.data)) {\n                return i;\n            }\n            node = node.next;\n        }\n        return -1;\n    }\nSo what is the order of growth for this method?\n- Each time through the loop we invoke \"equals\", which is\n  constant time (it might depend on the size of \"target\" or\n  \"data\", but it doesn't depend on the size of the list). The\n  other operations in the loop are also constant time.\n- The loop might run n times, because in the worse case, we\n  might have to traverse the whole list.\nmethod. Again, you should try to classify it before you read e n.\n    public void add(int index, E element) {\n        if (index == 0) {\n            head = new Node(element, head);\n        } else {\n            Node node = getNode(index-1);\n            node.next = new Node(element, node.next);\n        }\n        size++;\n    }\nIf \"index==0\", we're adding the new \"Node\" at e g, so we handle that as a special case. Otherwise, we have o e the list to find the element at \"index-1\". We use e r method \"getNode\":\n    private Node getNode(int index) {\n        if (index < 0 || index >= size) {\n            throw new IndexOutOfBoundsException();\n        }\n        Node node = head;\n        for (int i=0; i<index; i++) {\n            node = node.next;\n        }\n        return node;\n    }\nSo, what's the order of growth for \"add\"?\n- \"getNode\" is similar to\n  \"indexOf\", and it is linear for the same reason.\n- In \"add\", everything before and after \"getNode\" is\n  constant time.\nFinally, let's look at \"remove\":\n    public E remove(int index) {\n        E element = get(index);\n        if (index == 0) {\n            head = head.next;\n        } else {\n            Node node = getNode(index-1);\n            node.next = node.next.next;\n        }\n        size--;\n        return element;\n    }\nIf \"index==0\", we handle that as a special case again. e e find the node at \"index-1\" and modify it to skip over"], ["head r Node loop, time loop use equals, target return, sure next Node, exception Otherwise", "Initially \"node\" gets a copy of \"head\", so they both r o the same \"Node\". The loop variable, \"i\", counts from 0 to\n\"size-1\".  Each time through the loop, we use \"equals\" o e if we've found the target. If so, we return \"i\" immediately.\nNormally we would check to make sure the next \"Node\" is not\nit throws an exception. Otherwise it traverses the list and returns e d Node.\nJumping back to \"add\", once we find the right \"Node\", we create e w \"Node\" and put it between \"node\" and \"node.next\". u t find it helpful to draw a diagram of this operation to make e u understand it.\n\"node.next\" and link directly to \"node.next.next\". s y removes \"node.next\" from the list, and it can e e collected."], ["advance next Node list index", "Otherwise we advance to the next \"Node\" in the list.\n\"index\". Then it removes the \"Node\" that contained it."], ["null case safe loop, e end list, size consistent h e actual number nodes list", "\"null\", but in this case it is safe because the loop ends when e t to the end of the list (assuming \"size\" is consistent h e actual number of nodes in the list)."], ["target return", "If we get through the loop without finding the target, we return"], ["runtime method proportional length e people, linear operations, quadratic applies, e e, operation n sum", "So the runtime of this method is proportional to the length of e t.\nWhen people see two linear operations, they sometimes think the t s quadratic, but that only applies if one operation is nested e e other. If you invoke one operation after the other, the s d. If they are both in O(n), the sum is also in"], ["Next implementation", "Next, here is my implementation of the two-parameter \"add\"\nSo all together, \"add\" is linear."], ["getNode checks, index bounds", "\"getNode\" checks whether \"index\" is out of bounds; if so,"], ["find store element, constant time", "\"remove\" uses \"get\" to find and store the element at\n\"remove\" is constant time except \"get\" and"], ["decrement size return element", "Finally, we decrement \"size\" and return the element we d t the beginning."], ["order growth", "So, what's the order of growth for \"remove\"? Everything in"], ["getNode linear remove linear", "\"getNode\", which are linear. So \"remove\" is linear."], ["table summarizes differences", "The following table summarizes the differences between"], ["MyLinkedList MyArrayList, means operations MyArrayList advantage, e end, operations MyLinkedList advantage g", "\"MyLinkedList\" and \"MyArrayList\", where \"1\" means\nThe operations where \"MyArrayList\" has an advantage are adding t e end, removing from the end, getting and setting.\nThe operations where \"MyLinkedList\" has an advantage are g t the beginning and removing from the beginning."], ["constant time, n r r", "O(1) or constant time and n means O(n) r r."], ["f growth", "For the other operations, the two implementations are in the same r f growth."], ["use Java, e n depends", "Which implementation is better? It depends on which operations you e y to use the most. And that's why Java provides more than e n, because it depends."], ["next exercise provide class, Profiler code, method range problem, Profiler classify e f, method Java implementations", "For the next exercise I provide a class called \"Profiler\" t s code that runs a method with a range of problem sizes,\nYou will use \"Profiler\" to classify the e f the \"add\" method for the Java implementations of\nBut you don't need to know much for the next exercise; even if u e not comfortable with anonymous classes, you n y and modify the example code.\nThe next step is to create the \"Profiler\" object, passing the\nThe \"Profiler\" provides \"timingLoop\" which uses the\nWhen you run the experiments, you might have to adjust e s. If \"startN\" is too low, the runtime might be o t to measure accurately. If \"endMillis\" is too low, you t t get enough data to see a clear relationship between problem size d e.\nThis code is in \"ProfileListAdd.java\", which you'll run in the t e. When I ran it, I got this output:\n4000, 3\n8000, 0\n16000, 1\n32000, 2\n64000, 3\n128000, 6\n256000, 18\n512000, 30\n1024000, 88\n2048000, 185\n4096000, 242\n8192000, 544\n16384000, 1325"], ["plots results timeMe method Timeable object several h range values, startN value, loop start endMillis, timingLoop increases problem size runtime increases, exceeds threshold timingLoop stops", "measures runtimes, and plots the results.\n\"timeMe\" method on the \"Timeable\" object several s h a range of values of n. \"timingLoop\" takes o s:\n- \"startN\" is the value of n the timing loop should\n  start at.\n- \"endMillis\" is a threshold in milliseconds. As\n  \"timingLoop\" increases the problem size, the runtime increases;\n  when the runtime exceeds this threshold, \"timingLoop\" stops.\nThe result from \"timingLoop\" is an \"XYSeries\" t s this data. If you pass this series to \"plotResults\", t s a plot like the one in"], ["ArrayList LinkedList ArrayList, new element end n e code show results", "\"ArrayList\" and \"LinkedList\".\n\"ArrayList\", which adds the new element at the end. I'll n e code and then show the results."], ["example shows, profiler public static void profileArrayListAddEnd Timeable timeable new Timeable List String list public void setup int n list new ArrayList String public void timeMe int n int n, String title ArrayList, Profiler profiler new Profiler title timeable int startN, int endMillis", "Here's an example that shows how to use the profiler:\n    public static void profileArrayListAddEnd() {\n        Timeable timeable = new Timeable() {\n            List<String> list;\n            public void setup(int n) {\n                list = new ArrayList<String>();\n            }\n            public void timeMe(int n) {\n                for (int i=0; i<n; i++) {\n                    list.add(\"a string\");\n                }\n            }\n        };\n        String title = \"ArrayList add end\";\n        Profiler profiler = new Profiler(title, timeable);\n        int startN = 4000;\n        int endMillis = 1000;\n        XYSeries series = profiler.timingLoop(startN, endMillis);\n        profiler.plotResults(series);\n    }\nIn order to use \"Profiler\", we need to create a \"Timeable\"\nobject that provides two methods: \"setup\" and \"timeMe\".\nThe code that creates \"timeable\" is an **anonymous class** t s a new implementation of the \"Timeable\" interface d s an instance of the new class at the same time. If you are t r with anonymous classes, you can read about them here:\n\"Timeable\" object stored as an instance variable. It invokes the"], ["method measures time, setup method, e clock case, empty list timeMe", "This method measures the time it takes to run \"add\" on an\nThe \"setup\" method does whatever needs to be done before we t e clock; in this case it creates an empty list. Then \"timeMe\""], ["measure case n elements list", "does whatever operation we are trying to measure; in this case it s n elements to the list."], ["Timeable object title parameters", "\"Timeable\" object and a title as parameters."], ["column problem size n second column e milliseconds first measurements", "The first column is problem size, n; the second column s e in milliseconds. The first few measurements are pretty noisy; t t have been better to set \"startN\" around 64000."], ["next section", "The next section explains how to interpret it."], ["understanding ArrayList, constant time add elements, total time, n elements, suggests total time r", "Based on our understanding of how \"ArrayList\" works, we t e \"add\" method to take constant time when we add elements o e end. So the total time to add n elements should be linear.\nwhich is close to 1; and that suggests that the total time r n adds is linear, so each add is constant time, as expected."], ["test theory, total runtime versus problem size, straight line, e g enough measure, Mathematically write e n line runtime b n intercept line b e hand", "To test that theory, we could plot total runtime versus problem size,\nand we should see a straight line, at least for problem sizes that e g enough to measure accurately. Mathematically, we can write e n for that line: runtime = a + b n, where a is the intercept of the line and b is e e.\nOn the other hand, if \"add\" is linear, the total time r n adds would be quadratic. If we plot runtime versus m e, we expect to see a parabola. Or mathematically, something like: runtime = a + b n + c n^2. With perfect data, we might be able to tell the difference between a t line and a parabola, but if the measurements are noisy, it n e hard to tell. A better way to interpret noisy measurements is to t e and problem size on a **log-log** scale.\nWhy? Let's suppose that runtime is proportional to n^k, but e n't know what the exponent k is. We can write e p like this: runtime = a + b n + ... + c n^k. For large values of n, the term with the largest exponent s e most important, so: runtime ≈ c n^k, where ≈ means \"approximately equal\". Now, if e e the logarithm of both sides of this equation: log(runtime) ≈ log(c) + k log(n). This equation implies that if we plot runtime versus n on a g-log scale, we expect to see a straight line with t g(c) and slope k. We don't care much about e t, but the slope indicates the order of growth: f k=1, the algorithm is linear; if k=2, it's c."], ["figure previous section estimate e e eye call plotResults, fit data prints, slope mean algorithm linear n e proportional exponent k, straight line slope slope", "Looking at the figure in the previous section, you can estimate e e by eye. But when you call \"plotResults\" it computes a t s fit to the data and prints the estimated slope. In s e:\nEstimated slope = 1.06194352346708\nthat does **not** mean that the algorithm is linear. If the n e is proportional to n^k for any exponent k, e t to see a straight line with slope k. If the slope s e to 1, that suggests the algorithm is linear. If it is close to 2,"], ["important point, straight line graph", "One important point: if you see a straight line on a graph like this,"], ["previous exercise, various method, identical profileArrayListAddEnd e difference timeMe, n add, new element index", "In the previous exercise, we used \"Profiler.java\" to run various\nThis method is almost identical to \"profileArrayListAddEnd\". e y difference is in \"timeMe\", which uses the two-r n of \"add\" to put the new element at index 0. Also, e d \"endMillis\" to get one additional data point."], ["ArrayList LinkedList operations, f sizes, runtime versus problem size e, curve e, exponent relationship runtime example", "\"ArrayList\" and \"LinkedList\" operations with a range f m sizes. We plotted runtime versus problem size on a log-g e and estimated the slope of the resulting curve, which s e leading exponent of the relationship between runtime and m e.\nFor example, when we used the \"add\" method to add s o the end of an \"ArrayList\", we found that the total time o m n adds was proportional to n; that is, e d slope was close to 1. We concluded that performing n s is in O(n), so on average the time for a single add s t time, or O(1), which is what we expect based on m s.\n\"profileArrayListAddBeginning\", which tests the performance f g new elements at the beginning of an \"ArrayList\". Based on r s, we expect each add to be linear, because it has to shift e r elements to the right; so we expect n adds to e c.\nRemember that a straight line on this graph does **not** mean t e algorithm is linear. Rather, if the runtime is proportional o n^k for any exponent, k, we expect to see a t e with slope k. In this case, we expect the total time r n adds to be proportional to n^2, so we expect a t line with slope 2. In fact, the estimated slope is 1.992, h s so close I would be afraid to fake data this good."], ["NOTE Patrick, use average", "% NOTE: Again, Patrick is concerned that my use of \"average\" might"], ["reasonable describe, analysis average series operations", "% be confusing, but I think it's reasonable to describe amortized\n% analysis as an average over a series of operations."], ["fill body", "The exercise asks you to fill in the body of"], ["n e solution directory repository public static void, Timeable timeable new Timeable List String list public void setup int n list new ArrayList String public void timeMe int n int, int startN, runProfiler ArrayList, timeable startN endMillis", "Here's a solution, which you can find n e {\\tt solution} directory of the repository.\n    public static void profileArrayListAddBeginning() {\n        Timeable timeable = new Timeable() {\n            List<String> list;\n            public void setup(int n) {\n                list = new ArrayList<String>();\n            }\n            public void timeMe(int n) {\n                for (int i=0; i<n; i++) {\n                    list.add(0, \"a string\");\n                }\n            }\n        };\n        int startN = 4000;\n        int endMillis = 10000;\n        runProfiler(\"ArrayList add beginning\", timeable, startN, endMillis);\n    }"], ["results problem size", "Here are the timing results (problem size on the left, runtime n s on the right):\n4000, 14\n8000, 35\n16000, 150\n32000, 604\n64000, 2518\n128000, 11555"], ["previous exercise, constant time n, list shift, expect total time r, linear solution public static void", "In the previous exercise you also profiled the performance of adding w s at the beginning of a \"LinkedList\". Based on r s, we expect each \"add\" to take constant time, because n a linked list, we don't have to shift the existing elements; we can t d a new node at the beginning. So we expect the total time r n adds to be linear.\nHere's a solution:\n    public static void profileLinkedListAddBeginning() {\n        Timeable timeable = new Timeable() {\n            List<String> list;\n            public void setup(int n) {\n                list = new LinkedList<String>();\n            }\n            public void timeMe(int n) {\n                for (int i=0; i<n; i++) {\n                    list.add(0, \"a string\");\n                }\n            }\n        };\n        int startN = 128000;\n        int endMillis = 2000;\n        runProfiler(\"LinkedList add beginning\", timeable, startN, endMillis);\n    }\n\"ArrayList\" with \"LinkedList\" and adjusting\nso each add is constant time."], ["make changes", "We only had a make a few changes, replacing"], ["startN endMillis, good range data", "\"startN\" and \"endMillis\" to get a good range of data."], ["previous batch e e results", "The measurements were noisier than the previous batch; e e the results:\n128000, 16\n256000, 19\n512000, 28\n1024000, 77\n2048000, 330\n4096000, 892\n8192000, 1047\n16384000, 4755"], ["straight line slope, e f, squares fit results, e l time", "It's not a very straight line, and the slope is not exactly 1; the e f the least squares fit is 1.23. But these results indicate that e l time for n adds is at least approximately O(n),"], ["ArrayList r g elements", "Adding elements at the beginning is one of the operations where e t \"LinkedList\" to be faster than \"ArrayList\". But r g elements at the end, we expect \"LinkedList\" to be slower."], ["implementation traverse entire list add n end linear, total time r", "In my implementation, we have to traverse the entire list to add n t to the end, which is linear. So we expect the total time r n adds to be quadratic."], ["public static void profileLinkedListAddEnd Timeable timeable new Timeable List String list public void setup int n list new LinkedList String public void timeMe int n int n, int startN, int endMillis, runProfiler LinkedList add end timeable startN endMillis", "Well, it's not.  Here's the code:\n    public static void profileLinkedListAddEnd() {\n        Timeable timeable = new Timeable() {\n            List<String> list;\n            public void setup(int n) {\n                list = new LinkedList<String>();\n            }\n            public void timeMe(int n) {\n                for (int i=0; i<n; i++) {\n                    list.add(\"a string\");\n                }\n            }\n        };\n        int startN = 64000;\n        int endMillis = 1000;\n        runProfiler(\"LinkedList add end\", timeable, startN, endMillis);\n    }"], ["measurements noisy line, slope close e, analysis fact", "Again, the measurements are noisy and the line is not y t, but the estimated slope is 1.19, which is close to t e got adding elements at the beginning, and not very close to 2, h s what we expected based on our analysis. In fact, it is closer to 1,"], ["constant time", "which suggests that adding elements at the end is constant time."], ["list MyLinkedList, list element contains, next MyArrayList object link first node, documentation LinkedList p list implementation List e operations, list Operations x list traverse list", "My implementation of a linked list, \"MyLinkedList\", uses a y-linked list; that is, each element contains a link to the next,\nand the \"MyArrayList\" object itself has a link to the first node.\nBut if you read the documentation of \"LinkedList\" t p://thinkdast.com/linked,\nDoubly-linked list implementation of the List and e s. [...] All of the operations perform s d be expected for a doubly-linked list. Operations t x into the list will traverse the list from the beginning or e d, whichever is closer to the specified index.\nIf you are not familiar with doubly-linked lists, you can read e t them at http://thinkdast.com/doublelist,\nbut the short version is:\n- Each node contains a link to the next node and a link to the previous\n  node.\n- The \"LinkedList\" object contains links to the first and last\n  elements of the list.\n\"ArrayList\", \"MyLinkedList\" (singly-linked), and\n\"LinkedList\" (doubly-linked):"], ["quote quote", "\\begin{quote}\n\\end{quote}"], ["end list traverse r result, g end list constant time", "So we can start at either end of the list and traverse it in r n. As a result, we can add and remove elements from e g and the end of the list in constant time!"], ["table summarizes performance", "The following table summarizes the performance we expect from"], ["ArrayList r g, good ArrayList, end e ArrayList get, linear time, choice runtime", "The doubly-linked implementation is better than \"ArrayList\" r g and removing at the beginning, and just as good as\n\"ArrayList\" for adding and removing at the end. So the y e of \"ArrayList\" is for \"get\" and \"set\",\nwhich require linear time in a linked list, even if it is doubly-linked.\nmight be the better choice. If the runtime depends on adding d g elements near the beginning or the end, \"LinkedList\"\nBut remember that these recommendations are based on the order of h r large problems. There are other factors to consider:\n- If these operations don't take up a substantial fraction of the\n  runtime for your application --- that is, if your applications spends\n  most of its time doing other things --- then your choice of a\n  \"List\" implementation won't matter very much.\n- If the lists you are working with are not very big, you might not get\n  the performance you expect. For small problems, a quadratic algorithm\n  might be faster than a linear algorithm, or linear might be faster\n  than constant time. And for small problems, the difference probably\n  doesn't matter.\n- Also, don't forget about space. So far we have focused on runtime, but\n  different implementations require different amounts of space. In an\n  \"ArrayList\", the elements are stored side-by-side in a single\n  chunk of memory, so there is little wasted space, and computer\n  hardware is often faster with contiguous chunks. In a linked list,\n  each element requires a node with one or two links. The links take up\n  space (sometimes more than the data!), and with nodes scattered\n  around in memory, the hardware might be less efficient."], ["runtime application, elements ArrayList summary analysis algorithms, guidance g structures, application important runtime application, choice data structure problem size large enough order growth", "If you know that the runtime of your application depends on the time t s to \"get\" and \"set\" elements, an \"ArrayList\"\nIn summary, analysis of algorithms provides some guidance for g a structures, but only if\n- The runtime of your application is important,\n- The runtime of your application depends on your choice of data\n  structure, and\n- The problem size is large enough that the order of growth actually\n  predicts which data structure is better."], ["software engineer, g f situation", "You could have a long career as a software engineer without ever g f in this situation."], ["web search engine, Google Search Bing, f search terms returns list web pages terms, relevant means, essential components", "A **web search engine**, like Google Search or Bing, takes a t f \"search terms\" and returns a list of web pages that are t o those terms (I'll discuss what \"relevant\" means later).  You n d more at http://thinkdast.com/searcheng, but I'll n t you need as we go along.\nThe essential components of a search engine are:\n- Crawling: We'll need a program that can download a web page, parse it,\n  and extract the text and any links to other pages.\n- Indexing: We'll need a data structure that makes it possible to look up a\n  search term and find the pages that contain it.\n- Retrieval: And we'll need a way to collect results from the Index and\n  identify pages that are most relevant to the search terms.\nWe'll start with the crawler.  The goal of a crawler is to discover d d a set of web pages. For search engines like Google and Bing,\nthe goal is to find all web pages, but often crawlers are d o a smaller domain. In our case, we will only read pages m a."], ["first step, crawler reads Wikipedia page, first link, another page, l use crawler test", "As a first step, we'll build a crawler that reads a Wikipedia page,\nfinds the first link, follows the link to another page, and repeats. We l use this crawler to test the \"Getting to Philosophy\" conjecture,\nTesting the conjecture will allow us to build the basic pieces of a r without having to crawl the entire web, or even all f a. And I think the exercise is kind of fun!"], ["quote quote", "\\begin{quote}\n\\end{quote}"], ["first lowercase link main text article, Philosophy article chapters, e r", "Clicking on the first lowercase link in the main text of a a article, and then repeating the process for t s, usually eventually gets one to the Philosophy article.\nIn a few chapters, we'll work on the indexer, and then we'll get to e r."], ["read history", "and you can read its history there."], ["download web page contents, n Markup Language, HTML phrases, Hello world text, page elements", "When you download a web page, the contents are written n t Markup Language, aka HTML.\nThe phrases \"This is a title\" and \"Hello world!\" are the text t y appears on the page; the other elements are **tags** t e how the text should be displayed.\nWhen our crawler downloads a page, it will need to parse the HTML n r to extract the text and find the links. To do that, we'll use\n**jsoup**, which is an open-source Java library that downloads d s HTML.\nMost web browsers provide tools for inspecting the DOM of the page u e viewing. In Chrome, you can right-click on any part of a web e d select \"Inspect\" from the menu that pops up. In Firefox, you n t-click and select \"Inspect Element\" from the menu. i s a tool called Web Inspector, which you can read about t p://thinkdast.com/safari.\nFor Internet Explorer, you can read the instructions t p://thinkdast.com/explorer.\n\"id=\"mw-content-text\"\". We'll use this element id to identify e n text of each article we download."], ["example minimal HTML document DOCTYPE html html head title title body p Hello world result, HTML Document Object Model tree head title", "For example, here is a minimal HTML document:\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>This is a title</title>\n  </head>\n  <body>\n    <p>Hello world!</p>\n  </body>\n</html>\nThe result of parsing HTML is a Document Object Model tree, or\n\"<head>\" and\n\"<title>\", and the"], ["DOM tree, elements document g tags, data structure, text tags document elements relationships nodes, structure f", "**DOM tree**, that contains the elements of the document, g t and tags. The tree is a linked data structure made up of nodes; e s represent text, tags, and other document elements.\nThe relationships between the nodes are determined by the structure f e document. In the example above, the first node, called the\n**root**, is the \"<html>\" tag, h s links to the two nodes it contains,\n\"<body>\"; these nodes are the\nEach node contains links to its children; in addition, each e s a link to its **parent**, so from any node it is e o navigate up and down the tree. The DOM tree for real pages is y e complicated than this example."], ["node head, child body", "**children** of the root node.\nThe \"<head>\" node has one child,\n\"<body>\" node has one child,"], ["first paragraph main f article", "The element that's highlighted is the first paragraph of the main t f the article, which is contained in a"], ["div element", "\"<div>\" element with"], ["easy download parse web pages, DOM tree example String url http download parse document Connection conn url Document doc select content text pull paragraphs Element content Elements paragraphs p, URL String, method downloads HTML parses", "jsoup makes it easy to download and parse web pages, and to navigate the\nDOM tree. Here's an example:\n    String url = \"http://en.wikipedia.org/wiki/Java_(programming_language)\";\n    // download and parse the document\n    Connection conn = Jsoup.connect(url);\n    Document doc = conn.get();\n    // select the content text and pull out the paragraphs.\n    Element content = doc.getElementById(\"mw-content-text\");\n    Elements paragraphs = content.select(\"p\");\n\"Jsoup.connect\" takes a URL as a \"String\" and makes a connection o e web server; the \"get\" method downloads the HTML, parses it,"], ["returns Document object, DOM Document, e e, nodes fact, many methods n e", "and returns a \"Document\" object, which represents the DOM.\n\"Document\" provides methods for navigating e e and selecting nodes. In fact, it provides so many methods, it n e confusing. This example demonstrates two ways to select nodes:\n- \"getElementById\" takes a \"String\" and searches the tree for an\n  element that has a matching \"id\" field. Here it selects the node\n  \"<div id=\"mw-content-text\" lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">\",\n  which appears on every Wikipedia page to identify the\n  \"<div>\" element that contains the main\n  text of the page, as opposed to the navigation sidebar and other\n  elements.\n  The return value from \"getElementById\" is an \"Element\"\n  object that represents this \"<div>\" and\n  contains the elements in the \"<div>\" as\n  children, grandchildren, etc.\n- \"select\" takes a \"String\", traverses the tree, and returns all\n  the elements with tags that match the \"String\". In this example, it\n  returns all paragraph tags that appear in \"content\". The return\n  value is an \"Elements\" object."], ["skim documentation, know important classes", "Before you go on, you should skim the documentation of these classes o u know what they can do. The most important classes are"], ["Element Elements Node, node DOM tree l, Element TextNode DataNode Comment Elements Collection Element objects", "\"Element\", \"Elements\", and \"Node\", which you can read\n\"Node\" represents a node in the DOM tree;  there are l s that extend \"Node\", including\n\"Element\", \"TextNode\", \"DataNode\", and \"Comment\".\n\"Elements\" is a \"Collection\" of \"Element\" objects."], ["http http p", "http://thinkdast.com/jsoupelt,\nhttp://thinkdast.com/jsoupelts, d p://thinkdast.com/jsoupnode."], ["UML class diagram line hollow w, another example", "  In a UML class diagram, a line with a hollow w d indicates that one class extends another.  For example, s m indicates that \"Elements\" extends \"ArrayList\"."], ["UML diagrams", "We'll get back to UML diagrams in Section~\\ref{uml-class-diagrams}."], ["provide class", "To make your life easier, I provide a class called"], ["WikiNodeIterable lets, nodes WikiNodeIterable implements Iterable Node WikiNodeIterable performs, h nodes order, page example print Node", "\"WikiNodeIterable\" that lets you iterate through the nodes in a\n\"WikiNodeIterable\", which implements\n\"Iterable<Node>\".\n\"WikiNodeIterable\" performs a \"depth-first search\", h s the nodes in the order they would appear on the page.\nIn this example, we print a \"Node\" only if it is a"], ["DOM tree example shows, Elements paragraphs p Element firstPara, Iterable Node iter new WikiNodeIterable firstPara Node node iter node instanceof TextNode node TextNode ignore types Node e Element, represent tags, e n text HTML paragraph", "DOM tree. Here's an example that shows how to use it:\n    Elements paragraphs = content.select(\"p\");\n    Element firstPara = paragraphs.get(0);\n    Iterable<Node> iter = new WikiNodeIterable(firstPara);\n    for (Node node: iter) {\n        if (node instanceof TextNode) {\n            System.out.print(node);\n        }\n    }\n\"TextNode\" and ignore other types of \"Node\", y e \"Element\" objects that represent tags. The result is e n text of the HTML paragraph without any markup. The output is:"], ["selects e paragraph paragraphs creates", "This example picks up where the previous one leaves off. It selects e t paragraph in \"paragraphs\" and then creates a"], ["quote quote", "\\begin{quote}\n\\end{quote}"], ["Java computer", "Java is a general-purpose computer programming language that s t, class-based, object-oriented,{[}13{]} and y d ..."], ["several ways, tree h applications, search DFS DFS, root tree selects, e children selects", "There are several ways you might reasonably traverse a tree, each h t applications. We'll start with \"depth-first search\", or DFS.\nDFS starts at the root of the tree and selects the first child. If e d has children, it selects the first child again. When it gets to a e with no children, it backtracks, moving up the tree to the t e, where it selects the next child if there is one; otherwise t s again. When it has explored the last child of the root, it's e.\nThere are two common ways to implement DFS, recursively and iteratively.\ntraversal. You can read about \"pre-order\", \"post-order\", and\n\"in-order\" traversals at http://thinkdast.com/treetrav.  r s application, the traversal order doesn't matter.\n(http://thinkdast.com/callstack) to p k of the child nodes and process them in the right order. As n e, we can use a stack data structure to keep track of e s ourselves; if we do that, we can avoid the recursion and e e tree iteratively."], ["recursive implementation simple elegant private static void recursiveDFS Node node node instanceof TextNode node Node child recursiveDFS child method, every Node tree g h root Node, TextNode contents Node children, recursive calls, call stack", "The recursive implementation is simple and elegant:\nprivate static void recursiveDFS(Node node) {\n    if (node instanceof TextNode) {\n        System.out.print(node);\n    }\n    for (Node child: node.childNodes()) {\n        recursiveDFS(child);\n    }\n}\nThis method gets invoked on every \"Node\" in the tree, g h the root. If the \"Node\" it gets is a \"TextNode\", t s the contents. If the \"Node\" has any children, it invokes\nBy making recursive calls, \"recursiveDFS\" uses the call stack"], ["example print contents TextNode e g children example", "In this example, we print the contents of each \"TextNode\" e g the children, so this is an example of a \"pre-order\""], ["iterative version DFS, e stack data structure, general concept k, stack lowercase l, Java interfaces", "Before I explain the iterative version of DFS, I'll n e stack data structure.  We'll start with the general concept of a k, which I'll call a \"stack\" with a lowercase \"s\". Then we'l k about two Java \"interfaces\" that define stack methods:\n\"Stack\" and \"Deque\".\nA stack is a data structure that is similar to a list: it is a n that maintains the order of the elements. The y e between a stack and a list is that the stack provides r s. In the usual convention, it provides:\n- \"push\": which adds an element to the top of the stack.\n- \"pop\": which removes and returns the top-most element from the stack.\n- \"peek\": which returns the top-most element without modifying\n  the stack.\n- \"isEmpty\": which indicates whether the stack is empty.\nBecause \"pop\" always returns the top-most element, a stack s o called a \"LIFO\", which stands for \"last in, first out\". An e to a stack is a \"queue\", which returns elements in e e order they are added; that is, \"first in, first out\", or FIFO.\nIt might not be obvious why stacks and queues are useful: they don't e any capabilities that aren't provided by lists; in fact, y e fewer capabilities. So why not use lists for everything? e e two reasons:\n- If you limit yourself to a small set of methods --- that is, a small\n  API --- your code will be more readable and less error-prone. For\n  example, if you use a list to represent a stack, you might\n  accidentally remove an element in the wrong order. With the stack API,\n  this kind of mistake is literally impossible. And the best way to\n  avoid errors is to make them impossible.\n- If a data structure provides a small API, it is easier to implement\n  efficiently. For example, a simple way to implement a stack is a\n  singly-linked list. When we push an element onto the stack, we add it\n  to the beginning of the list; when we pop an element, we remove it\n  from the beginning. For a linked list, adding and removing from the\n  beginning are constant time operations, so this implementation is\n  efficient. Conversely, big APIs are harder to implement efficiently.\nTo implement a stack in Java, you have three options:\n- Go ahead and use \"ArrayList\" or \"LinkedList\". If you use\n  \"ArrayList\", be sure to add and remove from the end,\n  which is a constant time operation. And be careful not to add elements\n  in the wrong place or remove them in the wrong order.\n- Java provides a class called \"Stack\" that provides the standard\n  set of stack methods. But this class is an old part of Java: it is not\n  consistent with the Java Collections Framework, which came later.\n- Probably the best choice is to use one of the implementations of the\n  \"Deque\" interface, like \"ArrayDeque\"."], ["term Abstract Data Type", "% TODO: introduce the term \"Abstract Data Type\"?"], ["e deck people, deek Java", "\"Deque\" stands for \"double-ended queue\"; it's supposed to e d \"deck\", but some people say \"deek\". In Java, the"], ["Deque interface, push pop peek isEmpty use Deque stack", "\"Deque\" interface provides \"push\", \"pop\",\n\"peek\", and \"isEmpty\", so you can use a \"Deque\" s a stack. It provides other methods, which you can read about t p://thinkdast.com/deque,"], ["iterative version DFS, ArrayDeque stack Node, private static void iterativeDFS Node root Deque Node, new ArrayDeque Node root Node node node instanceof TextNode node List Node, new ArrayList Node", "Here is an iterative version of DFS that uses an \"ArrayDeque\" o t a stack of \"Node\" objects:\n    private static void iterativeDFS(Node root) {\n        Deque<Node> stack = new ArrayDeque<Node>();\n        stack.push(root);\n        while (!stack.isEmpty()) {\n            Node node = stack.pop();\n            if (node instanceof TextNode) {\n                System.out.print(node);\n            }\n            List<Node> nodes = new ArrayList<Node>(node.childNodes());\n            Collections.reverse(nodes);\n            for (Node child: nodes) {\n                stack.push(child);\n            }\n        }\n    }\nThe loop continues until the stack is empty. Each time through, it s a \"Node\" off the stack. If it gets a \"TextNode\", it s e contents. Then it pushes the children onto the stack. In order o s the children in the right order, we have to push them onto e k in reverse order; we do that by copying the children into an\nOne advantage of the iterative version of DFS is that it is easier o t as a Java \"Iterator\"; you'll see how in the t r.\n\"List\" variable, like this:\nList<Node> deque = new LinkedList<Node>();\nAnd if you assign it like this:\nLinkedList<Node> deque = new LinkedList<Node>();"], ["parameter root, e start", "The parameter, \"root\", is the root of the tree we want o e, so we start by creating the stack and pushing the root o t."], ["elements place g h", "\"ArrayList\", reversing the elements in place, and then g h the reversed \"ArrayList\"."], ["last note Deque interface n n ArrayDeque Java, another implementation implements interfaces List Deque h e, use example n LinkedList, Deqeue Node, new LinkedList Node use methods Deque interface l List interface assign", "But first, one last note about the \"Deque\" interface: n n to \"ArrayDeque\", Java provides another implementation of\nimplements both interfaces, \"List\" and \"Deque\". h e you get depends on how you use it. For example, if you n a \"LinkedList\" object to a \"Deque\" variable, like this:\nDeqeue<Node> deque = new LinkedList<Node>();\nyou can use the methods in the \"Deque\" interface, but not l s in the \"List\" interface. If you assign it to a"], ["Deque old friend LinkedList LinkedList", "\"Deque\", our old friend \"LinkedList\". \"LinkedList\""], ["use List methods Deque methods", "you can use \"List\" methods but not all \"Deque\" methods."], ["use methods, methods interfaces, readable e", "you can use all the methods. But if you combine methods m t interfaces, your code will be less readable and e r-prone."], ["repository book", "In the repository for this book,"], ["code help, previous chapter, recursive iterative implementations, DFS DOM tree, Iterable class", "you'll find some code to help you get started:\n- \"WikiNodeExample.java\" contains the code from the previous\n  chapter, demonstrating recursive and iterative implementations of\n  depth-first search (DFS) in a DOM tree.\n- \"WikiNodeIterable.java\" contains an \"Iterable\" class for\n  traversing a DOM tree. I'll explain this code in the next section.\n- \"WikiFetcher.java\" contains a utility class that uses jsoup to\n  download pages from Wikipedia. To help you comply with Wikipedia's\n  terms of service, this class limits how fast you can download pages;\n  if you request more than one page per second, it sleeps before\n  downloading the next page.\n- \"WikiPhilosophy.java\" contains an outline of the code you will\n  write for this exercise. We'll walk through it below.\n\"build.xml\".  If you run \"ant WikiPhilosophy\", it will n a simple bit of starter code."], ["Ant build file", "You'll also find the Ant build file"], ["previous chapter, iterative search", "In the previous chapter, I presented an iterative depth-first search"], ["advantage iterative version code, identical iterative version DFS w, methods constructor, ArrayDeque pushes, isEmpty checks", "(DFS), and suggested that an advantage of the iterative version,\nThis code is almost identical to the iterative version of DFS, but w t's split into three methods:\n- The constructor initializes the stack (which is implemented using an\n  \"ArrayDeque\") and pushes the root node onto it.\n- \"isEmpty\" checks whether the stack is empty.\n- \"next\" pops the next \"Node\" off the stack, pushes its\n  children in reverse order, and returns the \"Node\" it popped. If\n  someone invokes \"next\" on an empty \"Iterator\", it throws\n  an exception.\n\"Iterable\" is called for, which makes it easy and y n to separate the logic of the iteration (DFS) from r g we are doing on the nodes."], ["recursive version, worthwhile rewrite method, methods e e use WikiNodeIterable", "compared to the recursive version, is that it is easier to wrap in an\nIt might not be obvious that it is worthwhile to rewrite a y d method with two classes and five methods.  But now that we'e e it, we can use \"WikiNodeIterable\" anywhere an"], ["Iterator object section see familiar Iterator Iterable http Iterable Node interface e loop, Node root Iterable Node, new WikiNodeIterable root Node node iter visit node implementation, l constructor, stores reference root Node iterator method", "\"Iterator\" object. In this section we'll see how to do that.\nIf you are not familiar with the \"Iterator\" and \"Iterable\"\nhttp://thinkdast.com/iterable.\n\"Iterable<Node>\" interface  so we can e t in a for loop like this:\n    Node root = ...\n    Iterable<Node> iter = new WikiNodeIterable(root);\n    for (Node node: iter) {\n        visit(node);\n    }\nThe implementation of \"WikiNodeIterable\" follows a l a:\n- The constructor takes and stores a reference to the root\n  \"Node\".\n- The \"iterator\" method creates a returns an \"Iterator\"\n  object."], ["look contents, WikiNodeIterable implements, public class WikiNodeIterable implements Iterable Node private Node root public WikiNodeIterable Node root root Override public Iterator Node iterator, new WikiNodeIterator root inner class WikiNodeIterator real work private class WikiNodeIterator implements Iterator Node Deque Node, public WikiNodeIterator Node", "Take a look at the contents of \"WikiNodeIterable.java\". The r s, \"WikiNodeIterable\" implements the\nHere's what it looks like:\npublic class WikiNodeIterable implements Iterable<Node> {\n    private Node root;\n    public WikiNodeIterable(Node root) {\n        this.root = root;\n    }\n    @Override\n    public Iterator<Node> iterator() {\n        return new WikiNodeIterator(root);\n    }\n}\nThe inner class, \"WikiNodeIterator\", does all the real work:\n    private class WikiNodeIterator implements Iterator<Node> {\n        Deque<Node> stack;\n        public WikiNodeIterator(Node node) {\n            stack = new ArrayDeque<Node>();\n            stack.push(root);\n        }\n        @Override\n        public boolean hasNext() {\n            return !stack.isEmpty();\n        }\n        @Override\n        public Node next() {\n            if (stack.isEmpty()) {\n                throw new NoSuchElementException();\n            }\n            Node node = stack.pop();\n            List<Node> nodes = new ArrayList<Node>(node.childNodes());\n            Collections.reverse(nodes);\n            for (Node child: nodes) {\n                stack.push(child);\n            }\n            return node;\n        }\n    }"], ["root root tree", "where \"root\" is the root of the tree we want to traverse and"], ["visit method", "\"visit\" is a method that does whatever we want when we \"visit\""], ["write Web crawler, many pages, terms service, g help, provide class", "When you write a Web crawler, it is easy to download too many pages o t, which might violate the terms of service for the server you e g from. To help you avoid that, I provide a class called\n\"WikiFetcher\" that does two things:\n- It encapsulates the code we demonstrated in the previous chapter for\n  downloading pages from Wikipedia, parsing the HTML, and selecting the\n  content text.\n- It measures the time between requests and, if we don't leave enough\n  time between requests, it sleeps until a reasonable interval has\n  elapsed. By default, the interval is one second.\n\"WikiFetcher\" object and use it to handle all requests. If u e multiple instances of \"WikiFetcher\", they won't enforce e m interval between requests.\nNOTE: My implementation of \"WikiFetcher\" is simple, but it d e easy for someone to misuse it by creating multiple instances. u d avoid this problem by making \"WikiFetcher\" a \"singleton\","], ["definition WikiFetcher public class WikiFetcher private long lastRequestTime private long minInterval, list paragraph elements, url return, IOException public Elements, url throws IOException", "Here's the definition of \"WikiFetcher\":\npublic class WikiFetcher {\n    private long lastRequestTime = -1;\n    private long minInterval = 1000;\n    /**\n     * Fetches and parses a URL string,\n     * returning a list of paragraph elements.\n     *\n     * @param url\n     * @return\n     * @throws IOException\n     */\n    public Elements fetchWikipedia(String url) throws IOException {\n        sleepIfNeeded();\n        Connection conn = Jsoup.connect(url);\n        Document doc = conn.get();\n        Element content = doc.getElementById(\"mw-content-text\");\n        Elements paragraphs = content.select(\"p\");\n        return paragraphs;\n    }\n    private void sleepIfNeeded() {\n        if (lastRequestTime != -1) {\n            long currentTime = System.currentTimeMillis();\n            long nextRequestTime = lastRequestTime + minInterval;\n            if (currentTime < nextRequestTime) {\n                try {\n                    Thread.sleep(nextRequestTime - currentTime);\n                } catch (InterruptedException e) {\n                    System.err.println(\n                        \"Warning: sleep interrupted in fetchWikipedia.\");\n                }\n            }\n        }\n        lastRequestTime = System.currentTimeMillis();\n    }\n}\nThe only public method is \"fetchWikipedia\", which takes a URL s a \"String\" and returns an \"Elements\" collection that contains one\nThat's all there is to \"WikiFetcher\". Here's an example t s how it's used:\n    WikiFetcher wf = new WikiFetcher();\n    for (String url: urlList) {\n        Elements paragraphs = wf.fetchWikipedia(url);\n        processParagraphs(paragraphs);\n    }"], ["DOM element paragraph content text code k", "DOM element for each paragraph in the content text. This code d k familiar."], ["new code, checks time, last request sleeps", "The new code is in \"sleepIfNeeded\", which checks the time e e last request and sleeps if the elapsed time is less than"], ["minInterval milliseconds", "\"minInterval\", which is in milliseconds."], ["urlList collection", "In this example, we assume that \"urlList\" is a collection of"], ["processParagraphs method g h Elements", "\"String\"s, and \"processParagraphs\" is a method that does g h the \"Elements\" object returned by \"fetchWikipedia\"."], ["something important create", "This example demonstrates something important: you should create one"], ["read p", "which you can read about t p://thinkdast.com/singleton."], ["fundamental operation index lookup addition TermCounter, search terms, Index maps h term collection pages, e next question represent collection pages", "The fundamental operation of the index is a **lookup**;\nIn addition to the \"TermCounter\", which maps from search terms o s, we will define a class called \"Index\", which maps from a h term to a collection of pages where it appears. And that s e next question, which is how to represent a collection of pages."], ["Given search term, select ones, search term, proportional total number words pages, alternative map data structure collection pairs", "specifically, we need the ability to look up a term and find all s t contain it. The simplest implementation would be a collection f s. Given a search term, we could iterate through the contents of e s and select the ones that contain the search term. But the e d be proportional to the total number of words on all the pages,\nA better alternative is a **map**, which is a data structure t s a collection of **key-value pairs** and provides a t y to look up a **key** and find the corresponding **value**.\nwhich maps from each search term to the number of times it appears in a e. The keys are the search terms and the values are the counts (o d \"frequencies\").\nIn this case, we'll need to combine two or more collections and find e s that appear in all of them. You might recognize this operation as"], ["construct TermCounter HashSet TreeSet, data structures top l", "For example, the first map we'll construct is a \"TermCounter\",\n\"HashSet\" and \"TreeSet\".\nNow that we've designed our data structures from the top down, we'l t them from the inside out, starting with \"TermCounter\"."], ["Map specifies, important get key method, key returns, key value method, new pair Map key", "Java provides an interface called \"Map\" that specifies e s a map should provide; the most important are:\n- \"get(key)\": This method looks up a key and returns the\n  corresponding value.\n- \"put(key, value)\": This method adds a new key-value pair to the\n  \"Map\", or if the key is already in the map, it replaces the\n  value associated with \"key\".\nJava provides several implementations of \"Map\", including the o e will focus on, \"HashMap\" and \"TreeMap\". In g s, we'll look at these implementations and analyze their performance.\nAs you might expect by now, Java provides a \"Set\" interface t s the operations a set should perform. It doesn't actually e t intersection, but it provides methods that make it possible o t intersection and other set operations efficiently. The core\nJava provides several implementations of \"Set\", including"], ["perform r decision", "Again, if we think about the operations we want to perform, that s r decision."], ["intersection intersection, f appear", "**set intersection**: the intersection of two sets is the set f s that appear in both."], ["Set methods, element method, element method checks, element set", "\"Set\" methods are:\n- \"add(element)\": This method adds an element to a set; if the\n  element is already in the set, it has no effect.\n- \"contains(element)\": This method checks whether the given\n  element is in the set."], ["TermCounter class, h number times, page class definition public class TermCounter private Map String Integer, private String label public TermCounter String label, new HashMap String Integer instance variables", "\"TermCounter\" is a class that represents a mapping from h s to the number of times they appear in a page. Here is the t t of the class definition:\npublic class TermCounter {\n    private Map<String, Integer> map;\n    private String label;\n    public TermCounter(String label) {\n        this.label = label;\n        this.map = new HashMap<String, Integer>();\n    }\n}\nThe instance variables are \"map\", which contains the mapping m s to counts, and \"label\", which identifies the document e s came from; we'll use it to store URLs.\n\"TermCounter\" provides \"put\" and \"get\", which e d like this:\n    public void put(String term, int count) {\n        map.put(term, count);\n    }\n    public Integer get(String term) {\n        Integer count = map.get(term);\n        return count == null ? 0 : count;\n    }\n\"put\" on a \"TermCounter\", it calls \"put\" on e d map.\n\"get\" on a \"TermCounter\", it calls \"get\" on e p, and then checks the result. If the term does not appear in e p, \"TermCount.get\" returns 0. Defining \"get\" this y s it easier to write \"incrementTermCount\", which takes a m d increases by one the counter associated with that term.\n    public void incrementTermCount(String term) {\n        put(term, get(term) + 1);\n    }\nIn addition, \"TermCounter\" provides these other methods to p h indexing Web pages:\n    public void processElements(Elements paragraphs) {\n        for (Node node: paragraphs) {\n            processTree(node);\n        }\n    }\n    public void processTree(Node root) {\n        for (Node node: new WikiNodeIterable(root)) {\n            if (node instanceof TextNode) {\n                processText(((TextNode) node).text());\n            }\n        }\n    }\n    public void processText(String text) {\n        String[] array = text.replaceAll(\"\\\\pP\", \" \").\n                              toLowerCase().\n                              split(\"\\\\s+\");\n        for (int i=0; i<array.length; i++) {\n            String term = array[i];\n            incrementTermCount(term);\n        }\n    }\n- \"processElements\" takes an \"Elements\" object, which is a\n  collection of jsoup \"Element\" objects. It iterates through the\n  collection and calls \"processTree\" on each.\n- \"processTree\" takes a jsoup \"Node\" that represents the\n  root of a DOM tree. It iterates through the tree to find the nodes\n  that contain text; then it extracts the text and passes it to\n  \"processText\".\n- \"processText\" takes a \"String\" that contains words, spaces,\n  punctuation, etc. It removes punctuation characters by replacing\n  them with spaces, converts the remaining letters to lowercase, then\n  splits the text into words. Then it loops through the words it found\n  and calls \"incrementTermCount\" on each.  The \"replaceAll\"\n  and \"split\" methods take **regular expressions** as parameters;\n  you can read more about them at http://thinkdast.com/regex.\nFinally, here's an example that demonstrates how \"TermCounter\" s d:\n    String url = \"http://en.wikipedia.org/wiki/Java_(programming_language)\";\n    WikiFetcher wf = new WikiFetcher();\n    Elements paragraphs = wf.fetchWikipedia(url);\n    TermCounter counter = new TermCounter(url);\n    counter.processElements(paragraphs);\n    counter.printCounts();\n\"TermCounter\" and uses it to count the words in the page."], ["chose HashMap Map Coming chapters, w works common choice use, new pair map e, old count, new count replaces old value", "To implement the mapping, I chose \"HashMap\", which is the t y-used \"Map\". Coming up in a few chapters, you will see w t works and why it is a common choice.\nthen use \"put\" to add a new key-value pair to the map. If e m is already in the map, we get the old count, add 1, and then e e new count, which replaces the old value."], ["method call", "\"put\" is just a **wrapper method**; when you call"], ["WikiFetcher download page parse main text creates", "This example uses a \"WikiFetcher\" to download a page m a and parse the main text. Then it creates a"], ["next section chance run code test r g", "In the next section, you'll have a chance to run this code and test r g by filling in a missing method."], ["usual provide starter code fill g, MyLinearMap n public class MyLinearMap K V implements Map K V private List Entry, new ArrayList Entry MyLinearMap implements Map, e methods Map interface MyLinearMap, single instance variable much Entry container value definition", "As usual, I provide starter code and you will fill in the g s. Here's the beginning of the \"MyLinearMap\" s n:\npublic class MyLinearMap<K, V> implements Map<K, V> {\n    private List<Entry> entries = new ArrayList<Entry>();\n\"MyLinearMap\" implements \"Map\", which means it has o e the methods in the \"Map\" interface.\nA \"MyLinearMap\" object has a single instance variable,\nThere's not much to it; an \"Entry\" is just a container for a y d a value. This definition is nested inside \"MyLinearList\", o t uses the same type parameters, \"K\" and \"V\"."], ["type parameters K type f e keys V type values, pair e n public class Entry implements K V private K key private V value public Entry K key V value, value Override public K getKey, key Override public V getValue return value", "This class uses two type parameters, \"K\", which is the type f e keys, and \"V\", which is the type of the values.\nobjects. Each \"Entry\" contains a key-value pair. Here is e n:\n    public class Entry implements Map.Entry<K, V> {\n        private K key;\n        private V value;\n        public Entry(K key, V value) {\n            this.key = key;\n            this.value = value;\n        }\n        @Override\n        public K getKey() {\n            return key;\n        }\n        @Override\n        public V getValue() {\n            return value;\n        }\n    }"], ["need exercise", "That's all you need to do the exercise, so let's get started."], ["section present solution previous exercise e performance core methods summary core methods, n MyLinearMap, number entries, n Map core methods, time first hear", "In this section I present a solution to the previous exercise d e the performance of the core methods.  Here are\nIn summary, the core methods are all linear, which is why we called s n \"MyLinearMap\" (ta-da!).\nIf we know that the number of entries will be small, this n t be good enough, but we can do better. In fact, there is n n of \"Map\" where all of the core methods e t time. When you first hear that, it might not seem possible.\nIn the next chapter, I'll present a solution, analyze the e f the core \"Map\" methods, and introduce a more t n."], ["findEntry equals private Entry findEntry Object target Entry entry entries, return entry, null private boolean equals Object target Object, target null return obj null return, remove look", "\"findEntry\" and \"equals\":\nprivate Entry findEntry(Object target) {\n    for (Entry entry: entries) {\n        if (equals(target, entry.getKey())) {\n            return entry;\n        }\n    }\n    return null;\n}\nprivate boolean equals(Object target, Object obj) {\n    if (target == null) {\n        return obj == null;\n    }\n    return target.equals(obj);\n}\nincluding \"put\", \"get\", and \"remove\". Here's t y look like:\npublic V put(K key, V value) {\n    Entry entry = findEntry(key);\n    if (entry == null) {\n        entries.add(new Entry(key, value));\n        return null;\n    } else {\n        V oldValue = entry.getValue();\n        entry.setValue(value);\n        return oldValue;\n    }\n}\npublic V get(Object key) {\n    Entry entry = findEntry(key);\n    if (entry == null) {\n        return null;\n    }\n    return entry.getValue();\n}\npublic V remove(Object key) {\n    Entry entry = findEntry(key);\n    if (entry == null) {\n        return null;\n    } else {\n        V value = entry.getValue();\n        entries.remove(entry);\n        return value;\n    }\n}"], ["runtime equals, size target keys, n e number entries equals constant time", "The runtime of \"equals\" might depend on the size of the\n\"target\" and the keys, but does not generally depend n e number of entries, n. So \"equals\" is constant time."], ["key g r, general r f entries, proportional n, needle k constant time, big haystack c", "In \"findEntry\", we might get lucky and find the key we're g r at the beginning, but we can't count on it. In general, the r f entries we have to search is proportional to n, so\n\"findEntry\" is linear.\nWhat we are saying, in effect, is that you can find a needle in a k in constant time, regardless of how big the haystack is. It's c."], ["core methods MyLinearMap use findEntry", "Most of the core methods in \"MyLinearMap\" use \"findEntry\","], ["findEntry everything, Remember entries ArrayList g n element end constant time average key map, entry call, element e g middle ArrayList, linear operations", "After \"put\" calls \"findEntry\", everything else is t e. Remember that \"entries\" is an \"ArrayList\", so g n element at the end is constant time, on average. If the key s y in the map, we don't have to add an entry, but we have to call\n\"entries.remove\" might have to remove an element from e g or middle of the \"ArrayList\", and that takes r e. But that's OK: two linear operations are still linear.\nI'll explain how it works in two steps:\n- Instead of storing entries in one big \"List\", we'll break them\n  up into lots of short lists. For each key, we'll use a \\textbf{hash\n  code} (explained in the next section) to determine which list to use.\n- Using lots of short lists is faster than using just one, but as I'll\n  explain, it doesn't change the order of growth; the core operations\n  are still linear. But there is one more trick: if we increase the\n  number of lists to limit the number of entries per list, the result is\n  a constant-time map. You'll see the details in the next exercise, but\n  first: hashing!"], ["h time, linear reasoning get", "\"entry.getValue\" and \"entry.setValue\", and those are h t time. Putting it all together, \"put\" is linear.\nBy the same reasoning, \"get\" is also linear."], ["performance MyLinearMap write w, collection MyLinearMap, divides keys, number entries, class definition public class MyBetterMap K V implements Map K V", "To improve the performance of \"MyLinearMap\", we'll write a w s, called \"MyBetterMap\", that contains a collection of\n\"MyLinearMap\" objects. It divides the keys among the d s, so the number of entries in each map is smaller, which speeds up\nHere's the beginning of the class definition:\npublic class MyBetterMap<K, V> implements Map<K, V> {\n    protected List<MyLinearMap<K, V>> maps;\n    public MyBetterMap(int k) {\n        makeMaps(k);\n    }\n    protected void makeMaps(int k) {\n        maps = new ArrayList<MyLinearMap<K, V>>(k);\n        for (int i=0; i<k; i++) {\n            maps.add(new MyLinearMap<K, V>());\n        }\n    }\n}\n\"MyLinearMap\" objects. The constructor takes a parameter,\n\"MyBetterMap\" are k times shorter than the entry list in\n\"MyLinearMap\", we expect the search to be k s r. But the runtime is still proportional to n, so\n\"MyBetterMap\" is still linear. In the next exercise, you'll see how e n fix that."], ["findEntry methods", "\"findEntry\" and the methods that depend on it."], ["instance variable maps collection ArrayList Java every Object", "The instance variable, \"maps\", is a collection of\n\"ArrayList\".\nIn Java, every \"Object\" provides a method called"], ["many maps, work need way, embedded maps, new key, random p k", "\"k\", that determines how many maps to use, at least initially.\nNow, the key to making this work is that we need some way to look at a y and decide which of the embedded maps it should go into. When we\n\"put\" a new key, we choose one of the maps; when we \"get\"\nOne possibility is to choose one of the sub-maps at random and p k of where we put each key. But how should we keep track? It t m like we could use a \"Map\" to look up the key and find e t sub-map, but the whole point of the exercise is to write n t implementation of a \"Map\". We can't assume we y e one.\nthen use the remainder operator, \"\\%\", which guarantees that e t is between 0 and \"maps.size()-1\". So \"index\" s s a valid index into \"maps\". Then \"chooseMap\" s a reference to the map it chose.\nWe use \"chooseMap\" in both \"put\" and \"get\", so n e look up a key, we get the same map we chose when we added the key. At t, we should --- I'll explain a little later why this might t k.\nIf there are n entries split up among k sub-maps,\nthere will be n/k entries per map, on average. When we look p a key, we have to compute its hash code, which takes some time, then e h the corresponding sub-map."], ["makeMaps creates, maps stores, simple right methods, chooseMap e", "Then \"makeMaps\" creates the embedded maps and stores them in an\nPretty simple, right? In both methods, we use \"chooseMap\" to d e right sub-map and then invoke a method on the sub-map."], ["approach use hash function, hash code Importantly, hash code way, e hash code store, hash code e k hashCode", "A better approach is to use a **hash function**, which takes an\n**hash code**.  Importantly, if it sees the same \"Object\"\nmore than once, it always returns the same hash code. That way, if e e the hash code to store a key, we'll get the same hash code when e k it up.\n\"hashCode\" that computes a hash function. The implementation f s method is different for different objects; we'll see an e n.\narbitrarily. Otherwise we use \"hashCode\" to get an integer,"], ["Object Object returns integer", "\"Object\", any \"Object\", and returns an integer called a"], ["helper method chooses, MyLinearMap K V chooseMap Object key int index, key null index, public V, K key V value MyLinearMap K V map chooseMap key return key value public V get Object key MyLinearMap K V map chooseMap key return key", "Here's a helper method that chooses the right sub-map for a n key:\nprotected MyLinearMap<K, V> chooseMap(Object key) {\n    int index = 0;\n    if (key != null) {\n        index = Math.abs(key.hashCode()) % maps.size();\n    }\n    return maps.get(index);\n}\nIf \"key\" is \"null\", we choose the sub-map with index 0,\nHere's my implementation of \"put\" and \"get\":\npublic V put(K key, V value) {\n  MyLinearMap<K, V> map = chooseMap(key);\n    return map.put(key, value);\n}\npublic V get(Object key) {\n    MyLinearMap<K, V> map = chooseMap(key);\n    return map.get(key);\n}"], ["entry lists", "Because the entry lists in"], ["fundamental requirement hash function, hash code every time immutable objects, use show class e hash function Override public boolean equals, Override public int hashCode int, int total return total hashCode important order work", "The fundamental requirement for a hash function is that the same t d produce the same hash code every time. For immutable objects,\n\"SillyString\", but I'll use it to show how a class can e s own hash function:\n    @Override\n    public boolean equals(Object other) {\n        return this.toString().equals(other.toString());\n    }\n    @Override\n    public int hashCode() {\n        int total = 0;\n        for (int i=0; i<innerString.length(); i++) {\n            total += innerString.charAt(i);\n        }\n        return total;\n    }\n\"hashCode\". This is important. In order to work properly,\n\"equals\" has to be consistent with \"hashCode\", which s t if two objects are considered equal --- that is, \"equals\"\nreturns \"true\" --- they should have the same hash code. But s t only works one way; if two objects have the same hash code,\n\"hashCode\" works by iterating through the characters in the\nThis hash function satisfies the requirement: if two\nthey will get the same hash code.\nbecause it returns the same hash code for many different strings. If o s contain the same letters in any order, they will have the e h code. And even if they don't contain the same letters, they t d the same total, like \"\"ac\"\" and \"\"bb\"\".\nIf many objects have the same hash code, they end up in the e b-map.  If some sub-maps have more entries than others, the p n we have k maps might be much less than k. So one of the s f a hash function is to be uniform; that is, it should be y y to produce any value in the range.  You can read more t g good hash functions t p://thinkdast.com/hash."], ["easy objects mutable state k example immutable object define class", "that's relatively easy. For objects with mutable state, we have to k r.\nAs an example of an immutable object, I'll define a class called"], ["public class, public SillyString String, public String, Notice SillyString, objects equal f r", "\"SillyString\" that encapsulates a \"String\":\npublic class SillyString {\n    private final String innerString;\n    public SillyString(String innerString) {\n        this.innerString = innerString;\n    }\n    public String toString() {\n        return innerString;\n    }\nNotice that \"SillyString\" overrides both \"equals\" and\n\"innerString\". So two \"SillyString\" objects are equal f r \"innerString\" instance variables are equal.\n\"SillyString\" objects contain embedded strings that are equal,"], ["class useful", "This class is not very useful, which is why it's called"], ["add character int Java, character integer, Unicode code point", "\"String\" and adding them up. When you add a character to an \"int\",\nJava converts the character to an integer using its Unicode code point."], ["anything Unicode, curious read", "You don't need to know anything about Unicode to understand s e, but if you are curious, you can read more at"], ["good performance", "This works correctly, but it might not yield good performance,"], ["immutable SillyString, final u e, different String, code let, mutable object n r SillyArray identical SillyString", "\"String\"s are immutable, and \"SillyString\" is also e e \"innerString\" is declared to be \"final\". Once u e a \"SillyString\", you can't make \"innerString\" r o a different \"String\", and you can't modify the \"String\" t s to. Therefore, it will always have the same hash code.\nBut let's see what happens with a mutable object. Here's a n r \"SillyArray\", which is identical to \"SillyString\",\nexcept that it uses an array of characters instead of a \"String\":\npublic class SillyArray {\n    private final char[] array;\n    public SillyArray(char[] array) {\n        this.array = array;\n    }\n    public String toString() {\n        return Arrays.toString(array);\n    }\n    @Override\n    public boolean equals(Object other) {\n        return this.toString().equals(other.toString());\n    }\n    @Override\n    public int hashCode() {\n        int total = 0;\n        for (int i=0; i<array.length; i++) {\n            total += array[i];\n        }\n        System.out.println(total);\n        return total;\n    }\n\"SillyArray\" also provides \"setChar\", which makes t e to modify the characters in the array:\npublic void setChar(int i, char c) {\n    this.array[i] = c;\n}\nthe hash code after the mutation is 441. With a different hash code,\nIn general, it is dangerous to use mutable objects as keys in a s that use hashing, which includes \"MyBetterMap\" and"], ["suppose create SillyArray, map SillyArray, new SillyArray Word1, hash code array, modify contents", "Now suppose we create a \"SillyArray\" and add it to a map:\nSillyArray array1 = new SillyArray(\"Word1\".toCharArray());\nmap.put(array1, 1);\nThe hash code for this array is 461. Now if we modify the contents f e array and then try to look it up, like this:\narray1.setChar(0, 'C');\nInteger value = map.get(array1);"], ["good chance, wrong e, map HashMap guarantee keys, map changes, h e", "there's a good chance we'll go looking in the wrong sub-map. In t e, we won't find the key, even though it is in the map. And that's d.\n\"HashMap\". If you can guarantee that the keys won't be d e they are in the map, or that any changes won't affect the h e, it might be OK. But it is probably a good idea to avoid it."], ["number entries, proportional k, proportion n several core Suppose initial number k, much work, keys basic unit work count number f hash key", "If the number of entries in the biggest sub-map is proportional o n/k, and k grows in proportion to n, several of the core\nSuppose the initial number of sub-maps, k, is 2, and the d r is 1. Now let's see how much work it takes to \"put\" a s of keys. As the basic \"unit of work\", we'll count the number f s we have to hash a key and add it to a sub-map.\nThis diagram also shows why it is important to double the number f b-maps, k, when we rehash. If we only add to k d of multiplying, the towers would be too close together d y would start piling up. And that would not be t e."], ["MyBetterMap methods, constant time public boolean containsKey Object target MyLinearMap K V map chooseMap target, target public V get Object key MyLinearMap K V map chooseMap key return key public V, Object key MyLinearMap K V map chooseMap key return key method hashes key constant time invokes constant time", "\"MyBetterMap\" methods become constant time:\n    public boolean containsKey(Object target) {\n        MyLinearMap<K, V> map = chooseMap(target);\n        return map.containsKey(target);\n    }\n    public V get(Object key) {\n        MyLinearMap<K, V> map = chooseMap(key);\n        return map.get(key);\n    }\n    public V remove(Object key) {\n        MyLinearMap<K, V> map = chooseMap(key);\n        return map.remove(key);\n    }\nEach method hashes a key, which is constant time, and then invokes a d on a sub-map, which is constant time."], ["good core method, r analyze rehash constant time linear way similar reason, e time average series invocations first time call, unit work e, unit third time rehash", "So far, so good. But the other core method, \"put\", is a e r to analyze. When we don't have to rehash, it is constant time,\nbut when we do, it's linear. In that way, it's similar to\nFor the same reason, \"MyHashMap.put\" turns out to e t time if we average over a series of invocations.\nThe first time we call \"put\" it takes 1 unit of work. The d e also takes 1 unit. The third time we have to rehash, so it takes 2\nwhich shows that the average work per \"put\" is about 2 units. d t means that \"put\" is constant time on average."], ["amortized analysis", "Again, the argument is based on amortized analysis"], ["unit hash new key size hash table, next time call, unit work next time h, new key", "units to rehash the existing keys and 1 unit to hash the new key.\nNow the size of the hash table is 4, so the next time we call\n\"put\", it takes 1 unit of work. But the next time we have o h, which takes 4 units to rehash the existing keys and 1 unit o h the new key."], ["knock towers, e e, tower result uniform height", "As the arrows suggest, if we knock down the towers, each one fills e e before the next tower. The result is a uniform height of 2 units,"], ["containsKey get", "We've shown that \"containsKey\", \"get\", and \"remove\""], ["constant time, constant time, minute appreciate remarkable e e operations, much matter w g hash table Well sort Remember analysis, simple model n e unit work", "are constant time, and \"put\" is constant time on average. We d take a minute to appreciate how remarkable that is. e e of these operations is pretty much the same no matter w g the hash table is. Well, sort of.\nRemember that our analysis is based on a simple model of n e each \"unit of work\" takes the same amount of time. l s are more complicated than that. In particular, they e y fastest when working with data structures small enough to fit n e; somewhat slower if the structure doesn't fit in cache but l s in memory; and much slower if the structure doesn't fit n y."], ["Another limitation implementation, p f, key containsValue, search e, efficient way", "Another limitation of this implementation is that hashing doesn't p f we are given a value rather than a key: \"containsValue\" s r because it has to search all of the sub-maps. And e s no particularly efficient way to look up a value and find e g key (or possibly keys)."], ["limitation methods, linear example public void clear int", "And there's one more limitation: some of the methods that were t e in \"MyLinearMap\" have become linear. For example:\n    public void clear() {\n        for (int i=0; i<maps.size(); i++) {\n            maps.get(i).clear();\n        }\n    }"], ["clear clear number f proportional n", "\"clear\" has to clear all of the sub-maps, and the number f b-maps is proportional to n, so it's linear. Fortunately,"], ["next section track error x confirm, constant time", "Before we go on, we should check whether \"MyHashMap.put\" is y t time.\nBefore you read the next section, you should track down the error, x t, and confirm that \"put\" is now constant time, as expected."], ["build compile e, ant ProfileMapPut measures", "Run \"ant build\" to compile the e s. Then run \"ant ProfileMapPut\". It measures the runtime of"], ["Java range problem, Java HashMap Run, endMillis find range f, runtimes milliseconds", "\"HashMap.put\" (provided by Java) with a range of problem sizes,\n\"MyHashMap\", instead of Java's \"HashMap\". Run e r again and see if the slope is near 1. You might have o t \"startN\" and \"endMillis\" to find a range f m sizes where the runtimes are more than a few milliseconds, t t more than a few thousand."], ["versus problem size scale n constant time total time n linear result, line slope, ran code, analysis get something", "and plots runtime versus problem size on a log-log scale. If s n is constant time, the total time for n s d be linear, so the result should be a straight line with slope\n1. When I ran this code, the estimated slope was close to 1, which s t with our analysis. You should get something similar."], ["Modify profiles implementation", "Modify \"ProfileMapPut.java\" so it profiles your implementation,"], ["ran code", "When I ran this code, I got a surprise: the slope was about 1.7,"], ["suggests implementation constant time", "which suggests that this implementation is not constant time after all."], ["contains performance bug", "It contains a \"performance bug\"."], ["problem MyHashMap size MyBetterMap public int size int, MyLinearMap K V map maps, class definition public class MyFixedHashMap K V, MyHashMap K V implements Map K V private int size, public void clear size", "The problem with \"MyHashMap\" is in \"size\", which s d from \"MyBetterMap\":\n    public int size() {\n        int total = 0;\n        for (MyLinearMap<K, V> map: maps) {\n            total += map.size();\n        }\n        return total;\n    }\n\"MyFixedHashMap.java\".  Here's the beginning of the class definition:\npublic class MyFixedHashMap<K, V> extends MyHashMap<K, V> implements Map<K, V> {\n    private int size = 0;\n    public void clear() {\n        super.clear();\n        size = 0;\n    }\nRather than modify \"MyHashMap\", I define a new class t s it. It adds a new instance variable, \"size\", which s d to zero.\n\"size\".\nUpdating \"remove\" and \"put\" is a little more t e when we invoke the method on the superclass, we can't l r the size of the sub-map changed. Here's how I worked d t:\n    public V remove(Object key) {\n        MyLinearMap<K, V> map = chooseMap(key);\n        size -= map.size();\n        V oldValue = map.remove(key);\n        size += map.size();\n        return oldValue;\n    }\n\"size\" is correct.\nWe have the same problem here: when we invoke \"put\" on e b-map, we don't know whether it added a new entry. So we use the e n, subtracting off the old size and then adding in the new size.\nNow the implementation of the \"size\" method is simple:\n    public int size() {\n        return size;\n    }"], ["total size iterate, number k number entries, size invokes, finds key either way, w e", "To add up the total size it has to iterate the sub-maps. Since e e the number of sub-maps, k, as the number of entries,\n\"remove\" uses \"chooseMap\" to find the right sub-map, n s away the size of the sub-map. It invokes \"remove\" n e sub-map, which may or may not change the size of the sub-map,\ndepending on whether it finds the key. But either way, we add the w e of the sub-map back to \"size\", so the final value of"], ["n increases, proportional n, total time g n keys", "n, increases, k is proportional to n, so\nWhen I profiled this solution, I found that the total time for g n keys is proportional to n, which means that each \"put\" s t time, as it's supposed to be."], ["linear uses size public V, K key V value V, key value size FACTOR rehash return oldValue size linear", "\"size\" is linear.\nAnd that makes \"put\" linear, too, because it uses \"size\":\n    public V put(K key, V value) {\n        V oldValue = super.put(key, value);\n        if (size() > maps.size() * FACTOR) {\n            rehash();\n        }\n        return oldValue;\n    }\n\"size\" is linear!"], ["constant time, constant time", "Everything we did to make \"put\" constant time is wasted if\nAnd that's pretty clearly constant time."], ["simple solution, number entries instance variable update r call method changes", "Fortunately, there is a simple solution, and we have seen it before: e e to keep the number of entries in an instance variable and update t r we call a method that changes it."], ["solution repository book", "You'll find my solution in the repository for this book, in"], ["clear straightforward invoke clear n e superclass", "Updating \"clear\" is straightforward; we invoke \"clear\" n e superclass (which clears the sub-maps), and then update"], ["rewritten version, similar public V, K key V value MyLinearMap K V map chooseMap key size V, key value size size FACTOR size, rehash return oldValue", "The rewritten version of \"put\" is similar:\n    public V put(K key, V value) {\n        MyLinearMap<K, V> map = chooseMap(key);\n        size -= map.size();\n        V oldValue = map.put(key, value);\n        size += map.size();\n        if (size() > maps.size() * FACTOR) {\n            size = 0;\n            rehash();\n        }\n        return oldValue;\n    }"], ["code chapter, l classes, e classes MyLinearMap, LinkedList implements Map MyBetterMap, many MyLinearMap", "One challenge of working with the code in this chapter is that we e l classes that depend on each other. Here are some of e s between the classes:\n- \"MyLinearMap\" contains a \"LinkedList\" and implements\n  \"Map\".\n- \"MyBetterMap\" contains many \"MyLinearMap\" objects and\n  implements \"Map\".\n- \"MyHashMap\" extends \"MyBetterMap\", so it also contains\n  \"MyLinearMap\" objects, and it implements \"Map\".\n- \"MyFixedHashMap\" extends \"MyHashMap\" and\n  implements \"Map\".\nDifferent relationships are represented by different arrows:\n- Arrows with a solid head indicate HAS-A relationships. For example,\n  each instance of \"MyBetterMap\" contains multiple instances of\n  \"MyLinearMap\", so they are connected by a solid arrow.\n- Arrows with a hollow head and a solid line indicate IS-A\n  relationships. For example, \"MyHashMap\" extends\n  \"MyBetterMap\", so they are connected by an IS-A arrow.\n- Arrows with a hollow head and a dashed line indicate that a class\n  implements an interface; in this diagram, every class implements\n  \"Map\"."], ["track relationships, software n use UML class diagrams UML, Unified g e class, several graphical standards, UML UML class diagrams", "To help keep track of relationships like these, software s n use **UML class diagrams**. UML stands for Unified g e\nA \"class diagram\" is one of several graphical standards defined by UML.\nUML class diagrams provide a concise way to represent a lot f n about a collection of classes. They are used during n s to communicate about alternative designs, during n s to maintain a shared mental map of the project, and g t to document the design."], ["class diagram class, box classes", "In a class diagram, each class is represented by a box, d s between classes are represented y s. me/."], ["point familiar Map interface e HashMap implementation, r n Map, hash table understand HashMap, core methods performance HashMap, implementation Map reasons", "At this point you should be familiar with the \"Map\" interface d e \"HashMap\" implementation provided by Java. And by making r n \"Map\" using a hash table, you should understand how\n\"HashMap\" works and why we expect its core methods to be t e.\nBecause of this performance, \"HashMap\" is widely used, but it s t the only implementation of \"Map\". There are a few reasons u t want another implementation:\n- Hashing can be slow, so even though \"HashMap\" operations are\n  constant time, the \"constant\" might be big.\n- Hashing works well if the hash function distributes the keys evenly\n  among the sub-maps.  But designing good hash functions is not easy,\n  and if too many keys end up in the same sub-map, the performance of\n  the \"HashMap\" may be poor.\n- The keys in a hash table are not stored in any particular order; in\n  fact, the order might change when the table grows and the keys are\n  rehashed. For some applications, it is necessary, or at least useful,\n  to keep the keys in order.\nIt is hard to solve all of these problems at the e e, but Java provides an implementation called \"TreeMap\" t s close:\n- It doesn't use a hash function, so it avoids the cost of hashing\n  and the difficulty of choosing a hash function.\n- Inside the \"TreeMap\", the keys are are stored in a\n  **binary search tree**, which makes it possible to traverse the\n  keys, in order, in linear time.\n- The runtime of the core methods is proportional to log n,\n  which is not quite as good as constant time, but it is still\n  very good.\nIn the next section, I'll explain how binary search trees work and then u l use one to implement a \"Map\". Along the way, we'll e e performance of the core map methods when implemented using a tree."], ["binary search tree BST tree node, key node BST property node, child keys, key node node right child keys right subtree, key node figure Wikipedia page binary search trees", "A binary search tree (BST) is a tree where each node contains a key, d y \"node\" has the \"BST property\":\n- If \"node\" has a left child, all keys in the left subtree must\n  be less than the key in \"node\".\n- If \"node\" has a right child, all keys in the right subtree must\n  be greater than the key in \"node\".\nThis figure is from the Wikipedia page on binary search trees t p://thinkdast.com/bst, which u t find useful while you work on this exercise.\nThe key in the root is 8, and you can confirm that all keys to the t f the root are less than 8, and all keys to the right are greater. u n also check that the other nodes have this property.\nLooking up a key in a binary search tree is fast because we don't e o search the entire tree. Starting at the root, we can use e g algorithm:\n- Compare the key you are looking for, \"target\", to the key in\n  the current node. If they are equal, you are done.\n- If \"target\" is less than the current key, search the left tree.\n  If there isn't one, \"target\" is not in the tree.\n- If \"target\" is greater than the current key, search the right\n  tree. If there isn't one, \"target\" is not in the tree.\nAt each level of the tree, you only have to search one child. r e, if you look for \"target = 4\" in the previous diagram,\neven though the tree contains nine keys. In general, the number f s is proportional to the height of the tree, not the number f s in the tree.\nSo we expect that we can look up a key in a binary search tree in e l to log n. This is true if the tree is full, d n if the tree is only partially full. But it is not always true, s e will see."], ["start root, e key", "you start at the root, which contains the key \"8\". Because\n\"target\" is less than \"6\", you go left. And then you d e key you are looking for."], ["right example", "\"target\" is less than \"8\", you go left. Because\n\"target\" is greater than \"3\" you go right. Because\nIn this example, it takes four comparisons to find the target,"], ["relationship height e e h number nodes, pattern number levels, nodes total number nodes h levels, logarithm base, sides n h means", "So what can we say about the relationship between the height of e e, \"h\", and the number of nodes, n? Starting l d working up:\n- If \"h=1\", the tree only contains one node, so \"n=1\".\n- If \"h=2\", we can add two more nodes, for a total of\n  \"n=3\".\n- If \"h=3\", we can add up to four more nodes, for a total\n  of \"n=7\".\n- If \"h=4\", we can add up to eight more nodes, for a total\n  of \"n=15\".\nBy now you might see the pattern. If we number the levels of the tree from\n2^{i-1} nodes. And the total number of nodes in \"h\" levels is 2^h-1.\nIf we have n = 2^h - 1, we can take the logarithm base 2 of both sides: log_2 n ≈ h, which means that the height of the tree is proportional o g n, if the tree is full; that is, if each level contains e m number of nodes.\nO(log n)."], ["h level index", "\"1\" to \"h\", the level with index \"i\" can have up to"], ["time proportional log n, logarithmic log time belongs order growth", "An algorithm that takes time proportional to log n is called\n\"logarithmic\" or \"log time\", and it belongs to the order of growth"], ["repository book, source files, previous section outlines, methods contains unit tests MyTreeMap", "In the repository for this book, you'll find these source files:\n- \"MyTreeMap.java\" contains the code from the previous section\n  with outlines for the missing methods.\n- \"MyTreeMapTest.java\" contains the unit tests for\n  \"MyTreeMap\"."], ["build compile source files", "Run \"ant build\" to compile the source files. Then run \"ant"], ["Several tests, e k, next chapter r solutions, performance core methods", "  MyTreeMapTest\".  Several tests should fail, because you have e k to do!\nWhen you are done, all tests should pass. In the next chapter, I'll o r my solutions and test the performance of the core methods."], ["containsKey f use findNode private method, part Map interface, private Node findNode Object target target null throw new IllegalArgumentException SuppressWarnings, Comparable super K k Comparable super K target TODO FILL, null parameter target", "I've provided outlines for \"get\" and \"containsKey\".  Both f m use \"findNode\", which is a private method I defined; it s t part of the \"Map\" interface. Here's how it starts:\n    private Node findNode(Object target) {\n        if (target == null) {\n            throw new IllegalArgumentException();\n        }\n        @SuppressWarnings(\"unchecked\")\n        Comparable<? super K> k = (Comparable<? super K>) target;\n        // TODO: FILL THIS IN!\n        return null;\n    }\nThe parameter \"target\" is the key we're looking for. If\n\"target\" is \"null\", \"findNode\" throws an exception.\nSome implementations of \"Map\" can handle \"null\" as a key,\nThe next lines show how we can compare \"target\" to a key in e e. From the signature of \"get\" and \"containsKey\", e r considers \"target\" to be an \"Object\". But we d o be able to compare keys, so we typecast \"target\" to\nFortunately, dealing with Java's type system is not the point of s e. Your job is to fill in the rest of \"findNode\". If t s a node that contains \"target\" as a key, it should n e node. Otherwise it should return \"null\". When you get s g, the tests for \"get\" and \"containsKey\" d s.\nUnlike your previous solution for \"findNode\", your solution for\n  starter code that handles the simple cases:\n    public V put(K key, V value) {\n        if (key == null) {\n            throw new IllegalArgumentException();\n        }\n        if (root == null) {\n            root = new Node(key, value);\n            size++;\n            return null;\n        }\n        return putHelper(root, key, value);\n    }\n    private V putHelper(Node node, K key, V value) {\n        // TODO: Fill this in.\n    }\n\"HashSet\" implementation of \"Set\", which we used n n~\\ref{exercise6}, doesn't maintain the order of the keys, t e \"LinkedHashSet\" implementation does.  You can read about t t http://thinkdast.com/linkedhashset.\n\"LinkedHashSet\":\n    public Set<K> keySet() {\n        Set<K> set = new LinkedHashSet<K>();\n        return set;\n    }"], ["binary search tree, able compare keys, null problematic keep things simple implementation, null key target, key Note values", "but in a binary search tree, we need to be able to compare keys, o g with \"null\" is problematic. To keep things simple,\nthis implementation does not allow \"null\" as a key.\n\"target\" and a given key. Note that the values in the tree (s d to the keys) are not necessarily comparable, so we can't use\n\"compareTo\"; we have to invoke \"equals\" on \"target\".\n\"containsValue\" does have to search the whole tree, so s e is proportional to the number of keys, n, not e t of the tree, \"h\".\nIf you try to put \"null\" as a key, \"put\" throws n n.\nFill in \"putHelper\" so it searches the tree and:\n- If \"key\" is already in the tree, it replaces the old value with\n  the new, and returns the old value.\n- If \"key\" is not in the tree, it creates a new node, finds the\n  right place to add it, and returns \"null\".\nYou should finish off this method so it adds the keys from the tree to"], ["Comparable super K, comparable instance type K superclass K familiar use e", "\"Comparable<? super K>\", which means t t is comparable to an instance of type \"K\", or any superclass of\n\"K\".  If you are not familiar with this use of \"e s\", you can read more t p://thinkdast.com/gentut."], ["Note solution search, path tree, time proportional height tree search whole tree tree, new node e instance variable root implementation, time proportional e tree h number elements Ideally u search tree", "Note that your solution should only search one path through the tree, o t should take time proportional to the height of the tree. You d t search the whole tree!\nIf the tree is empty, \"put\" creates a new node and s e instance variable \"root\".\nYour implementation of \"put\" should take time proportional to e t of the tree, h, not the number of elements, n. Ideally u d search the tree only once, but if you find it easier to h e, you can do that; it will be slower, but it doesn't change e r of growth.\n\"set\" in ascending order. HINT: you might want to write a r d; you might want to make it recursive; and you might want o d about in-order tree traversal t p://thinkdast.com/inorder."], ["next task fill containsValue get, next method fill", "Your next task is to fill in \"containsValue\". To get you started,\nThe next method you should fill in is \"put\". I've provided"], ["helper method equals, compareTo method", "I've provided a helper method, \"equals\", that compares\nin increasing order according to the \"compareTo\" method.  The"], ["putHelper private method", "Otherwise, it calls \"putHelper\", which is a private method I"], ["part Map interface", "defined; it is not part of the \"Map\" interface."], ["e documentation http return Set, keys order, outline keySet creates returns", "Finally, you should fill in the body of \"keySet\".  According o e documentation at http://thinkdast.com/mapkeyset, this d d return a \"Set\" that iterates the keys in order; that is,\nI've provided an outline of \"keySet\" that creates and returns a"], ["TODO help recursion", "% TODO: more help with recursion?"], ["previous exercise, outline MyTreeMap fill, findNode private Node findNode Object target implementations, null key, target null throw new IllegalArgumentException something", "In the previous exercise I gave you the outline of \"MyTreeMap\" d d you to fill in the missing methods. Now I'll present a n, starting with \"findNode\":\nprivate Node findNode(Object target) {\n    // some implementations can handle null as a key, but not this one\n    if (target == null) {\n            throw new IllegalArgumentException();\n    }\n    // something to make the compiler happy\n    @SuppressWarnings(\"unchecked\")\n    Comparable<? super K> k = (Comparable<? super K>) target;\n    // the actual search\n    Node node = root;\n    while (node != null) {\n        int cmp = k.compareTo(node.key);\n        if (cmp < 0)\n            node = node.left;\n        else if (cmp > 0)\n            node = node.right;\n        else\n            return node;\n    }\n    return null;\n}\n\"findNode\" is a private method used by \"containsKey\" and\n\"get\"; it is not part of the \"Map\" interface. e r \"target\" is the key we're looking for. I explained e t part of this method in the previous exercise:\n- In this implementation, \"null\" is not a legal value for a key.\n- Before we can invoke \"compareTo\" on \"target\", we have to\n  typecast it to some kind of \"Comparable\". The \"type wildcard\"\n  used here is as permissive as possible; that is, it works with any\n  type that implements \"Comparable\" and whose \"compareTo\"\n  method accepts \"K\" or any supertype of \"K\"."], ["actual search, p variable node refers, node e h loop, current key move, child r move", "After all that, the actual search is relatively simple. We initialize a p variable \"node\" so it refers to the root node. Each e h the loop, we compare the target to \"node.key\". If e t is less than the current key, we move to the left child. If it's r, we move to the right child. And if it's equal, we return e t node."], ["bottom tree, target e e tree return null", "If we get to the bottom of the tree without finding the target, e e that it is not in the tree and return \"null\"."], ["previous exercise runtime", "As I explained in the previous exercise, the runtime of"], ["findNode proportional height tree e r, search whole tree r containsValue search values, BST property apply values, e e tree containsValue, target value parameter invokes", "\"findNode\" is proportional to the height of the tree, not e r of nodes, because we don't have to search the whole tree. t r \"containsValue\", we have to search the values, not the keys;\nthe BST property doesn't apply to the values, so we have to search e e tree.\n\"containsValue\" takes the target value as a parameter d y invokes \"containsValueHelper\", passing the root f e tree as an additional parameter."], ["solution recursive public boolean containsValue Object target return containsValueHelper root target private boolean containsValueHelper Node node Object target node null return false equals, true containsValueHelper target, true containsValueHelper target, true return false containsValueHelper, first statement checks base case recursion", "My solution is recursive:\npublic boolean containsValue(Object target) {\n    return containsValueHelper(root, target);\n}\nprivate boolean containsValueHelper(Node node, Object target) {\n    if (node == null) {\n        return false;\n    }\n    if (equals(target, node.value)) {\n        return true;\n    }\n    if (containsValueHelper(node.left, target)) {\n        return true;\n    }\n    if (containsValueHelper(node.right, target)) {\n        return true;\n    }\n    return false;\n}\nHere's how \"containsValueHelper\" works:\n- The first \"if\" statement checks the base case of the recursion.\n  If \"node\" is \"null\", that means we have recursed to the\n  bottom of the tree without finding the \"target\", so we should\n  return \"false\". Note that this only means that the target did\n  not appear on one path through the tree; it is still possible that it\n  will be found on another.\n- The second case checks whether we've found what we're looking for. If\n  so, we return \"true\". Otherwise, we have to keep going.\n- The third case makes a recursive call to search for \"target\" in\n  the left subtree. If we find it, we can return \"true\"\n  immediately, without searching the right subtree. Otherwise, we keep\n  going.\n- The fourth case searches the right subtree. Again, if we find what we\n  are looking for, we return \"true\". Otherwise, having searched\n  the whole tree, we return \"false\"."], ["method visits every node tree, e l number nodes", "This method \"visits\" every node in the tree, so it takes e l to the number of nodes."], ["last method, write keySet Set, order implementations Map keys, keySet particular order, f tree implementation simple efficient e keys", "The last method I asked you to write is \"keySet\", which s a \"Set\" that contains the keys from the tree in ascending order.\nIn other implementations of \"Map\", the keys returned by\n\"keySet\" are in no particular order, but one of the s f the tree implementation is that it is simple and efficient to t e keys. So we should take advantage of that.\nIn \"keySet\", we create a \"LinkedHashSet\", which is a\n\"addInOrder\" to traverse the tree.\nThe first parameter, \"node\", is initially the root of the tree,\nbut as you should expect by now, we use it to traverse the e y. \"addInOrder\" performs a classic \"in-r l\" of the tree.\nApplying the same argument recursively, we know that the elements m e left subtree are in order, as well as the elements from the t e.  And the base case is correct: if the subtree is empty, o s are added.  So we can conclude that this method adds all keys n e correct order.\nBecause this method visits every node in the tree, like"], ["solution public Set K keySet Set K, new LinkedHashSet K addInOrder root, private void addInOrder Node node Set K, node null return addInOrder, addInOrder set", "Here's my solution:\npublic Set<K> keySet() {\n    Set<K> set = new LinkedHashSet<K>();\n    addInOrder(root, set);\n    return set;\n}\nprivate void addInOrder(Node node, Set<K> set) {\n    if (node == null) return;\n    addInOrder(node.left, set);\n    set.add(node.key);\n    addInOrder(node.right, set);\n}"], ["Set implementation, elements order e Set implementations", "\"Set\" implementation that keeps the elements in order (e t other \"Set\" implementations). Then we call"], ["node null, subtree empty e return, Otherwise Traverse, subtree order Add Traverse, order Remember BST property guarantees", "If \"node\" is \"null\", that means the subtree is empty, o e return without adding anything to \"set\". Otherwise we:\n- Traverse the left subtree in order.\n- Add \"node.key\".\n- Traverse the right subtree in order.\nRemember that the BST property guarantees that all nodes in the t e are less than \"node.key\", and all nodes in the t e are greater. So we know that \"node.key\" has been added n e correct order."], ["time proportional n", "\"containsValue\", it takes time proportional to n."], ["MyTreeMap methods, e proportional height tree e, tree full every level, maximum number nodes, tree l log", "In \"MyTreeMap\", the methods \"get\" and \"put\" e e proportional to the height of the tree, h. In the s e, we showed that if the tree is full --- if every level of the e s the maximum number of nodes --- the height of the tree s l to log n.\nAnd I claimed that \"get\" and \"put\" are logarithmic; t s, they take time proportional to log n. But for t s, there's no guarantee that the tree is full. In general,\nthe shape of the tree depends on the keys and what order they are added.\nI ran this code with \"n=16384\" and measured the runtime and e t of the final tree. Here's the output:\nTime in milliseconds = 151\nFinal size of MyTreeMap = 16384\nlog base 2 of size of MyTreeMap = 14.0\nFinal height of MyTreeMap = 33\nI included \"log base 2 of size of MyTreeMap\" to see how tall the e d be if it were full. The result indicates that a full tree h t 14 would contain 16,384 nodes.\nThe actual tree of random strings has height 33, which is y e than the theoretical minimum, but not too bad. To find one key in a n of 16,384, we only have to make 33 comparisons. Compared to a r search, that's almost 500 times faster.\nThis performance is typical with random strings or other keys that e d in no particular order. The final height of the tree might be 2-3\nlog n grows so slowly as n increases, it can e t to distinguish logarithmic time from constant time n e.\nAnd let's see what happens when we run it:\nTime in milliseconds = 1158\nFinal size of MyTreeMap = 16384\nlog base 2 of size of MyTreeMap = 14.0\nFinal height of MyTreeMap = 16384\nlonger. If you wonder why, take a look at the final height of the tree:\nIf you think about how \"put\" works, you can figure out what's g on. Every time we add a new key, it's larger than all of the s n the tree, so we always choose the right subtree, and always add e w node as the right child of the rightmost node. The result is an\n\"unbalanced\" tree that only contains right children.\nThe height of this tree is proportional to n, t g n, so the performance of \"get\" and \"put\" s r, not logarithmic.\n  In the balanced tree, the height is 4 and the total number f s is 2^4-1 = 15.  In the unbalanced tree with the same number f s, the height is 15."], ["works practice test n h, sample datasets list random strings list", "To see how this works out in practice, we'll test our n h two sample datasets: a list of random strings and a list f s in increasing order."], ["code generates, strings Map String Integer, new MyTreeMap String Integer int n String, UUID class package n e random, unique identifier UUIDs l r variety applications example", "Here's the code that generates random strings:\nMap<String, Integer> map = new MyTreeMap<String, Integer>();\nfor (int i=0; i<n; i++) {\n    String uuid = UUID.randomUUID().toString();\n    map.put(uuid, 0);\n}\n\"UUID\" is a class in the \"java.util\" package that n e a random \"universally unique identifier\". UUIDs are l r a variety of applications, but in this example we're g e of an easy way to generate random strings.\nHowever, binary search trees don't always behave so well. Let's see t s when we add keys in increasing order. Here's an example t s timestamps in nanoseconds and uses them as keys:\nMyTreeMap<String, Integer> map = new MyTreeMap<String, Integer>();\nfor (int i=0; i<n; i++) {\n    String timestamp = Long.toString(System.nanoTime());\n    map.put(timestamp, 0);\n}"], ["times theoretical minimum, proportional g", "times the theoretical minimum, but it is still proportional o g n, which is much less than n. In fact,"], ["elapsed time nanoseconds time call, number convert timestamps strings, previous case", "\"System.nanoTime\" returns an integer with type \"long\" t s elapsed time in nanoseconds. Each time we call it, we get a t bigger number. When we convert these timestamps to strings,\nThe runtime is more than seven times longer than in the previous case."], ["alphabetical order", "they appear in increasing alphabetical order."], ["possible solutions problem, keys Map order, keys happen order second solution, several ways, common modify", "There are two possible solutions to this problem:\n- You could avoid adding keys to the \"Map\" in order. But this is\n  not always possible.\n- You could make a tree that does a better job of handling keys if they\n  happen to be in order.\nThe second solution is better, and there are several ways to do it. e t common is to modify \"put\" so that it detects when the e s starting to become unbalanced and, if so, rearranges the nodes. s h this capability are called \"self-balancing\". n f-balancing trees include the AVL tree (\"AVL\" are the initials f e inventors), and the red-black tree, which is what the Java\n\"TreeMap\" uses.\n\"put\" in logarithmic time, but only if the keys are added in n r that keeps the tree sufficiently balanced. Self-balancing s d this problem by doing some additional work each time a new key s d."], ["example code, MyTreeMap Java", "In our example code, if we replace \"MyTreeMap\" with the Java"], ["random timestamps fact timestamps, e order, time hash", "\"TreeMap\", the runtimes are about the same for the random s d the timestamps. In fact, the timestamps run faster, even though y e in order, probably because they take less time to hash."], ["summary binary search tree implement get", "In summary, a binary search tree can implement \"get\" and"], ["read trees", "You can read more about self-balancing trees t p://thinkdast.com/balancing."], ["previous exercise implement", "In the previous exercise you didn't have to implement \"remove\","], ["node middle f e tree rearrange, BST Removing node, tree similar operations, idea k", "but you might want to try it. If you remove a node from the middle f e tree, you have to rearrange the remaining nodes to restore the BST\nRemoving a node and rebalancing a tree are similar operations: if you o s exercise, you will have a better idea of how self-balancing s k."], ["figure r u read explanation p", "property.  You can probably figure out how to do that on your own, r u can read the explanation t p://thinkdast.com/bstdel."], ["previous version indexer stores index, TermCounter maps, term e r times, web page Index search term", "The previous version of the indexer stores the index in two a s: a \"TermCounter\" that maps from a search term to e r of times it appears on a web page, and an \"Index\" t s from a search term to the set of pages where it appears."], ["data structures, means program stops, index Data, Data persists program, persistent general files", "These data structures are stored in the memory of a running a m, which means that when the program stops running, the index s t. Data stored only in the memory of a running program is called\nData that persists after the program that created it ends is called\n\"persistent\". In general, files stored in a file system e t, as well as data stored in databases.\nA simple way to make data persistent is to store it in a file. e e program ends, it could translate its data structures into a t e JSON (http://thinkdast.com/json) and then write m o a file. When it starts again, it could read the file and d e data structures.\nBut there are several problems with this solution:\n- Reading and writing large data structures (like a Web index) would be\n  slow.\n- The entire data structure might not fit into the memory of a single\n  running program.\n- If a program ends unexpectedly (for example, due to a power outage),\n  any changes made since the program last started would be lost.\nThe database I recommend for this exercise is Redis, which s t data structures that are similar to Java data structures."], ["program ends", "\"volatile\", because it vaporizes when the program ends."], ["alternative database, persistent storage e ability, write parts database, g whole thing many kinds database management systems DBMS e capabilities, overview p", "A better alternative is a database that provides persistent storage d e ability to read and write parts of the database without reading d g the whole thing.\nThere are many kinds of database management systems (DBMS) that e t capabilities. You can read an overview t p://thinkdast.com/database."], ["Lists strings similar Java List Hashes similar Java Map Sets, similar Java Set", "Specifically, it provides:\n- Lists of strings, similar to Java \"List\".\n- Hashes, similar to Java \"Map\".\n- Sets of strings, similar to Java \"Set\"."], ["Redis database, data contains values, unique strings keys key Redis, role reference Java n object", "Redis is a \"key-value database\", which means that the data s t contains (the values) are identified by unique strings (the keys). A\nkey in Redis plays the same role as a reference in Java: it s n object. We'll see some examples soon."], ["remote service fact name, REmote DIctionary Server use Redis run r, Redis client e ways, many clients, e recommend Rather install", "Redis is usually run as a remote service; in fact, the name stands for\n\"REmote DIctionary Server\". To use Redis, you have to run the s r somewhere and then connect to it using a Redis client. There e y ways to set up a server and many clients you could use. For s e, I recommend:\n- Rather than install and run the server yourself, consider using a\n  service like RedisToGo (http://thinkdast.com/redistogo), which runs\n  Redis in the cloud. They offer a free plan with enough resources for\n  the exercise.\n- For the client I recommend Jedis, which is a Java library that\n  provides classes and methods for working with Redis.\nHere are more detailed instructions to help you get started:\n- Create an account on RedisToGo, at\n  http://thinkdast.com/redissign,\n  and select the plan you want (probably the free plan to get started).\n- Create an \"instance\", which is a virtual machine running the Redis\n  server. If you click on the \"Instances\" tab, you should see your new\n  instance, identified by a host name and a port number. For example, I\n  have an instance named \"dory-10534\".\n- Click on the instance name to get the configuration page. Make a note\n  of the URL near the top of the page, which looks like this:\n  \\begin{verbatim}\n  redis://redistogo:1234567feedfacebeefa1e1234567@dory.redistogo.com:10534"], ["host name", "This URL contains the server's host name, \"dory.redistogo.com\","], ["port number, password need, information next step", "the port number, \"10534\", and the password you will need o t to the server, which is the long string of letters and s n the middle. You will need this information for the next step."], ["repository book", "In the repository for this book,"], ["source files, example code, Redis server, Jedis methods, starter code exercise", "you'll find the source files for this exercise:\n- \"JedisMaker.java\" contains example code for connecting to a\n  Redis server and running a few Jedis methods.\n- \"JedisIndex.java\" contains starter code for this exercise.\n- \"JedisIndexTest.java\" contains test code for\n  \"JedisIndex\".\n- \"WikiFetcher.java\" contains the code we saw in previous exercises to\n  read web pages and parse them using jsoup.\nYou will also need these files, which you worked on in s s:\n- \"Index.java\" implements an index using Java data structures.\n- \"TermCounter.java\" represents a map from terms to their\n  frequencies.\n- \"WikiNodeIterable.java\" iterates through the nodes in a DOM\n  tree produced by jsoup.\nThe first step is to use Jedis to connect to your Redis server.\n\"RedisMaker.java\" shows how to do this. It reads n t your Redis server from a file, connects to it and logs in g r password, then returns a \"Jedis\" object you can use o m Redis operations.\nIf you open \"JedisMaker.java\", you should see the\n\"JedisMaker\" class, which is a helper class that provides e c method, \"make\", which creates a \"Jedis\" object. e s object is authenticated, you can use it to communicate with r s database.\n\"JedisMaker\" reads information about your Redis server from a e named \"redis_url.txt\", which you should put in e y \"src/resources\":\n- Use a text editor to create end edit\n  \"ThinkDataStructures/code/src/resources/redis_url.txt\".\n- Paste in the URL of your server. If you are using RedisToGo, the URL\n  will look like this:\n\"redis://redistogo:1234567feedfacebeefa1e1234567@dory.redistogo.com:10534\"\nNow run \"ant build\" to compile e e files and \"ant JedisMaker\" to run the example code in\n\"main\":\n    public static void main(String[] args) {\n        Jedis jedis = make();\n        // String\n        jedis.set(\"mykey\", \"myvalue\");\n        String value = jedis.get(\"mykey\");\n        System.out.println(\"Got value: \" + value);\n        // Set\n        jedis.sadd(\"myset\", \"element1\", \"element2\", \"element3\");\n        System.out.println(\"element2 is member: \" +\n                           jedis.sismember(\"myset\", \"element2\"));\n        // List\n        jedis.rpush(\"mylist\", \"element1\", \"element2\", \"element3\");\n        System.out.println(\"element at index 1: \" +\n                           jedis.lindex(\"mylist\", 1));\n        // Hash\n        jedis.hset(\"myhash\", \"word1\", Integer.toString(2));\n        jedis.hincrBy(\"myhash\", \"word2\", 1);\n        System.out.println(\"frequency of word1: \" +\n                           jedis.hget(\"myhash\", \"word1\"));\n        System.out.println(\"frequency of word1: \" +\n                            jedis.hget(\"myhash\", \"word2\"));\n        jedis.close();\n    }"], ["versions files, r exercise previous exercises u e confident solutions", "If you have working versions of these files, you can use them r s exercise.  If you didn't do the previous exercises, or u e not confident in your solutions, you can copy my s m the {\\tt solutions} folder."], ["file contains, Redis server u, file public repository help, accident repository contains", "Because this file contains the password for your Redis server, u d not put this file in a public repository. To help you d g that by accident, the repository contains a {\\tt .gitignore}"], ["impossible put e n repo", "file that makes it harder (but not impossible) to put this e n your repo."], ["data types methods, exercise run output Got value e t2 member e index, element2 frequency", "This example demonstrates the data types and methods you are most y o use for this exercise. When you run it, the output should be:\nGot value: e t2 is member: e t at index 1: element2\nfrequency of word1: 2\nfrequency of word2: 1"], ["next section explain code works", "In the next section, I'll explain how the code works."], ["keys strings, several data types basic type, write Redis types, distinguish Java types Redis, set structure r Java Set String add elements Redis", "Redis is basically a map from keys, which are strings, o s, which can be one of several data types. The most basic s a type is a \\redis{string}.  I will write Redis types n s to distinguish them from Java types.\nRedis provides a \\redis{set} structure, which s r to a Java\n\"Set<String>\". To add elements to a Redis \\redis{set},\nyou choose a key to identify the \\redis{set} and then use\nYou don't have to create the \\redis{set} as a separate step. If it doesn't t, Redis creates it. In this case, it creates a \\redis{set} named\nRedis also provides a \\redis{list} structure, which s r to a Java\nFinally, Redis provides a \\redis{hash} structure, which is similar to a Java\n\"Map<String, String>\". The method\nThis example creates a \\redis{hash} named \"myhash\" that contains e y, which maps from the key \"word1\" to the value \"\"2\"\".\nThe keys and values are \\redis{string}s, so if we want to e n \"Integer\", we have to convert it o a \"String\" before we call \"hset\".\nWorking with Redis \\redis{hash}es can be confusing, because we use a key o y which \\redis{hash} we want, and then another key to identify a value n e \\redis{hash}. In the context of Redis, the second key is called a \"field\",\nidentifies a particular \\redis{hash}, and then a \"field\" like \"word1\"\nidentifies a value in the \\redis{hash}.\nFor many applications, the values in a Redis \\redis{hash} are integers, so s s a few special methods, like \"hincrby\", that treat e s as numbers:\n        jedis.hincrBy(\"myhash\", \"word2\", 1);\n1, and writes the result back to the \\redis{hash}.\nYou can read more about Redis data types t p://thinkdast.com/redistypes."], ["use similar e new key, value look, value use mykey myvalue, value mykey example key mykey value, element1 element2 element3 boolean flag myset element2 method", "use \"jedis.set\", which is similar to \"Map.put\"; e s are the new key and the corresponding value. To look up a y and get its value, use \"jedis.get\":\n        jedis.set(\"mykey\", \"myvalue\");\n        String value = jedis.get(\"mykey\");\nIn this example, the key is \"\"mykey\"\" and the value is\n\"jedis.sadd\":\n        jedis.sadd(\"myset\", \"element1\", \"element2\", \"element3\");\n        boolean flag = jedis.sismember(\"myset\", \"element2\");\nThe method \"jedis.sismember\" checks whether an element is in a\n\"jedis.rpush\" adds elements to the end (right side) of a\n\\redis{list}:\n        jedis.rpush(\"mylist\", \"element1\", \"element2\", \"element3\");\n        String element = jedis.lindex(\"mylist\", 1);\nThe method \"jedis.lindex\" takes an integer index and returns e d element of a \\redis{list}. Adding and accessing elements e t time operations.\n\"jedis.hset\" adds a new entry to the \\redis{hash}:\n        jedis.hset(\"myhash\", \"word1\", Integer.toString(2));\n        String value = jedis.hget(\"myhash\", \"word1\");"], ["myset contains, structure g elements example", "\"myset\" that contains three elements.\nAgain, you don't have to create the structure before you t g elements. This example creates a \\redis{list} named \"mylist\" t s three elements."], ["Adding elements, membership constant e, constant e", "\\redis{set}. Adding elements and checking membership are constant e s.\nSetting, getting, and incrementing entries in a \\redis{hash} are constant e s."], ["List String method", "\"List<String>\". The method"], ["look value", "And when we look up the value using \"hget\","], ["k Integer", "the result is a \"String\", so we might have to convert it k o \"Integer\"."], ["current value h", "This method accesses \"myhash\", gets the current value d h \"word2\" (or 0 if it doesn't already exist), increments it by"], ["point information, exercise u get, ready suggestions, exercise provide, guidance previous exercises", "At this point you have all the information you need to do the exercise, o u can get started if you are ready. But I have a few suggestions u t want to read first:\n- For this exercise I provide less guidance than in previous\n  exercises.  You will have to make some design decisions; in\n  particular, you will have to figure out how to divide the problem\n  into pieces that you can test one at a time, and then assemble the\n  pieces into a complete solution. If you try to write the whole thing\n  at once, without testing smaller pieces, it might take a very long\n  time to debug.\n- One of the challenges of working with persistent data is that it is\n  persistent. The structures stored in the database might change every\n  time you run the program. If you mess something up in the database,\n  you will have to fix it or start over before you can proceed. To help\n  you keep things under control, I've provided methods called\n  \"deleteURLSets\", \"deleteTermCounters\", and\n  \"deleteAllKeys\", which you can use to clean out the database\n  and start fresh. You can also use \"printIndex\" to print the\n  contents of the index.\n- Each time you invoke a \"Jedis\" method, your client sends a\n  message to the server, then the server performs the action you\n  requested and sends back a message. If you perform many small\n  operations, it will probably take a long time. You can improve\n  performance by grouping a series of operations into a\n  \"Transaction\".\nthis method would take a long time to run. We can speed it up with a"], ["example simple version deleteAllKeys public void deleteAllKeys Set String keys, key keys key Transaction, void deleteAllKeys Set String keys Transaction String key keys", "For example, here's a simple version of \"deleteAllKeys\":\n    public void deleteAllKeys() {\n        Set<String> keys = jedis.keys(\"*\");\n        for (String key: keys) {\n            jedis.del(key);\n        }\n    }\n\"Transaction\" object:\n    public void deleteAllKeys() {\n        Set<String> keys = jedis.keys(\"*\");\n        Transaction t = jedis.multi();\n        for (String key: keys) {\n            t.del(key);\n        }\n        t.exec();\n    }"], ["time invoke del, index contains pages", "Each time you invoke \"del\" requires a round-trip from the t o the server and back. If the index contains more than a few pages,"], ["returns Transaction, h methods Jedis, e method Transaction, communicate server, h operations", "\"jedis.multi\" returns a \"Transaction\" object, h s all the methods of a \"Jedis\" object. But when you e a method on a \"Transaction\", it doesn't run the n y, and it doesn't communicate with the server. It saves up a h of operations until you invoke \"exec\". Then it sends all f e saved operations to the server at the same time, which is y h faster."], ["information need, w get", "Now you really have all the information you need; you d t working on the exercise. But if you get stuck, or if you really don't w how to get started, you can come back for a few more hints."], ["code basic Redis commands, tests first figure w test method", "\\textbf{Don't read the following until you have run the test code, d t some basic Redis commands, and written a few methods in\nFor each method, consider writing the tests first. When you figure t w to test a method, you often get ideas about how to write it."], ["k Adds URL, associated term public void, term TermCounter tc Looks search term returns, URLs public Set String getURLs, term Returns number times", "OK, if you are really stuck, here are some methods you might want o k on:\n    /**\n     * Adds a URL to the set associated with term.\n     */\n    public void add(String term, TermCounter tc) {}\n    /**\n     * Looks up a search term and returns a set of URLs.\n     */\n    public Set<String> getURLs(String term) {}\n    /**\n     * Returns the number of times the given term appears at the given URL.\n     */\n    public Integer getCount(String url, String term) {}\n    /**\n     * Pushes the contents of the TermCounter to Redis.\n     */\n    public List<Object> pushTermCounterToRedis(TermCounter tc) {}"], ["solution way divide things, f help", "These are the methods I used in my solution, but they are y t the only way to divide things up. So please take these s f they help, but ignore them if they don't."], ["Good luck", "Good luck!"], ["solution store, kinds structures Redis, term URLSet Redis, URLs contain search term URL TermCounter Redis hash maps, term number times", "In my solution, we store two kinds of structures in Redis:\n- For each search term, we have a \"URLSet\", which is a Redis \\redis{set}\n  of URLs that contain the search term.\n- For each URL, we have a \"TermCounter\", which is a Redis \\redis{hash}\n  that maps each search term to the number of times it appears.\nWe discussed these data types in the previous chapter. You can o d about Redis structures at http://thinkdast.com/redistypes\nIn \"JedisIndex\", I provide a method that takes a search m d returns the Redis key of its \"URLSet\":\nprivate String urlSetKey(String term) {\n    return \"URLSet:\" + term;\n}\nAnd a method that takes a URL and returns the Redis key of its\nHere's the new code that pushes a \"TermCounter\" to Redis:\npublic List<Object> pushTermCounterToRedis(TermCounter tc) {\n    Transaction t = jedis.multi();\n    String url = tc.getLabel();\n    String hashname = termCounterKey(url);\n    // if this page has already been indexed, delete the old hash\n    t.del(hashname);\n    // for each term, add an entry in the TermCounter and a new\n    // member of the index\n    for (String term: tc.keySet()) {\n        Integer count = tc.get(term);\n        t.hset(hashname, term, count.toString());\n        t.sadd(urlSetKey(term), url);\n    }\n    List<Object> res = t.exec();\n    return res;\n}\nIt loops through the terms in the \"TermCounter\". For each one it\n- Finds or creates a \"TermCounter\" on Redis, then adds a field\n  for the new term.\n- Finds or creates a \"URLSet\" on Redis, then adds the current\n  URL.\nThe second part of the exercise asked you to write \"getCounts\", h s a search term and returns a map from each URL where the m s to the number of times it appears there. Here is my solution:\n    public Map<String, Integer> getCounts(String term) {\n        Map<String, Integer> map = new HashMap<String, Integer>();\n        Set<String> urls = getURLs(term);\n        for (String url: urls) {\n            Integer count = getCount(url, term);\n            map.put(url, count);\n        }\n        return map;\n    }\nThis method uses two helper methods:\n- \"getURLs\" takes a search term and returns the Set of URLs where\n  the term appears.\n- \"getCount\" takes a URL and a term and returns the number of\n  times the term appears at the given URL."], ["TermCounter private String termCounterKey String url return TermCounter url implementation indexPage, URL p Elements, contains DOM, index public void indexPage String url Elements, TermCounter count terms", "\"TermCounter\":\nprivate String termCounterKey(String url) {\n    return \"TermCounter:\" + url;\n}\nHere's the implementation of \"indexPage\", which takes a URL and a p \"Elements\" object that contains the DOM tree of e s we want to index:\npublic void indexPage(String url, Elements paragraphs) {\n    System.out.println(\"Indexing \" + url);\n    // make a TermCounter and count the terms in the paragraphs\n    TermCounter tc = new TermCounter(url);\n    tc.processElements(paragraphs);\n    // push the contents of the TermCounter to Redis\n    pushTermCounterToRedis(tc);\n}\nHere are the implementations:\n    public Set<String> getURLs(String term) {\n        Set<String> set = jedis.smembers(urlSetKey(term));\n        return set;\n    }\n    public Integer getCount(String url, String term) {\n        String redisKey = termCounterKey(url);\n        String count = jedis.hget(redisKey, term);\n        return new Integer(count);\n    }"], ["index page Make Java TermCounter contents page, code previous exercise Push contents TermCounter Redis TermCounter, new contents, new pages", "To index a page, we\n- Make a Java \"TermCounter\" for the contents of the page, using\n  code from a previous exercise.\n- Push the contents of the \"TermCounter\" to Redis.\n\"TermCounter\" before pushing the new contents.\nThat's it for indexing new pages."], ["Transaction collect operations, small operations way, index methods simple", "This method uses a \"Transaction\" to collect the operations d d them to the server all at once, which is much faster than sending a s of small operations.\nBecause of the way we designed the index, these methods are simple d t."], ["indexed delete", "If the page has already been indexed, we delete its old"], ["Suppose indexed N pages", "Suppose we have indexed N pages and discovered M"], ["unique search terms, search term getURLs, time proportional number URLs n search term rare terms, small number", "unique search terms. How long will it take to look up a search term?\n\"getURLs\" takes time proportional to the number of URLs t n the search term. For rare terms, that might be a small number,"], ["Think answer continue", "Think about your answer before you continue."], ["look search term run getCounts, map Runs getURLs get Set URLs URL Set, entry HashMap Inside, getCount finds", "To look up a search term, we run \"getCounts\", which\n- Creates a map.\n- Runs \"getURLs\" to get a Set of URLs.\n- For each URL in the Set, runs \"getCount\" and adds an entry\n  to a \"HashMap\".\nInside the loop, we run \"getCount\", which finds a"], ["common terms, large N", "but for common terms it might be as large as N."], ["TermCounter Redis, entry constant time operations, getCounts N, e runtime proportional number pages, e term", "\"TermCounter\" on Redis, looks up a term, and adds an entry to a p. Those are all constant time operations, so the l y of \"getCounts\" is O(N) in the worst case. However, n e the runtime is proportional to the number of pages that n e term, which is normally much less than N."], ["algorithm efficient terms, c complexity, many l Redis", "This algorithm is as efficient as it can be, in terms f c complexity, but it is very slow because it sends many l s to Redis. You can make it faster using a"], ["exercise u n", "\"Transaction\". You might want to do that as an exercise, or u n see my solution in \"RedisIndex.java\"."], ["data structures, way improve performance, common words First, lot f, every URLSet", "Using the data structures we designed, how long will it take to index a e? Again, think about your answer before you continue.\nThis analysis suggests a way to improve performance: we should y d indexing very common words. First of all, they take up a lot f e and space, because they appear in almost every \"URLSet\" and"], ["index page traverse DOM tree find", "To index a page, we traverse its DOM tree, find all the"], ["split strings search terms", "\"TextNode\" objects, and split up the strings into search terms."], ["time proportional number words page term increment counter HashMap e operation, l number words page constant time operations total time h, number unique search terms, TermCounter proportional e r words page, TermCounter proportional number unique terms", "That all takes time proportional to the number of words on the page.\nFor each term, we increment a counter in a HashMap, which is a t e operation. So making the \"TermCounter\" takes e l to the number of words on the page.\nBoth of these are constant time operations, so the total time to h e \"TermCounter\" is linear in the number of unique search terms.\nIn summary, making the \"TermCounter\" is proportional to e r of words on the page. Pushing the \"TermCounter\" to s s proportional to the number of unique terms.\nSince the number of words on the page usually exceeds the number f e search terms, the overall complexity is proportional to e r of words on the page. In theory a page might contain all h s in the index, so the worst case performance is O(M), but we don't t to see the worse case in practice."], ["TermCounter Redis, term Add element URLSet Add element Redis TermCounter", "Pushing the \"TermCounter\" to Redis requires deleting a\nThen for each term we have to\n- Add an element to a \"URLSet\", and\n- Add an element to a Redis \"TermCounter\"."], ["TermCounter linear number unique terms", "\"TermCounter\", which is linear in the number of unique terms."], ["TermCounter Furthermore useful help, relevant pages", "\"TermCounter\". Furthermore, they are not very useful because y n't help identify relevant pages."], ["search engines, common words, stop words http", "Most search engines avoid indexing common words, which are known in s t as stop words (http://thinkdast.com/stopword)."], ["Philosophy exercise n getphilo, program reads, load next page program, kind crawler n e, Web crawler", "If you did the \"Getting to Philosophy\" exercise n r~\\ref{getphilo}, you already have a program that reads a a e, finds the first link, uses the link to load the next page, d s. This program is a specialized kind of crawler, but n e say \"Web crawler\" they usually mean a program that\n- Loads a starting page and indexes the contents,\n- Finds all the links on the page and adds the linked URLs to a collection,\n  and\n- Works its way through the collection, loading pages, indexing them, and\n  adding new URLs.\n- If it finds a URL that has already been indexed, it skips\n  it.\nStarting from a source node, a crawler traverses this graph,\nThe collection we use to store the URLs determines what kind f l the crawler performs:\n- If it's a first-in-first-out (FIFO) queue, the crawler performs a\n  breadth-first traversal.\n- If it's a last-in-first-out (LIFO) stack, the crawler performs a\n  depth-first traversal.\n- More generally, the items in the collection might be prioritized. For\n  example, we might want to give higher priority to pages that have not\n  been indexed for a long time.\nYou can read more about graph traversal t p://thinkdast.com/graphtrav."], ["e page node link, e another familiar graphs, reachable node", "You can think of the Web as a h e each page is a node and each link is a directed edge from one e o another. If you are not familiar with graphs, you can read t m at http://thinkdast.com/graph.\nvisiting each reachable node once."], ["solution previous exercise, n e WikiCrawler job fill crawl", "First, let's go over our solution to the previous exercise. I provided n e of \"WikiCrawler\"; your job was to fill in \"crawl\".\n\"WikiCrawler.queueInternalLinks\"."], ["reminder fields WikiCrawler class public class WikiCrawler, started private final String source index results, private JedisIndex index, URLs indexed private Queue String, new LinkedList String fetcher", "As a reminder, here are the fields in the \"WikiCrawler\" class:\npublic class WikiCrawler {\n    // keeps track of where we started\n    private final String source;\n    // the index where the results go\n    private JedisIndex index;\n    // queue of URLs to be indexed\n    private Queue<String> queue = new LinkedList<String>();\n    // fetcher used to get pages from Wikipedia\n    final static WikiFetcher wf = new WikiFetcher();\n}\nHere's my implementation of \"WikiCrawler.crawl\":\n    public String crawl(boolean testing) throws IOException {\n        if (queue.isEmpty()) {\n            return null;\n        }\n        String url = queue.poll();\n        System.out.println(\"Crawling \" + url);\n        if (testing==false && index.isIndexed(url)) {\n            System.out.println(\"Already indexed.\");\n            return null;\n        }\n        Elements paragraphs;\n        if (testing) {\n            paragraphs = wf.readWikipedia(url);\n        } else {\n            paragraphs = wf.fetchWikipedia(url);\n        }\n        index.indexPage(url, paragraphs);\n        queueInternalLinks(paragraphs);\n        return url;\n    }\nMost of the complexity in this method is there to make it easier o t. Here's the logic:\n- If the queue is empty, it returns \"null\" to indicate that it\n  did not index a page.\n- Otherwise it removes and stores the next URL from the queue.\n- If the URL has already been indexed, \"crawl\" doesn't index it\n  again, unless it's in testing mode.\n- Next it reads the contents of the page: if it's in testing mode, it\n  reads from a file; otherwise it reads from the Web.\n- It indexes the page.\n- It parses the page and adds internal links to the queue.\n- Finally, it returns the URL of the page it indexed."], ["create WikiCrawler provide source source", "When we create a \"WikiCrawler\", we provide \"source\" and\n\"source\"."], ["index Initially, element Notice implementation queue LinkedList object Queue, methods Queue interface, first version loops, second n real work void", "\"index\". Initially, \"queue\" contains only one element,\nNotice that the implementation of \"queue\" is a\n\"LinkedList\" object to a \"Queue\" variable, we t s to using methods in the \"Queue\" interface; specifically,\nThe first version just loops through the paragraphs. The second n s the real work.\n    void queueInternalLinks(Elements paragraphs) {\n        for (Element paragraph: paragraphs) {\n            queueInternalLinks(paragraph);\n        }\n    }\n    private void queueInternalLinks(Element paragraph) {\n        Elements elts = paragraph.select(\"a[href]\");\n        for (Element elt: elts) {\n            String relURL = elt.attr(\"href\");\n            if (relURL.startsWith(\"/wiki/\")) {\n                String absURL = elt.attr(\"abs:href\");\n                queue.offer(absURL);\n            }\n        }\n    }"], ["LinkedList add elements, constant time", "\"LinkedList\", so we can add elements at the end --- and e m from the beginning --- in constant time. By assigning a"], ["use offer add elements", "we'll use \"offer\" to add elements and \"poll\" to e m."], ["new method", "I presented an implementation of \"Index.indexPage\" n n~\\ref{redis-indexer}. So the only new method is"], ["different parameters, DOM tree r h, Element object, e paragraph", "I wrote two versions of this method with different parameters: e s an \"Elements\" object containing one DOM tree r h; the other takes an \"Element\" object that contains a e paragraph."], ["link internal check", "To determine whether a link is \"internal,\" we check whether the URL"], ["links pages languages", "starts with \"/wiki/\". This might include some pages we don't want o x, like meta-pages about Wikipedia. And it might exclude some s e want, like links to pages in non-English languages. But this e t is good enough to get started."], ["exercise lot new material", "That's all there is to it. This exercise doesn't have a lot of new material;"], ["chance bring pieces", "it is mostly a chance to bring the pieces together."], ["next phase project implement search tool, interface users, search terms, results lookup mechanism, search term returns pages", "The next phase of this project is to implement a search tool. The s e'll need include:\n- An interface where users can provide search terms and view results.\n- A lookup mechanism that takes each search term and returns the pages\n  that contain it.\n- Mechanisms for combining search results from multiple search terms.\n- Algorithms for ranking and sorting search results.\nThe general term for processes like this is \"information retrieval\",\nIn this exercise, we'll focus on steps 3 and 4. We've already built a e n of 2. If you are interested in building Web applications, u t consider working on step 1."], ["search engines, boolean searches, u n combine results multiple search terms, boolean logic Expressions, search terms operators", "Most search engines can perform \"boolean searches\", which means u n combine the results from multiple search terms using boolean logic.\nExpressions like these that contain search terms and operators e d \"queries\".\nWhen applied to search results, the boolean operators \"AND\","], ["example search java programming, search terms, java programming, either term, java contain indonesia intersection union difference r e suppose s1", "For example:\n- The search \"java AND programming\" might return only pages that\n  contain both search terms: \"java\" and \"programming\".\n- \"java OR programming\" might return pages that contain either term\n  but not necessarily both.\n- \"java -indonesia\" might return pages that contain \"java\" and do\n  not contain \"indonesia\".\n\"intersection\", \"union\", and \"difference\". r e, suppose\n- \"s1\" is the set of pages containing \"java\",\n- \"s2\" is the set of pages containing \"programming\", and\n- \"s3\" is the set of pages containing \"indonesia\".\nIn that case:\n- The intersection of \"s1\" and \"s2\" is the set of pages\n  containing \"java\" AND \"programming\".\n- The union of \"s1\" and \"s2\" is the set of pages\n  containing \"java\" OR \"programming\".\n- The difference of \"s1\" and \"s2\" is the set of pages\n  containing \"java\" and not \"indonesia\"."], ["next section write method implement operations", "In the next section you will write a method to implement these operations."], ["basic version exercise, k n optional exercises Read, document frequencies total number times term, pages index, search term total relevance page", "If you get a basic version of this exercise working, you might want to k n these optional exercises:\n- Read about TF-IDF at http://thinkdast.com/tfidf\n  and implement it. You might have to modify \"JavaIndex\" to\n  compute document frequencies; that is, the total number of times\n  each term appears on all pages in the index.\n- For queries with more than one search term, the total relevance for\n  each page is currently the sum of the relevance for each term. Think\n  about when this simple version might not work well, and try out some\n  alternatives.\n- Build a user interface that allows users to enter queries with\n  boolean operators. Parse the queries, generate the results, then\n  sort them by relevance and display the highest-scoring\n  URLs. Consider generating \"snippets\" that show where the search\n  terms appeared on the page. If you want to make a Web application\n  for your user interface, consider using Heroku as a simple option\n  for developing and deploying Web applications using Java.  See\n  http://thinkdast.com/heroku."], ["start insertion sort, simple e implement efficient g, read e n sort Wikipedia page p e, examples Come, l insertionSort", "We'll start with insertion sort, mostly because it is simple to e d implement. It is not very efficient, but it has some g s, as we'll see.\nRather than explain the algorithm here, I suggest you read e n sort Wikipedia page t p://thinkdast.com/insertsort, which s e and animated examples. Come back when you get the l a.\n\"insertionSort\" takes two parameters, a \"List\" of any d d a \"Comparator\" that knows how to compare type \"T\"\nIn the worst case, insertion sort is quadratic. However:\n- If the elements are already sorted, or nearly so, insertion sort is\n  linear. Specifically, if each element is no more than k\n  locations away from where it should be, the inner loop never runs more\n  than k times, and the total runtime is O(kn).\n- Because the implementation is simple, the overhead is low; that is,\n  although the runtime is a n^2, the coefficient of the leading\n  term, a, is probably small.\nSo if we know that the array is nearly sorted, or is not very big,\ninsertion sort might be a good choice. But for large arrays, we n o better. In fact, much better."], ["implementation insertion sort Java public class ListSorter public void insertionSort List list Comparator comparator int int j j, break j j j define class ListSorter container, type parameter e work lists, object type Integer, List Integer", "Here's an implementation of insertion sort in Java:\npublic class ListSorter<T> {\n    public void insertionSort(List<T> list, Comparator<T> comparator) {\n        for (int i=1; i < list.size(); i++) {\n            T elt_i = list.get(i);\n            int j = i;\n            while (j > 0) {\n                T elt_j = list.get(j-1);\n                if (comparator.compare(elt_i, elt_j) >= 0) {\n                    break;\n                }\n                list.set(j, elt_j);\n                j--;\n            }\n            list.set(j, elt_i);\n        }\n    }\n}\nI define a class, \"ListSorter\", as a container for t s. By using the type parameter, \"T\", we can e s that work on lists containing any object type.\n\"Integer\" objects:\n        List<Integer> list = new ArrayList<Integer>(\n            Arrays.asList(3, 5, 1, 4, 2));\n        Comparator<Integer> comparator = new Comparator<Integer>() {\n            @Override\n            public int compare(Integer elt1, Integer elt2) {\n                return elt1.compareTo(elt2);\n            }\n        };\n        ListSorter<Integer> sorter = new ListSorter<Integer>();\n        sorter.insertionSort(list, comparator);\n        System.out.println(list);"], ["objects sorts list place, g list, new space outer loop, r n size list n", "objects. It sorts the list \"in place\", which means it modifies e g list and does not have to allocate any new space.\nThe outer loop iterates from 1 to \"list.size()\", so it is r n the size of the list, n."], ["example shows, method List", "The following example shows how to call this method with a \"List\" of"], ["nested loops, quadratic case, correct jump conclusion check e r times, proportional n, f array Therefore total number times", "\"insertionSort\" has two nested loops, so you might guess t s runtime is quadratic. In this case, that turns out to be correct,\nbut before you jump to that conclusion, you have to check that e r of times each loop runs is proportional to n, the e f the array.\nTherefore, the total number of times the inner loop runs is quadratic.\nIf you are not sure about that, here's the argument:\n- The first time through, i=1 and the inner loop runs at most\n  once.\n- The second time, i=2 and the inner loop runs at most twice.\n- The last time, i=n-1 and the inner loop runs at most\n  n-1 times.\nSo the total number of times the inner loop runs is the sum of e s 1, 2, ... , n-1, which is n (n-1) / 2. And e g term of that expression (the one with the highest exponent) s n^2."], ["inner loop, linear n", "The inner loop iterates from \"i\" to 0, so it is also linear in n."], ["classify runtime merge sort, recursion much work, level e e start list contains n elements steps, e algorithm, new arrays", "To classify the runtime of merge sort, it helps to think in terms f s of recursion and how much work is done on each level. e e start with a list that contains n elements. Here are the steps f e algorithm:\n- Make two new arrays and copy half of the elements into each.\n- Sort the two halves.\n- Merge the halves.\nThe first step copies each of the elements once, so it is linear. e d step also copies each element once, so it is also linear. Now e d to figure out the complexity of step 2. To do that, it helps o s at a different picture of the computation, which shows the s f recursion, as in\nwe have to split the arrays in half, which takes time proportional o n on every level. On the way back up, we have to merge a l f n elements, which is also linear."], ["top level, list n elements simplicity, n power, next level, lists elements", "At the top level, we have 1 list with n elements.\nFor simplicity, let's assume n is a power of 2.\nAt the next level there are 2 lists with n/2 elements.\nThen 4 lists with n/4 elements, and so on until we t o n lists with 1 element.\nOn every level we have a total of n elements. On the way down,"], ["number levels, total amount work, many levels, many times, n half", "If the number of levels is h, the total amount of work for e m is O(nh). So how many levels are there? There are o s to think about that:\n- How many times do we have to cut n in half to get to 1?\n- Or, how many times do we have to double 1 before we get to n?\nAnother way to ask the second question is \"What power of 2 s n?\"\n2^h = n"], ["sides yields, n total time n log, write e e, logarithms different bases, constant factor logarithms order growth Algorithms", "Taking the log_2 of both sides yields\nh = log_2 n\nSo the total time is O(n log n). I didn't bother to write e e of the logarithm because logarithms with different bases differ y a constant factor, so all logarithms are in the same order of growth.\nAlgorithms in O(n log n) are sometimes called\nIt turns out that O(n log n) is the theoretical lower bound r t algorithms that work by comparing elements to each other. t s there is no \"comparison sort\" whose order of growth is r n n log n.  See http://thinkdast.com/compsort."], ["linearithmic people, n log n", "\"linearithmic\", but most people just say \"n log n\"."], ["next section, linear time", "But as we'll see in the next section, there are non-comparison s t take linear time!"], ["United States Presidential Campaign candidate k, perform impromptu algorithm analysis e Google Chief executive Eric Schmidt, efficient way sort, bubble sort, watch e http", "During the 2008 United States Presidential Campaign, candidate k a was asked to perform an impromptu algorithm analysis when e d Google. Chief executive Eric Schmidt jokingly asked him for\n\"the most efficient way to sort a million 32-bit integers.\" a d apparently been tipped off, because he quickly replied, \"I k e bubble sort would be the wrong way to go.\" You can watch e o at http://thinkdast.com/obama."], ["Obama right bubble sort, simple runtime c, quadratic sort algorithms e good See http answer Schmidt, radix sort sort algorithm, size e", "Obama was right: bubble sort is conceptually simple but its runtime s c; and even among quadratic sort algorithms, its e s not very good.  See http://thinkdast.com/bubble.\nThe answer Schmidt was probably looking for is \"radix sort\", which s a **non-comparison** sort algorithm that works if the size of e s is bounded, like a 32-bit integer or a 20-character string."], ["stack index cards, h card contains word, pass cards, first letter words, b Divide bucket", "To see how this works, imagine you have a stack of index cards e h card contains a three-letter word. Here's how you could sort e s:\n- Make one pass through the cards and divide them into buckets based on\n  the first letter. So words starting with \"a\" should be\n  in one bucket, followed by words starting with \"b\", and so on.\n- Divide each bucket again based on the second letter. So words starting\n  with \"aa\" should be together, followed by words starting with\n  \"ab\", and so on. Of course, not all buckets will be full, but\n  that's OK.\n- Divide each bucket again based on the third letter.\nAt this point each bucket contains one element, and the buckets e d in ascending order.\nThe top row shows the unsorted words. The second row shows what e s look like after the first pass. The words in each bucket n h the same letter.\nAfter the second pass, the words in each bucket begin with the same o s. After the third pass, there can be only one word in h t, and the buckets are in order."], ["pass iterate elements, long buckets, addition constant time h", "During each pass, we iterate through the elements and add them o s. As long as the buckets allow addition in constant time, h s is linear."], ["number passes, width words, number words", "The number of passes, which I'll call w, depends on the \"width\"\nof the words, but it doesn't depend on the number of words, n."], ["order growth, linear n", "So the order of growth is O(wn), which is linear in n."], ["many variations, many ways, read p l e, version radix sort", "There are many variations on radix sort, and many ways to t h one. You can read more about them t p://thinkdast.com/radix. As an l e, consider writing a version of radix sort."], ["addition radix sort applies things, heap sort, heap sort l, Top k value k, r example suppose monitoring Web service handles n transactions", "In addition to radix sort, which applies when the things you want o t are bounded in size, there is one other special-purpose g m you might encounter: bounded heap sort. Bounded heap sort s l if you are working with a very large dataset and you want o t the \"Top 10\" or \"Top k\" for some value of k h r than n.\nFor example, suppose you are monitoring a Web service that handles a n transactions per day. At the end of each day, you want o t the k biggest transactions (or slowest, or any r e). One option is to store all transactions, sort them t e end of the day, and select the top k. That would take e l to n log n, and it would be very slow because e y can't fit a billion transactions in the memory of a e m. We would have to use an \"out of core\" sort algorithm. u n read about external sorting at http://thinkdast.com/extsort.\nUsing a bounded heap, we can do much better! Here's how we l d:\n- I'll explain (unbounded) heap sort.\n- You'll implement it.\n- I'll explain bounded heap sort and analyze it.\nTo understand heap sort, you have to understand a heap, which is a a e similar to a binary search tree (BST). Here are the differences:\n- In a BST, every node, \"x\", has the \"BST property\": all nodes\n  in the left subtree of \"x\" are less than \"x\" and all\n  nodes in the right subtree are greater than \"x\".\n- In a heap, every node, \"x\", has the \"heap property\": all\n  nodes in both subtrees of \"x\" are greater than \"x\".\n- Heaps are like balanced BSTs; when you add or remove elements, they\n  do some extra work to rebalance the tree.  As a result, they can\n  be implemented efficiently using an array of elements.\nThe smallest element in a heap is always at the root, so we can d t in constant time. Adding and removing elements from a heap s e proportional to the height of the tree h. And because the p s always balanced, h is proportional to log n.  You can d e about heaps at http://thinkdast.com/heap.\nThis way of sorting is called heap sort (see http://thinkdast.com/heapsort).\nAdding n elements to the queue takes n log n time. So s removing n elements. So the runtime for heap sort is"], ["Java PriorityQueue, heap PriorityQueue, Queue interface, offer poll, Adds element queue", "The Java \"PriorityQueue\" is implemented using a heap.\n\"PriorityQueue\" provides the methods specified in the\n\"Queue\" interface, including \"offer\" and \"poll\":\n- \"offer\": Adds an element to the queue, updating the heap so\n  that every node has the \"heap property\". Takes log n time.\n- \"poll\": Removes the smallest element in the queue from the root\n  and updates the heap. Takes log n time.\nGiven a \"PriorityQueue\", you can easily sort of a collection f n elements like this:\n- Add all elements of the collection to a \"PriorityQueue\" using\n  \"offer\".\n- Remove the elements from the queue using \"poll\" and add them to\n  a \"List\".\nIn the repository for this book, in \"ListSorter.java\" you'll d e outline of a method called \"heapSort\". Fill it in and n n \"ant ListSorterTest\" to confirm that it works."], ["poll returns, e e elements", "Because \"poll\" returns the smallest element remaining in e e, the elements are added to the \"List\" in ascending order."], ["n log n", "O(n log n)."], ["heap heap, contain k n elements, track e k, empty element x Branch, heap full add x", "A bounded heap is a heap that is limited to contain at most k s. If you have n elements, you can keep track of e k largest elements like this:\nInitially, the heap is empty.  For each element, \"x\":\n- Branch 1: If the heap is not full, add \"x\" to the heap.\n- Branch 2: If the heap is full, compare \"x\" to the\n  smallest element in the heap. If \"x\" is smaller, it\n  cannot be one of the largest k elements, so you can discard\n  it.\n- Branch 3: If the heap is full and \"x\" is greater than the\n  smallest element in the heap, remove the smallest element from the\n  heap and add \"x\".\nUsing a heap with the smallest element at the top, we can keep track f e largest k elements. Let's analyze the performance of s m. For each element, we perform one of:\n- Branch 1: Adding an element to the heap is O(log k).\n- Branch 2: Finding the smallest element in the heap is O(1).\n- Branch 3: Removing the smallest element is O(log k). Adding\n  \"x\" is also O(log k).\n\"topK\" that takes a \"List\", a \"Comparator\", and n r k. It should return the k largest elements in the"], ["case elements, order n, case total time process, n log k linear n", "In the worst case, if the elements appear in ascending order, we s n Branch 3. In that case, the total time to process n s is O(n log k), which is linear in n."], ["outline method, ListSorterTest confirm works", "In \"ListSorter.java\" you'll find the outline of a method called\n  ListSorterTest\" to confirm that it works."], ["order Fill", "\"List\" in ascending order. Fill it in and then run \"ant"], ["lot runtime analysis, space example, e merge sort, copies data r, total amount space", "Until now we have talked a lot about runtime analysis, but for y s we are also concerned about space. For example, one of e s of merge sort is that it makes copies of the data. In r n, the total amount of space it allocates is\nIn contrast, insertion sort doesn't copy the data because it sorts e s in place. It uses temporary variables to compare two s t a time, and it uses a few other local variables. But its space e n't depend on n.\nO(1) space.\nOne of the benefits of the bounded heap algorithm you just d s that it only needs space proportional to k (the number f s we want to keep), and k is often much smaller n n.\nSoftware developers tend to pay more attention to runtime than space, d r many applications, that's appropriate. But for large datasets, e n be just as important or more so. For example:\n- If a dataset doesn't fit into the memory of one program, the run\n  time often increases dramatically, or it might not run at all. If you\n  choose an algorithm that needs less space, and that makes it possible\n  to fit the computation into memory, it might run much faster. In the\n  same vein, a program that uses less space might make better use of\n  CPU caches and run\n  faster (see http://thinkdast.com/cache).\n- On a server that runs many programs at the same time, if you can\n  reduce the space needed for each program, you might be able to run\n  more programs on the same server, which reduces hardware and energy\n  costs.\nSo those are some reasons you should know at least a little bit t e space needs of algorithms."], ["n log, clever implementation, e e requirement n", "O(n log n). With a more clever implementation, you can get e e requirement down to O(n)."], ["new PriorityQueue e elements space, e sort list place", "Our implementation of heap sort creates a new \"PriorityQueue\" o e the elements, so the space is O(n); but if you e d to sort the list in place, you can run heap sort with"]]}